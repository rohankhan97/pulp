//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V2021.2 (Build 1)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : env
// Unit            : siracusa_ral_pkg
// File            : siracusa_ral_pkg.sv
//----------------------------------------------------------------------
// Created by      : meggiman
// Creation Date   : 22.10.21 05:52
//----------------------------------------------------------------------
// Title           : env
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// siracusa_ral_pkg
//----------------------------------------------------------------------
package siracusa_ral_pkg;

   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: apb_soc_ctrl_corestatus
   // 
   // Software Run/Exit Status
   //--------------------------------------------------------------------

   class apb_soc_ctrl_corestatus extends uvm_reg;
      `uvm_object_utils(apb_soc_ctrl_corestatus)

      rand uvm_reg_field eoc; // Set to 1 once the core reaches end of computation
      rand uvm_reg_field exit_code; // The 31 LSBs of the exit code


      // Function: new
      // 
      function new(string name = "apb_soc_ctrl_corestatus");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         eoc = uvm_reg_field::type_id::create("eoc");
         exit_code = uvm_reg_field::type_id::create("exit_code");

         eoc.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         exit_code.configure(this, 31, 0, "RW", 0, 31'b0000000000000000000000000000000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_cfg
   // 
   // Global configuration register for the peripheral
   //--------------------------------------------------------------------

   class gpio_cfg extends uvm_reg;
      `uvm_object_utils(gpio_cfg)

      rand uvm_reg_field reserved; // Reserved for future use
      rand uvm_reg_field intrpt_mode; // If 1, keep the interrupt line asserted until all
                                    // interrupts are cleared. If 0, generate one cycle wide pulse for every interrupt.


      // Function: new
      // 
      function new(string name = "gpio_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         intrpt_mode = uvm_reg_field::type_id::create("intrpt_mode");

         reserved.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_mode.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_clear_0
   // 
   // For each asserted bit in this register, clear the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_clear_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_clear_0)

      rand uvm_reg_field gpio_clear_31; 
      rand uvm_reg_field gpio_clear_30; 
      rand uvm_reg_field gpio_clear_29; 
      rand uvm_reg_field gpio_clear_28; 
      rand uvm_reg_field gpio_clear_27; 
      rand uvm_reg_field gpio_clear_26; 
      rand uvm_reg_field gpio_clear_25; 
      rand uvm_reg_field gpio_clear_24; 
      rand uvm_reg_field gpio_clear_23; 
      rand uvm_reg_field gpio_clear_22; 
      rand uvm_reg_field gpio_clear_21; 
      rand uvm_reg_field gpio_clear_20; 
      rand uvm_reg_field gpio_clear_19; 
      rand uvm_reg_field gpio_clear_18; 
      rand uvm_reg_field gpio_clear_17; 
      rand uvm_reg_field gpio_clear_16; 
      rand uvm_reg_field gpio_clear_15; 
      rand uvm_reg_field gpio_clear_14; 
      rand uvm_reg_field gpio_clear_13; 
      rand uvm_reg_field gpio_clear_12; 
      rand uvm_reg_field gpio_clear_11; 
      rand uvm_reg_field gpio_clear_10; 
      rand uvm_reg_field gpio_clear_9; 
      rand uvm_reg_field gpio_clear_8; 
      rand uvm_reg_field gpio_clear_7; 
      rand uvm_reg_field gpio_clear_6; 
      rand uvm_reg_field gpio_clear_5; 
      rand uvm_reg_field gpio_clear_4; 
      rand uvm_reg_field gpio_clear_3; 
      rand uvm_reg_field gpio_clear_2; 
      rand uvm_reg_field gpio_clear_1; 
      rand uvm_reg_field gpio_clear_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_clear_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_clear_31 = uvm_reg_field::type_id::create("gpio_clear_31");
         gpio_clear_30 = uvm_reg_field::type_id::create("gpio_clear_30");
         gpio_clear_29 = uvm_reg_field::type_id::create("gpio_clear_29");
         gpio_clear_28 = uvm_reg_field::type_id::create("gpio_clear_28");
         gpio_clear_27 = uvm_reg_field::type_id::create("gpio_clear_27");
         gpio_clear_26 = uvm_reg_field::type_id::create("gpio_clear_26");
         gpio_clear_25 = uvm_reg_field::type_id::create("gpio_clear_25");
         gpio_clear_24 = uvm_reg_field::type_id::create("gpio_clear_24");
         gpio_clear_23 = uvm_reg_field::type_id::create("gpio_clear_23");
         gpio_clear_22 = uvm_reg_field::type_id::create("gpio_clear_22");
         gpio_clear_21 = uvm_reg_field::type_id::create("gpio_clear_21");
         gpio_clear_20 = uvm_reg_field::type_id::create("gpio_clear_20");
         gpio_clear_19 = uvm_reg_field::type_id::create("gpio_clear_19");
         gpio_clear_18 = uvm_reg_field::type_id::create("gpio_clear_18");
         gpio_clear_17 = uvm_reg_field::type_id::create("gpio_clear_17");
         gpio_clear_16 = uvm_reg_field::type_id::create("gpio_clear_16");
         gpio_clear_15 = uvm_reg_field::type_id::create("gpio_clear_15");
         gpio_clear_14 = uvm_reg_field::type_id::create("gpio_clear_14");
         gpio_clear_13 = uvm_reg_field::type_id::create("gpio_clear_13");
         gpio_clear_12 = uvm_reg_field::type_id::create("gpio_clear_12");
         gpio_clear_11 = uvm_reg_field::type_id::create("gpio_clear_11");
         gpio_clear_10 = uvm_reg_field::type_id::create("gpio_clear_10");
         gpio_clear_9 = uvm_reg_field::type_id::create("gpio_clear_9");
         gpio_clear_8 = uvm_reg_field::type_id::create("gpio_clear_8");
         gpio_clear_7 = uvm_reg_field::type_id::create("gpio_clear_7");
         gpio_clear_6 = uvm_reg_field::type_id::create("gpio_clear_6");
         gpio_clear_5 = uvm_reg_field::type_id::create("gpio_clear_5");
         gpio_clear_4 = uvm_reg_field::type_id::create("gpio_clear_4");
         gpio_clear_3 = uvm_reg_field::type_id::create("gpio_clear_3");
         gpio_clear_2 = uvm_reg_field::type_id::create("gpio_clear_2");
         gpio_clear_1 = uvm_reg_field::type_id::create("gpio_clear_1");
         gpio_clear_0 = uvm_reg_field::type_id::create("gpio_clear_0");

         gpio_clear_31.configure(this, 1, 31, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_30.configure(this, 1, 30, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_29.configure(this, 1, 29, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_28.configure(this, 1, 28, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_27.configure(this, 1, 27, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_26.configure(this, 1, 26, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_25.configure(this, 1, 25, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_24.configure(this, 1, 24, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_23.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_22.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_21.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_20.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_19.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_18.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_17.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_16.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_15.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_14.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_13.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_12.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_11.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_10.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_9.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_8.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_7.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_6.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_5.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_4.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_3.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_2.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_1.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_0.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_clear_1
   // 
   // For each asserted bit in this register, clear the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_clear_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_clear_1)

      rand uvm_reg_field gpio_clear_55; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_54; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_53; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_52; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_51; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_50; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_49; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_48; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_47; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_46; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_45; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_44; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_43; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_42; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_41; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_40; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_39; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_38; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_37; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_36; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_35; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_34; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_33; // For GPIO_CLEAR1
      rand uvm_reg_field gpio_clear_32; // For GPIO_CLEAR1


      // Function: new
      // 
      function new(string name = "gpio_gpio_clear_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_clear_55 = uvm_reg_field::type_id::create("gpio_clear_55");
         gpio_clear_54 = uvm_reg_field::type_id::create("gpio_clear_54");
         gpio_clear_53 = uvm_reg_field::type_id::create("gpio_clear_53");
         gpio_clear_52 = uvm_reg_field::type_id::create("gpio_clear_52");
         gpio_clear_51 = uvm_reg_field::type_id::create("gpio_clear_51");
         gpio_clear_50 = uvm_reg_field::type_id::create("gpio_clear_50");
         gpio_clear_49 = uvm_reg_field::type_id::create("gpio_clear_49");
         gpio_clear_48 = uvm_reg_field::type_id::create("gpio_clear_48");
         gpio_clear_47 = uvm_reg_field::type_id::create("gpio_clear_47");
         gpio_clear_46 = uvm_reg_field::type_id::create("gpio_clear_46");
         gpio_clear_45 = uvm_reg_field::type_id::create("gpio_clear_45");
         gpio_clear_44 = uvm_reg_field::type_id::create("gpio_clear_44");
         gpio_clear_43 = uvm_reg_field::type_id::create("gpio_clear_43");
         gpio_clear_42 = uvm_reg_field::type_id::create("gpio_clear_42");
         gpio_clear_41 = uvm_reg_field::type_id::create("gpio_clear_41");
         gpio_clear_40 = uvm_reg_field::type_id::create("gpio_clear_40");
         gpio_clear_39 = uvm_reg_field::type_id::create("gpio_clear_39");
         gpio_clear_38 = uvm_reg_field::type_id::create("gpio_clear_38");
         gpio_clear_37 = uvm_reg_field::type_id::create("gpio_clear_37");
         gpio_clear_36 = uvm_reg_field::type_id::create("gpio_clear_36");
         gpio_clear_35 = uvm_reg_field::type_id::create("gpio_clear_35");
         gpio_clear_34 = uvm_reg_field::type_id::create("gpio_clear_34");
         gpio_clear_33 = uvm_reg_field::type_id::create("gpio_clear_33");
         gpio_clear_32 = uvm_reg_field::type_id::create("gpio_clear_32");

         gpio_clear_55.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_54.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_53.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_52.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_51.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_50.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_49.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_48.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_47.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_46.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_45.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_44.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_43.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_42.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_41.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_40.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_39.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_38.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_37.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_36.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_35.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_34.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_33.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_clear_32.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_en_0
   // 
   // Enable sampling on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_gpio_en_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_en_0)

      rand uvm_reg_field gpio_en_31; 
      rand uvm_reg_field gpio_en_30; 
      rand uvm_reg_field gpio_en_29; 
      rand uvm_reg_field gpio_en_28; 
      rand uvm_reg_field gpio_en_27; 
      rand uvm_reg_field gpio_en_26; 
      rand uvm_reg_field gpio_en_25; 
      rand uvm_reg_field gpio_en_24; 
      rand uvm_reg_field gpio_en_23; 
      rand uvm_reg_field gpio_en_22; 
      rand uvm_reg_field gpio_en_21; 
      rand uvm_reg_field gpio_en_20; 
      rand uvm_reg_field gpio_en_19; 
      rand uvm_reg_field gpio_en_18; 
      rand uvm_reg_field gpio_en_17; 
      rand uvm_reg_field gpio_en_16; 
      rand uvm_reg_field gpio_en_15; 
      rand uvm_reg_field gpio_en_14; 
      rand uvm_reg_field gpio_en_13; 
      rand uvm_reg_field gpio_en_12; 
      rand uvm_reg_field gpio_en_11; 
      rand uvm_reg_field gpio_en_10; 
      rand uvm_reg_field gpio_en_9; 
      rand uvm_reg_field gpio_en_8; 
      rand uvm_reg_field gpio_en_7; 
      rand uvm_reg_field gpio_en_6; 
      rand uvm_reg_field gpio_en_5; 
      rand uvm_reg_field gpio_en_4; 
      rand uvm_reg_field gpio_en_3; 
      rand uvm_reg_field gpio_en_2; 
      rand uvm_reg_field gpio_en_1; 
      rand uvm_reg_field gpio_en_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_en_31 = uvm_reg_field::type_id::create("gpio_en_31");
         gpio_en_30 = uvm_reg_field::type_id::create("gpio_en_30");
         gpio_en_29 = uvm_reg_field::type_id::create("gpio_en_29");
         gpio_en_28 = uvm_reg_field::type_id::create("gpio_en_28");
         gpio_en_27 = uvm_reg_field::type_id::create("gpio_en_27");
         gpio_en_26 = uvm_reg_field::type_id::create("gpio_en_26");
         gpio_en_25 = uvm_reg_field::type_id::create("gpio_en_25");
         gpio_en_24 = uvm_reg_field::type_id::create("gpio_en_24");
         gpio_en_23 = uvm_reg_field::type_id::create("gpio_en_23");
         gpio_en_22 = uvm_reg_field::type_id::create("gpio_en_22");
         gpio_en_21 = uvm_reg_field::type_id::create("gpio_en_21");
         gpio_en_20 = uvm_reg_field::type_id::create("gpio_en_20");
         gpio_en_19 = uvm_reg_field::type_id::create("gpio_en_19");
         gpio_en_18 = uvm_reg_field::type_id::create("gpio_en_18");
         gpio_en_17 = uvm_reg_field::type_id::create("gpio_en_17");
         gpio_en_16 = uvm_reg_field::type_id::create("gpio_en_16");
         gpio_en_15 = uvm_reg_field::type_id::create("gpio_en_15");
         gpio_en_14 = uvm_reg_field::type_id::create("gpio_en_14");
         gpio_en_13 = uvm_reg_field::type_id::create("gpio_en_13");
         gpio_en_12 = uvm_reg_field::type_id::create("gpio_en_12");
         gpio_en_11 = uvm_reg_field::type_id::create("gpio_en_11");
         gpio_en_10 = uvm_reg_field::type_id::create("gpio_en_10");
         gpio_en_9 = uvm_reg_field::type_id::create("gpio_en_9");
         gpio_en_8 = uvm_reg_field::type_id::create("gpio_en_8");
         gpio_en_7 = uvm_reg_field::type_id::create("gpio_en_7");
         gpio_en_6 = uvm_reg_field::type_id::create("gpio_en_6");
         gpio_en_5 = uvm_reg_field::type_id::create("gpio_en_5");
         gpio_en_4 = uvm_reg_field::type_id::create("gpio_en_4");
         gpio_en_3 = uvm_reg_field::type_id::create("gpio_en_3");
         gpio_en_2 = uvm_reg_field::type_id::create("gpio_en_2");
         gpio_en_1 = uvm_reg_field::type_id::create("gpio_en_1");
         gpio_en_0 = uvm_reg_field::type_id::create("gpio_en_0");

         gpio_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_en_1
   // 
   // Enable sampling on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_gpio_en_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_en_1)

      rand uvm_reg_field gpio_en_55; // For GPIO_EN1
      rand uvm_reg_field gpio_en_54; // For GPIO_EN1
      rand uvm_reg_field gpio_en_53; // For GPIO_EN1
      rand uvm_reg_field gpio_en_52; // For GPIO_EN1
      rand uvm_reg_field gpio_en_51; // For GPIO_EN1
      rand uvm_reg_field gpio_en_50; // For GPIO_EN1
      rand uvm_reg_field gpio_en_49; // For GPIO_EN1
      rand uvm_reg_field gpio_en_48; // For GPIO_EN1
      rand uvm_reg_field gpio_en_47; // For GPIO_EN1
      rand uvm_reg_field gpio_en_46; // For GPIO_EN1
      rand uvm_reg_field gpio_en_45; // For GPIO_EN1
      rand uvm_reg_field gpio_en_44; // For GPIO_EN1
      rand uvm_reg_field gpio_en_43; // For GPIO_EN1
      rand uvm_reg_field gpio_en_42; // For GPIO_EN1
      rand uvm_reg_field gpio_en_41; // For GPIO_EN1
      rand uvm_reg_field gpio_en_40; // For GPIO_EN1
      rand uvm_reg_field gpio_en_39; // For GPIO_EN1
      rand uvm_reg_field gpio_en_38; // For GPIO_EN1
      rand uvm_reg_field gpio_en_37; // For GPIO_EN1
      rand uvm_reg_field gpio_en_36; // For GPIO_EN1
      rand uvm_reg_field gpio_en_35; // For GPIO_EN1
      rand uvm_reg_field gpio_en_34; // For GPIO_EN1
      rand uvm_reg_field gpio_en_33; // For GPIO_EN1
      rand uvm_reg_field gpio_en_32; // For GPIO_EN1


      // Function: new
      // 
      function new(string name = "gpio_gpio_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_en_55 = uvm_reg_field::type_id::create("gpio_en_55");
         gpio_en_54 = uvm_reg_field::type_id::create("gpio_en_54");
         gpio_en_53 = uvm_reg_field::type_id::create("gpio_en_53");
         gpio_en_52 = uvm_reg_field::type_id::create("gpio_en_52");
         gpio_en_51 = uvm_reg_field::type_id::create("gpio_en_51");
         gpio_en_50 = uvm_reg_field::type_id::create("gpio_en_50");
         gpio_en_49 = uvm_reg_field::type_id::create("gpio_en_49");
         gpio_en_48 = uvm_reg_field::type_id::create("gpio_en_48");
         gpio_en_47 = uvm_reg_field::type_id::create("gpio_en_47");
         gpio_en_46 = uvm_reg_field::type_id::create("gpio_en_46");
         gpio_en_45 = uvm_reg_field::type_id::create("gpio_en_45");
         gpio_en_44 = uvm_reg_field::type_id::create("gpio_en_44");
         gpio_en_43 = uvm_reg_field::type_id::create("gpio_en_43");
         gpio_en_42 = uvm_reg_field::type_id::create("gpio_en_42");
         gpio_en_41 = uvm_reg_field::type_id::create("gpio_en_41");
         gpio_en_40 = uvm_reg_field::type_id::create("gpio_en_40");
         gpio_en_39 = uvm_reg_field::type_id::create("gpio_en_39");
         gpio_en_38 = uvm_reg_field::type_id::create("gpio_en_38");
         gpio_en_37 = uvm_reg_field::type_id::create("gpio_en_37");
         gpio_en_36 = uvm_reg_field::type_id::create("gpio_en_36");
         gpio_en_35 = uvm_reg_field::type_id::create("gpio_en_35");
         gpio_en_34 = uvm_reg_field::type_id::create("gpio_en_34");
         gpio_en_33 = uvm_reg_field::type_id::create("gpio_en_33");
         gpio_en_32 = uvm_reg_field::type_id::create("gpio_en_32");

         gpio_en_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         gpio_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_in_0
   // 
   // Read the current input values of all GPIOs.
   //--------------------------------------------------------------------

   class gpio_gpio_in_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_in_0)

      uvm_reg_field gpio_in_31; 
      uvm_reg_field gpio_in_30; 
      uvm_reg_field gpio_in_29; 
      uvm_reg_field gpio_in_28; 
      uvm_reg_field gpio_in_27; 
      uvm_reg_field gpio_in_26; 
      uvm_reg_field gpio_in_25; 
      uvm_reg_field gpio_in_24; 
      uvm_reg_field gpio_in_23; 
      uvm_reg_field gpio_in_22; 
      uvm_reg_field gpio_in_21; 
      uvm_reg_field gpio_in_20; 
      uvm_reg_field gpio_in_19; 
      uvm_reg_field gpio_in_18; 
      uvm_reg_field gpio_in_17; 
      uvm_reg_field gpio_in_16; 
      uvm_reg_field gpio_in_15; 
      uvm_reg_field gpio_in_14; 
      uvm_reg_field gpio_in_13; 
      uvm_reg_field gpio_in_12; 
      uvm_reg_field gpio_in_11; 
      uvm_reg_field gpio_in_10; 
      uvm_reg_field gpio_in_9; 
      uvm_reg_field gpio_in_8; 
      uvm_reg_field gpio_in_7; 
      uvm_reg_field gpio_in_6; 
      uvm_reg_field gpio_in_5; 
      uvm_reg_field gpio_in_4; 
      uvm_reg_field gpio_in_3; 
      uvm_reg_field gpio_in_2; 
      uvm_reg_field gpio_in_1; 
      uvm_reg_field gpio_in_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_in_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_in_31 = uvm_reg_field::type_id::create("gpio_in_31");
         gpio_in_30 = uvm_reg_field::type_id::create("gpio_in_30");
         gpio_in_29 = uvm_reg_field::type_id::create("gpio_in_29");
         gpio_in_28 = uvm_reg_field::type_id::create("gpio_in_28");
         gpio_in_27 = uvm_reg_field::type_id::create("gpio_in_27");
         gpio_in_26 = uvm_reg_field::type_id::create("gpio_in_26");
         gpio_in_25 = uvm_reg_field::type_id::create("gpio_in_25");
         gpio_in_24 = uvm_reg_field::type_id::create("gpio_in_24");
         gpio_in_23 = uvm_reg_field::type_id::create("gpio_in_23");
         gpio_in_22 = uvm_reg_field::type_id::create("gpio_in_22");
         gpio_in_21 = uvm_reg_field::type_id::create("gpio_in_21");
         gpio_in_20 = uvm_reg_field::type_id::create("gpio_in_20");
         gpio_in_19 = uvm_reg_field::type_id::create("gpio_in_19");
         gpio_in_18 = uvm_reg_field::type_id::create("gpio_in_18");
         gpio_in_17 = uvm_reg_field::type_id::create("gpio_in_17");
         gpio_in_16 = uvm_reg_field::type_id::create("gpio_in_16");
         gpio_in_15 = uvm_reg_field::type_id::create("gpio_in_15");
         gpio_in_14 = uvm_reg_field::type_id::create("gpio_in_14");
         gpio_in_13 = uvm_reg_field::type_id::create("gpio_in_13");
         gpio_in_12 = uvm_reg_field::type_id::create("gpio_in_12");
         gpio_in_11 = uvm_reg_field::type_id::create("gpio_in_11");
         gpio_in_10 = uvm_reg_field::type_id::create("gpio_in_10");
         gpio_in_9 = uvm_reg_field::type_id::create("gpio_in_9");
         gpio_in_8 = uvm_reg_field::type_id::create("gpio_in_8");
         gpio_in_7 = uvm_reg_field::type_id::create("gpio_in_7");
         gpio_in_6 = uvm_reg_field::type_id::create("gpio_in_6");
         gpio_in_5 = uvm_reg_field::type_id::create("gpio_in_5");
         gpio_in_4 = uvm_reg_field::type_id::create("gpio_in_4");
         gpio_in_3 = uvm_reg_field::type_id::create("gpio_in_3");
         gpio_in_2 = uvm_reg_field::type_id::create("gpio_in_2");
         gpio_in_1 = uvm_reg_field::type_id::create("gpio_in_1");
         gpio_in_0 = uvm_reg_field::type_id::create("gpio_in_0");

         gpio_in_31.configure(this, 1, 31, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_30.configure(this, 1, 30, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_29.configure(this, 1, 29, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_28.configure(this, 1, 28, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_27.configure(this, 1, 27, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_26.configure(this, 1, 26, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_25.configure(this, 1, 25, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_24.configure(this, 1, 24, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_23.configure(this, 1, 23, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_22.configure(this, 1, 22, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_21.configure(this, 1, 21, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_20.configure(this, 1, 20, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_19.configure(this, 1, 19, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_18.configure(this, 1, 18, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_17.configure(this, 1, 17, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_16.configure(this, 1, 16, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_15.configure(this, 1, 15, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_14.configure(this, 1, 14, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_13.configure(this, 1, 13, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_12.configure(this, 1, 12, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_11.configure(this, 1, 11, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_10.configure(this, 1, 10, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_9.configure(this, 1, 9, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_8.configure(this, 1, 8, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_7.configure(this, 1, 7, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_6.configure(this, 1, 6, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_5.configure(this, 1, 5, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_4.configure(this, 1, 4, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_3.configure(this, 1, 3, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_2.configure(this, 1, 2, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_1.configure(this, 1, 1, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_0.configure(this, 1, 0, "RO", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_in_1
   // 
   // Read the current input values of all GPIOs.
   //--------------------------------------------------------------------

   class gpio_gpio_in_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_in_1)

      uvm_reg_field gpio_in_55; // For GPIO_IN1
      uvm_reg_field gpio_in_54; // For GPIO_IN1
      uvm_reg_field gpio_in_53; // For GPIO_IN1
      uvm_reg_field gpio_in_52; // For GPIO_IN1
      uvm_reg_field gpio_in_51; // For GPIO_IN1
      uvm_reg_field gpio_in_50; // For GPIO_IN1
      uvm_reg_field gpio_in_49; // For GPIO_IN1
      uvm_reg_field gpio_in_48; // For GPIO_IN1
      uvm_reg_field gpio_in_47; // For GPIO_IN1
      uvm_reg_field gpio_in_46; // For GPIO_IN1
      uvm_reg_field gpio_in_45; // For GPIO_IN1
      uvm_reg_field gpio_in_44; // For GPIO_IN1
      uvm_reg_field gpio_in_43; // For GPIO_IN1
      uvm_reg_field gpio_in_42; // For GPIO_IN1
      uvm_reg_field gpio_in_41; // For GPIO_IN1
      uvm_reg_field gpio_in_40; // For GPIO_IN1
      uvm_reg_field gpio_in_39; // For GPIO_IN1
      uvm_reg_field gpio_in_38; // For GPIO_IN1
      uvm_reg_field gpio_in_37; // For GPIO_IN1
      uvm_reg_field gpio_in_36; // For GPIO_IN1
      uvm_reg_field gpio_in_35; // For GPIO_IN1
      uvm_reg_field gpio_in_34; // For GPIO_IN1
      uvm_reg_field gpio_in_33; // For GPIO_IN1
      uvm_reg_field gpio_in_32; // For GPIO_IN1


      // Function: new
      // 
      function new(string name = "gpio_gpio_in_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_in_55 = uvm_reg_field::type_id::create("gpio_in_55");
         gpio_in_54 = uvm_reg_field::type_id::create("gpio_in_54");
         gpio_in_53 = uvm_reg_field::type_id::create("gpio_in_53");
         gpio_in_52 = uvm_reg_field::type_id::create("gpio_in_52");
         gpio_in_51 = uvm_reg_field::type_id::create("gpio_in_51");
         gpio_in_50 = uvm_reg_field::type_id::create("gpio_in_50");
         gpio_in_49 = uvm_reg_field::type_id::create("gpio_in_49");
         gpio_in_48 = uvm_reg_field::type_id::create("gpio_in_48");
         gpio_in_47 = uvm_reg_field::type_id::create("gpio_in_47");
         gpio_in_46 = uvm_reg_field::type_id::create("gpio_in_46");
         gpio_in_45 = uvm_reg_field::type_id::create("gpio_in_45");
         gpio_in_44 = uvm_reg_field::type_id::create("gpio_in_44");
         gpio_in_43 = uvm_reg_field::type_id::create("gpio_in_43");
         gpio_in_42 = uvm_reg_field::type_id::create("gpio_in_42");
         gpio_in_41 = uvm_reg_field::type_id::create("gpio_in_41");
         gpio_in_40 = uvm_reg_field::type_id::create("gpio_in_40");
         gpio_in_39 = uvm_reg_field::type_id::create("gpio_in_39");
         gpio_in_38 = uvm_reg_field::type_id::create("gpio_in_38");
         gpio_in_37 = uvm_reg_field::type_id::create("gpio_in_37");
         gpio_in_36 = uvm_reg_field::type_id::create("gpio_in_36");
         gpio_in_35 = uvm_reg_field::type_id::create("gpio_in_35");
         gpio_in_34 = uvm_reg_field::type_id::create("gpio_in_34");
         gpio_in_33 = uvm_reg_field::type_id::create("gpio_in_33");
         gpio_in_32 = uvm_reg_field::type_id::create("gpio_in_32");

         gpio_in_55.configure(this, 1, 23, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_54.configure(this, 1, 22, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_53.configure(this, 1, 21, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_52.configure(this, 1, 20, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_51.configure(this, 1, 19, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_50.configure(this, 1, 18, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_49.configure(this, 1, 17, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_48.configure(this, 1, 16, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_47.configure(this, 1, 15, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_46.configure(this, 1, 14, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_45.configure(this, 1, 13, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_44.configure(this, 1, 12, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_43.configure(this, 1, 11, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_42.configure(this, 1, 10, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_41.configure(this, 1, 9, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_40.configure(this, 1, 8, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_39.configure(this, 1, 7, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_38.configure(this, 1, 6, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_37.configure(this, 1, 5, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_36.configure(this, 1, 4, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_35.configure(this, 1, 3, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_34.configure(this, 1, 2, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_33.configure(this, 1, 1, "RO", 0, 1'b0, 1, 0, 0);
         gpio_in_32.configure(this, 1, 0, "RO", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_mode_0
   // 
   // Set the IO Mode of the GPIO.
   //--------------------------------------------------------------------

   class gpio_gpio_mode_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_mode_0)

      rand uvm_reg_field mode_15; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_14; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_13; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_12; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_11; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_10; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_9; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_8; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_7; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_6; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_5; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_4; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_3; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_2; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_1; // Change the IO  mode of the GPIO.
      rand uvm_reg_field mode_0; // Change the IO  mode of the GPIO.


      // Function: new
      // 
      function new(string name = "gpio_gpio_mode_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         mode_15 = uvm_reg_field::type_id::create("mode_15");
         mode_14 = uvm_reg_field::type_id::create("mode_14");
         mode_13 = uvm_reg_field::type_id::create("mode_13");
         mode_12 = uvm_reg_field::type_id::create("mode_12");
         mode_11 = uvm_reg_field::type_id::create("mode_11");
         mode_10 = uvm_reg_field::type_id::create("mode_10");
         mode_9 = uvm_reg_field::type_id::create("mode_9");
         mode_8 = uvm_reg_field::type_id::create("mode_8");
         mode_7 = uvm_reg_field::type_id::create("mode_7");
         mode_6 = uvm_reg_field::type_id::create("mode_6");
         mode_5 = uvm_reg_field::type_id::create("mode_5");
         mode_4 = uvm_reg_field::type_id::create("mode_4");
         mode_3 = uvm_reg_field::type_id::create("mode_3");
         mode_2 = uvm_reg_field::type_id::create("mode_2");
         mode_1 = uvm_reg_field::type_id::create("mode_1");
         mode_0 = uvm_reg_field::type_id::create("mode_0");

         mode_15.configure(this, 2, 30, "RW", 0, 2'b00, 1, 1, 0);
         mode_14.configure(this, 2, 28, "RW", 0, 2'b00, 1, 1, 0);
         mode_13.configure(this, 2, 26, "RW", 0, 2'b00, 1, 1, 0);
         mode_12.configure(this, 2, 24, "RW", 0, 2'b00, 1, 1, 0);
         mode_11.configure(this, 2, 22, "RW", 0, 2'b00, 1, 1, 0);
         mode_10.configure(this, 2, 20, "RW", 0, 2'b00, 1, 1, 0);
         mode_9.configure(this, 2, 18, "RW", 0, 2'b00, 1, 1, 0);
         mode_8.configure(this, 2, 16, "RW", 0, 2'b00, 1, 1, 0);
         mode_7.configure(this, 2, 14, "RW", 0, 2'b00, 1, 1, 0);
         mode_6.configure(this, 2, 12, "RW", 0, 2'b00, 1, 1, 0);
         mode_5.configure(this, 2, 10, "RW", 0, 2'b00, 1, 1, 0);
         mode_4.configure(this, 2, 8, "RW", 0, 2'b00, 1, 1, 0);
         mode_3.configure(this, 2, 6, "RW", 0, 2'b00, 1, 1, 0);
         mode_2.configure(this, 2, 4, "RW", 0, 2'b00, 1, 1, 0);
         mode_1.configure(this, 2, 2, "RW", 0, 2'b00, 1, 1, 0);
         mode_0.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_mode_1
   // 
   // Set the IO Mode of the GPIO.
   //--------------------------------------------------------------------

   class gpio_gpio_mode_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_mode_1)

      rand uvm_reg_field mode_31; // For GPIO_MODE1
      rand uvm_reg_field mode_30; // For GPIO_MODE1
      rand uvm_reg_field mode_29; // For GPIO_MODE1
      rand uvm_reg_field mode_28; // For GPIO_MODE1
      rand uvm_reg_field mode_27; // For GPIO_MODE1
      rand uvm_reg_field mode_26; // For GPIO_MODE1
      rand uvm_reg_field mode_25; // For GPIO_MODE1
      rand uvm_reg_field mode_24; // For GPIO_MODE1
      rand uvm_reg_field mode_23; // For GPIO_MODE1
      rand uvm_reg_field mode_22; // For GPIO_MODE1
      rand uvm_reg_field mode_21; // For GPIO_MODE1
      rand uvm_reg_field mode_20; // For GPIO_MODE1
      rand uvm_reg_field mode_19; // For GPIO_MODE1
      rand uvm_reg_field mode_18; // For GPIO_MODE1
      rand uvm_reg_field mode_17; // For GPIO_MODE1
      rand uvm_reg_field mode_16; // For GPIO_MODE1


      // Function: new
      // 
      function new(string name = "gpio_gpio_mode_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         mode_31 = uvm_reg_field::type_id::create("mode_31");
         mode_30 = uvm_reg_field::type_id::create("mode_30");
         mode_29 = uvm_reg_field::type_id::create("mode_29");
         mode_28 = uvm_reg_field::type_id::create("mode_28");
         mode_27 = uvm_reg_field::type_id::create("mode_27");
         mode_26 = uvm_reg_field::type_id::create("mode_26");
         mode_25 = uvm_reg_field::type_id::create("mode_25");
         mode_24 = uvm_reg_field::type_id::create("mode_24");
         mode_23 = uvm_reg_field::type_id::create("mode_23");
         mode_22 = uvm_reg_field::type_id::create("mode_22");
         mode_21 = uvm_reg_field::type_id::create("mode_21");
         mode_20 = uvm_reg_field::type_id::create("mode_20");
         mode_19 = uvm_reg_field::type_id::create("mode_19");
         mode_18 = uvm_reg_field::type_id::create("mode_18");
         mode_17 = uvm_reg_field::type_id::create("mode_17");
         mode_16 = uvm_reg_field::type_id::create("mode_16");

         mode_31.configure(this, 2, 30, "RW", 0, 2'b00, 1, 1, 0);
         mode_30.configure(this, 2, 28, "RW", 0, 2'b00, 1, 1, 0);
         mode_29.configure(this, 2, 26, "RW", 0, 2'b00, 1, 1, 0);
         mode_28.configure(this, 2, 24, "RW", 0, 2'b00, 1, 1, 0);
         mode_27.configure(this, 2, 22, "RW", 0, 2'b00, 1, 1, 0);
         mode_26.configure(this, 2, 20, "RW", 0, 2'b00, 1, 1, 0);
         mode_25.configure(this, 2, 18, "RW", 0, 2'b00, 1, 1, 0);
         mode_24.configure(this, 2, 16, "RW", 0, 2'b00, 1, 1, 0);
         mode_23.configure(this, 2, 14, "RW", 0, 2'b00, 1, 1, 0);
         mode_22.configure(this, 2, 12, "RW", 0, 2'b00, 1, 1, 0);
         mode_21.configure(this, 2, 10, "RW", 0, 2'b00, 1, 1, 0);
         mode_20.configure(this, 2, 8, "RW", 0, 2'b00, 1, 1, 0);
         mode_19.configure(this, 2, 6, "RW", 0, 2'b00, 1, 1, 0);
         mode_18.configure(this, 2, 4, "RW", 0, 2'b00, 1, 1, 0);
         mode_17.configure(this, 2, 2, "RW", 0, 2'b00, 1, 1, 0);
         mode_16.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_mode_2
   // 
   // Set the IO Mode of the GPIO.
   //--------------------------------------------------------------------

   class gpio_gpio_mode_2 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_mode_2)

      rand uvm_reg_field mode_47; // For GPIO_MODE2
      rand uvm_reg_field mode_46; // For GPIO_MODE2
      rand uvm_reg_field mode_45; // For GPIO_MODE2
      rand uvm_reg_field mode_44; // For GPIO_MODE2
      rand uvm_reg_field mode_43; // For GPIO_MODE2
      rand uvm_reg_field mode_42; // For GPIO_MODE2
      rand uvm_reg_field mode_41; // For GPIO_MODE2
      rand uvm_reg_field mode_40; // For GPIO_MODE2
      rand uvm_reg_field mode_39; // For GPIO_MODE2
      rand uvm_reg_field mode_38; // For GPIO_MODE2
      rand uvm_reg_field mode_37; // For GPIO_MODE2
      rand uvm_reg_field mode_36; // For GPIO_MODE2
      rand uvm_reg_field mode_35; // For GPIO_MODE2
      rand uvm_reg_field mode_34; // For GPIO_MODE2
      rand uvm_reg_field mode_33; // For GPIO_MODE2
      rand uvm_reg_field mode_32; // For GPIO_MODE2


      // Function: new
      // 
      function new(string name = "gpio_gpio_mode_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         mode_47 = uvm_reg_field::type_id::create("mode_47");
         mode_46 = uvm_reg_field::type_id::create("mode_46");
         mode_45 = uvm_reg_field::type_id::create("mode_45");
         mode_44 = uvm_reg_field::type_id::create("mode_44");
         mode_43 = uvm_reg_field::type_id::create("mode_43");
         mode_42 = uvm_reg_field::type_id::create("mode_42");
         mode_41 = uvm_reg_field::type_id::create("mode_41");
         mode_40 = uvm_reg_field::type_id::create("mode_40");
         mode_39 = uvm_reg_field::type_id::create("mode_39");
         mode_38 = uvm_reg_field::type_id::create("mode_38");
         mode_37 = uvm_reg_field::type_id::create("mode_37");
         mode_36 = uvm_reg_field::type_id::create("mode_36");
         mode_35 = uvm_reg_field::type_id::create("mode_35");
         mode_34 = uvm_reg_field::type_id::create("mode_34");
         mode_33 = uvm_reg_field::type_id::create("mode_33");
         mode_32 = uvm_reg_field::type_id::create("mode_32");

         mode_47.configure(this, 2, 30, "RW", 0, 2'b00, 1, 1, 0);
         mode_46.configure(this, 2, 28, "RW", 0, 2'b00, 1, 1, 0);
         mode_45.configure(this, 2, 26, "RW", 0, 2'b00, 1, 1, 0);
         mode_44.configure(this, 2, 24, "RW", 0, 2'b00, 1, 1, 0);
         mode_43.configure(this, 2, 22, "RW", 0, 2'b00, 1, 1, 0);
         mode_42.configure(this, 2, 20, "RW", 0, 2'b00, 1, 1, 0);
         mode_41.configure(this, 2, 18, "RW", 0, 2'b00, 1, 1, 0);
         mode_40.configure(this, 2, 16, "RW", 0, 2'b00, 1, 1, 0);
         mode_39.configure(this, 2, 14, "RW", 0, 2'b00, 1, 1, 0);
         mode_38.configure(this, 2, 12, "RW", 0, 2'b00, 1, 1, 0);
         mode_37.configure(this, 2, 10, "RW", 0, 2'b00, 1, 1, 0);
         mode_36.configure(this, 2, 8, "RW", 0, 2'b00, 1, 1, 0);
         mode_35.configure(this, 2, 6, "RW", 0, 2'b00, 1, 1, 0);
         mode_34.configure(this, 2, 4, "RW", 0, 2'b00, 1, 1, 0);
         mode_33.configure(this, 2, 2, "RW", 0, 2'b00, 1, 1, 0);
         mode_32.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_mode_3
   // 
   // Set the IO Mode of the GPIO.
   //--------------------------------------------------------------------

   class gpio_gpio_mode_3 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_mode_3)

      rand uvm_reg_field mode_55; // For GPIO_MODE3
      rand uvm_reg_field mode_54; // For GPIO_MODE3
      rand uvm_reg_field mode_53; // For GPIO_MODE3
      rand uvm_reg_field mode_52; // For GPIO_MODE3
      rand uvm_reg_field mode_51; // For GPIO_MODE3
      rand uvm_reg_field mode_50; // For GPIO_MODE3
      rand uvm_reg_field mode_49; // For GPIO_MODE3
      rand uvm_reg_field mode_48; // For GPIO_MODE3


      // Function: new
      // 
      function new(string name = "gpio_gpio_mode_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         mode_55 = uvm_reg_field::type_id::create("mode_55");
         mode_54 = uvm_reg_field::type_id::create("mode_54");
         mode_53 = uvm_reg_field::type_id::create("mode_53");
         mode_52 = uvm_reg_field::type_id::create("mode_52");
         mode_51 = uvm_reg_field::type_id::create("mode_51");
         mode_50 = uvm_reg_field::type_id::create("mode_50");
         mode_49 = uvm_reg_field::type_id::create("mode_49");
         mode_48 = uvm_reg_field::type_id::create("mode_48");

         mode_55.configure(this, 2, 14, "RW", 0, 2'b00, 1, 1, 0);
         mode_54.configure(this, 2, 12, "RW", 0, 2'b00, 1, 1, 0);
         mode_53.configure(this, 2, 10, "RW", 0, 2'b00, 1, 1, 0);
         mode_52.configure(this, 2, 8, "RW", 0, 2'b00, 1, 1, 0);
         mode_51.configure(this, 2, 6, "RW", 0, 2'b00, 1, 1, 0);
         mode_50.configure(this, 2, 4, "RW", 0, 2'b00, 1, 1, 0);
         mode_49.configure(this, 2, 2, "RW", 0, 2'b00, 1, 1, 0);
         mode_48.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_out_0
   // 
   // Set the output value of the corresponding GPIOs.
   //--------------------------------------------------------------------

   class gpio_gpio_out_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_out_0)

      rand uvm_reg_field gpio_out_31; 
      rand uvm_reg_field gpio_out_30; 
      rand uvm_reg_field gpio_out_29; 
      rand uvm_reg_field gpio_out_28; 
      rand uvm_reg_field gpio_out_27; 
      rand uvm_reg_field gpio_out_26; 
      rand uvm_reg_field gpio_out_25; 
      rand uvm_reg_field gpio_out_24; 
      rand uvm_reg_field gpio_out_23; 
      rand uvm_reg_field gpio_out_22; 
      rand uvm_reg_field gpio_out_21; 
      rand uvm_reg_field gpio_out_20; 
      rand uvm_reg_field gpio_out_19; 
      rand uvm_reg_field gpio_out_18; 
      rand uvm_reg_field gpio_out_17; 
      rand uvm_reg_field gpio_out_16; 
      rand uvm_reg_field gpio_out_15; 
      rand uvm_reg_field gpio_out_14; 
      rand uvm_reg_field gpio_out_13; 
      rand uvm_reg_field gpio_out_12; 
      rand uvm_reg_field gpio_out_11; 
      rand uvm_reg_field gpio_out_10; 
      rand uvm_reg_field gpio_out_9; 
      rand uvm_reg_field gpio_out_8; 
      rand uvm_reg_field gpio_out_7; 
      rand uvm_reg_field gpio_out_6; 
      rand uvm_reg_field gpio_out_5; 
      rand uvm_reg_field gpio_out_4; 
      rand uvm_reg_field gpio_out_3; 
      rand uvm_reg_field gpio_out_2; 
      rand uvm_reg_field gpio_out_1; 
      rand uvm_reg_field gpio_out_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_out_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_out_31 = uvm_reg_field::type_id::create("gpio_out_31");
         gpio_out_30 = uvm_reg_field::type_id::create("gpio_out_30");
         gpio_out_29 = uvm_reg_field::type_id::create("gpio_out_29");
         gpio_out_28 = uvm_reg_field::type_id::create("gpio_out_28");
         gpio_out_27 = uvm_reg_field::type_id::create("gpio_out_27");
         gpio_out_26 = uvm_reg_field::type_id::create("gpio_out_26");
         gpio_out_25 = uvm_reg_field::type_id::create("gpio_out_25");
         gpio_out_24 = uvm_reg_field::type_id::create("gpio_out_24");
         gpio_out_23 = uvm_reg_field::type_id::create("gpio_out_23");
         gpio_out_22 = uvm_reg_field::type_id::create("gpio_out_22");
         gpio_out_21 = uvm_reg_field::type_id::create("gpio_out_21");
         gpio_out_20 = uvm_reg_field::type_id::create("gpio_out_20");
         gpio_out_19 = uvm_reg_field::type_id::create("gpio_out_19");
         gpio_out_18 = uvm_reg_field::type_id::create("gpio_out_18");
         gpio_out_17 = uvm_reg_field::type_id::create("gpio_out_17");
         gpio_out_16 = uvm_reg_field::type_id::create("gpio_out_16");
         gpio_out_15 = uvm_reg_field::type_id::create("gpio_out_15");
         gpio_out_14 = uvm_reg_field::type_id::create("gpio_out_14");
         gpio_out_13 = uvm_reg_field::type_id::create("gpio_out_13");
         gpio_out_12 = uvm_reg_field::type_id::create("gpio_out_12");
         gpio_out_11 = uvm_reg_field::type_id::create("gpio_out_11");
         gpio_out_10 = uvm_reg_field::type_id::create("gpio_out_10");
         gpio_out_9 = uvm_reg_field::type_id::create("gpio_out_9");
         gpio_out_8 = uvm_reg_field::type_id::create("gpio_out_8");
         gpio_out_7 = uvm_reg_field::type_id::create("gpio_out_7");
         gpio_out_6 = uvm_reg_field::type_id::create("gpio_out_6");
         gpio_out_5 = uvm_reg_field::type_id::create("gpio_out_5");
         gpio_out_4 = uvm_reg_field::type_id::create("gpio_out_4");
         gpio_out_3 = uvm_reg_field::type_id::create("gpio_out_3");
         gpio_out_2 = uvm_reg_field::type_id::create("gpio_out_2");
         gpio_out_1 = uvm_reg_field::type_id::create("gpio_out_1");
         gpio_out_0 = uvm_reg_field::type_id::create("gpio_out_0");

         gpio_out_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_out_1
   // 
   // Set the output value of the corresponding GPIOs.
   //--------------------------------------------------------------------

   class gpio_gpio_out_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_out_1)

      rand uvm_reg_field gpio_out_55; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_54; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_53; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_52; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_51; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_50; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_49; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_48; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_47; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_46; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_45; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_44; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_43; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_42; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_41; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_40; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_39; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_38; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_37; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_36; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_35; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_34; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_33; // For GPIO_OUT1
      rand uvm_reg_field gpio_out_32; // For GPIO_OUT1


      // Function: new
      // 
      function new(string name = "gpio_gpio_out_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_out_55 = uvm_reg_field::type_id::create("gpio_out_55");
         gpio_out_54 = uvm_reg_field::type_id::create("gpio_out_54");
         gpio_out_53 = uvm_reg_field::type_id::create("gpio_out_53");
         gpio_out_52 = uvm_reg_field::type_id::create("gpio_out_52");
         gpio_out_51 = uvm_reg_field::type_id::create("gpio_out_51");
         gpio_out_50 = uvm_reg_field::type_id::create("gpio_out_50");
         gpio_out_49 = uvm_reg_field::type_id::create("gpio_out_49");
         gpio_out_48 = uvm_reg_field::type_id::create("gpio_out_48");
         gpio_out_47 = uvm_reg_field::type_id::create("gpio_out_47");
         gpio_out_46 = uvm_reg_field::type_id::create("gpio_out_46");
         gpio_out_45 = uvm_reg_field::type_id::create("gpio_out_45");
         gpio_out_44 = uvm_reg_field::type_id::create("gpio_out_44");
         gpio_out_43 = uvm_reg_field::type_id::create("gpio_out_43");
         gpio_out_42 = uvm_reg_field::type_id::create("gpio_out_42");
         gpio_out_41 = uvm_reg_field::type_id::create("gpio_out_41");
         gpio_out_40 = uvm_reg_field::type_id::create("gpio_out_40");
         gpio_out_39 = uvm_reg_field::type_id::create("gpio_out_39");
         gpio_out_38 = uvm_reg_field::type_id::create("gpio_out_38");
         gpio_out_37 = uvm_reg_field::type_id::create("gpio_out_37");
         gpio_out_36 = uvm_reg_field::type_id::create("gpio_out_36");
         gpio_out_35 = uvm_reg_field::type_id::create("gpio_out_35");
         gpio_out_34 = uvm_reg_field::type_id::create("gpio_out_34");
         gpio_out_33 = uvm_reg_field::type_id::create("gpio_out_33");
         gpio_out_32 = uvm_reg_field::type_id::create("gpio_out_32");

         gpio_out_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         gpio_out_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_set_0
   // 
   // For each asserted bit in this register, set the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_set_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_set_0)

      rand uvm_reg_field gpio_set_31; 
      rand uvm_reg_field gpio_set_30; 
      rand uvm_reg_field gpio_set_29; 
      rand uvm_reg_field gpio_set_28; 
      rand uvm_reg_field gpio_set_27; 
      rand uvm_reg_field gpio_set_26; 
      rand uvm_reg_field gpio_set_25; 
      rand uvm_reg_field gpio_set_24; 
      rand uvm_reg_field gpio_set_23; 
      rand uvm_reg_field gpio_set_22; 
      rand uvm_reg_field gpio_set_21; 
      rand uvm_reg_field gpio_set_20; 
      rand uvm_reg_field gpio_set_19; 
      rand uvm_reg_field gpio_set_18; 
      rand uvm_reg_field gpio_set_17; 
      rand uvm_reg_field gpio_set_16; 
      rand uvm_reg_field gpio_set_15; 
      rand uvm_reg_field gpio_set_14; 
      rand uvm_reg_field gpio_set_13; 
      rand uvm_reg_field gpio_set_12; 
      rand uvm_reg_field gpio_set_11; 
      rand uvm_reg_field gpio_set_10; 
      rand uvm_reg_field gpio_set_9; 
      rand uvm_reg_field gpio_set_8; 
      rand uvm_reg_field gpio_set_7; 
      rand uvm_reg_field gpio_set_6; 
      rand uvm_reg_field gpio_set_5; 
      rand uvm_reg_field gpio_set_4; 
      rand uvm_reg_field gpio_set_3; 
      rand uvm_reg_field gpio_set_2; 
      rand uvm_reg_field gpio_set_1; 
      rand uvm_reg_field gpio_set_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_set_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_set_31 = uvm_reg_field::type_id::create("gpio_set_31");
         gpio_set_30 = uvm_reg_field::type_id::create("gpio_set_30");
         gpio_set_29 = uvm_reg_field::type_id::create("gpio_set_29");
         gpio_set_28 = uvm_reg_field::type_id::create("gpio_set_28");
         gpio_set_27 = uvm_reg_field::type_id::create("gpio_set_27");
         gpio_set_26 = uvm_reg_field::type_id::create("gpio_set_26");
         gpio_set_25 = uvm_reg_field::type_id::create("gpio_set_25");
         gpio_set_24 = uvm_reg_field::type_id::create("gpio_set_24");
         gpio_set_23 = uvm_reg_field::type_id::create("gpio_set_23");
         gpio_set_22 = uvm_reg_field::type_id::create("gpio_set_22");
         gpio_set_21 = uvm_reg_field::type_id::create("gpio_set_21");
         gpio_set_20 = uvm_reg_field::type_id::create("gpio_set_20");
         gpio_set_19 = uvm_reg_field::type_id::create("gpio_set_19");
         gpio_set_18 = uvm_reg_field::type_id::create("gpio_set_18");
         gpio_set_17 = uvm_reg_field::type_id::create("gpio_set_17");
         gpio_set_16 = uvm_reg_field::type_id::create("gpio_set_16");
         gpio_set_15 = uvm_reg_field::type_id::create("gpio_set_15");
         gpio_set_14 = uvm_reg_field::type_id::create("gpio_set_14");
         gpio_set_13 = uvm_reg_field::type_id::create("gpio_set_13");
         gpio_set_12 = uvm_reg_field::type_id::create("gpio_set_12");
         gpio_set_11 = uvm_reg_field::type_id::create("gpio_set_11");
         gpio_set_10 = uvm_reg_field::type_id::create("gpio_set_10");
         gpio_set_9 = uvm_reg_field::type_id::create("gpio_set_9");
         gpio_set_8 = uvm_reg_field::type_id::create("gpio_set_8");
         gpio_set_7 = uvm_reg_field::type_id::create("gpio_set_7");
         gpio_set_6 = uvm_reg_field::type_id::create("gpio_set_6");
         gpio_set_5 = uvm_reg_field::type_id::create("gpio_set_5");
         gpio_set_4 = uvm_reg_field::type_id::create("gpio_set_4");
         gpio_set_3 = uvm_reg_field::type_id::create("gpio_set_3");
         gpio_set_2 = uvm_reg_field::type_id::create("gpio_set_2");
         gpio_set_1 = uvm_reg_field::type_id::create("gpio_set_1");
         gpio_set_0 = uvm_reg_field::type_id::create("gpio_set_0");

         gpio_set_31.configure(this, 1, 31, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_30.configure(this, 1, 30, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_29.configure(this, 1, 29, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_28.configure(this, 1, 28, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_27.configure(this, 1, 27, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_26.configure(this, 1, 26, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_25.configure(this, 1, 25, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_24.configure(this, 1, 24, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_23.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_22.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_21.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_20.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_19.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_18.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_17.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_16.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_15.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_14.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_13.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_12.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_11.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_10.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_9.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_8.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_7.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_6.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_5.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_4.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_3.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_2.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_1.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_0.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_set_1
   // 
   // For each asserted bit in this register, set the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_set_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_set_1)

      rand uvm_reg_field gpio_set_55; // For GPIO_SET1
      rand uvm_reg_field gpio_set_54; // For GPIO_SET1
      rand uvm_reg_field gpio_set_53; // For GPIO_SET1
      rand uvm_reg_field gpio_set_52; // For GPIO_SET1
      rand uvm_reg_field gpio_set_51; // For GPIO_SET1
      rand uvm_reg_field gpio_set_50; // For GPIO_SET1
      rand uvm_reg_field gpio_set_49; // For GPIO_SET1
      rand uvm_reg_field gpio_set_48; // For GPIO_SET1
      rand uvm_reg_field gpio_set_47; // For GPIO_SET1
      rand uvm_reg_field gpio_set_46; // For GPIO_SET1
      rand uvm_reg_field gpio_set_45; // For GPIO_SET1
      rand uvm_reg_field gpio_set_44; // For GPIO_SET1
      rand uvm_reg_field gpio_set_43; // For GPIO_SET1
      rand uvm_reg_field gpio_set_42; // For GPIO_SET1
      rand uvm_reg_field gpio_set_41; // For GPIO_SET1
      rand uvm_reg_field gpio_set_40; // For GPIO_SET1
      rand uvm_reg_field gpio_set_39; // For GPIO_SET1
      rand uvm_reg_field gpio_set_38; // For GPIO_SET1
      rand uvm_reg_field gpio_set_37; // For GPIO_SET1
      rand uvm_reg_field gpio_set_36; // For GPIO_SET1
      rand uvm_reg_field gpio_set_35; // For GPIO_SET1
      rand uvm_reg_field gpio_set_34; // For GPIO_SET1
      rand uvm_reg_field gpio_set_33; // For GPIO_SET1
      rand uvm_reg_field gpio_set_32; // For GPIO_SET1


      // Function: new
      // 
      function new(string name = "gpio_gpio_set_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_set_55 = uvm_reg_field::type_id::create("gpio_set_55");
         gpio_set_54 = uvm_reg_field::type_id::create("gpio_set_54");
         gpio_set_53 = uvm_reg_field::type_id::create("gpio_set_53");
         gpio_set_52 = uvm_reg_field::type_id::create("gpio_set_52");
         gpio_set_51 = uvm_reg_field::type_id::create("gpio_set_51");
         gpio_set_50 = uvm_reg_field::type_id::create("gpio_set_50");
         gpio_set_49 = uvm_reg_field::type_id::create("gpio_set_49");
         gpio_set_48 = uvm_reg_field::type_id::create("gpio_set_48");
         gpio_set_47 = uvm_reg_field::type_id::create("gpio_set_47");
         gpio_set_46 = uvm_reg_field::type_id::create("gpio_set_46");
         gpio_set_45 = uvm_reg_field::type_id::create("gpio_set_45");
         gpio_set_44 = uvm_reg_field::type_id::create("gpio_set_44");
         gpio_set_43 = uvm_reg_field::type_id::create("gpio_set_43");
         gpio_set_42 = uvm_reg_field::type_id::create("gpio_set_42");
         gpio_set_41 = uvm_reg_field::type_id::create("gpio_set_41");
         gpio_set_40 = uvm_reg_field::type_id::create("gpio_set_40");
         gpio_set_39 = uvm_reg_field::type_id::create("gpio_set_39");
         gpio_set_38 = uvm_reg_field::type_id::create("gpio_set_38");
         gpio_set_37 = uvm_reg_field::type_id::create("gpio_set_37");
         gpio_set_36 = uvm_reg_field::type_id::create("gpio_set_36");
         gpio_set_35 = uvm_reg_field::type_id::create("gpio_set_35");
         gpio_set_34 = uvm_reg_field::type_id::create("gpio_set_34");
         gpio_set_33 = uvm_reg_field::type_id::create("gpio_set_33");
         gpio_set_32 = uvm_reg_field::type_id::create("gpio_set_32");

         gpio_set_55.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_54.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_53.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_52.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_51.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_50.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_49.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_48.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_47.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_46.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_45.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_44.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_43.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_42.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_41.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_40.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_39.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_38.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_37.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_36.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_35.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_34.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_33.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_set_32.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_toggle_0
   // 
   // For each asserted bit in this register, toggle the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_toggle_0 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_toggle_0)

      rand uvm_reg_field gpio_toggle_31; 
      rand uvm_reg_field gpio_toggle_30; 
      rand uvm_reg_field gpio_toggle_29; 
      rand uvm_reg_field gpio_toggle_28; 
      rand uvm_reg_field gpio_toggle_27; 
      rand uvm_reg_field gpio_toggle_26; 
      rand uvm_reg_field gpio_toggle_25; 
      rand uvm_reg_field gpio_toggle_24; 
      rand uvm_reg_field gpio_toggle_23; 
      rand uvm_reg_field gpio_toggle_22; 
      rand uvm_reg_field gpio_toggle_21; 
      rand uvm_reg_field gpio_toggle_20; 
      rand uvm_reg_field gpio_toggle_19; 
      rand uvm_reg_field gpio_toggle_18; 
      rand uvm_reg_field gpio_toggle_17; 
      rand uvm_reg_field gpio_toggle_16; 
      rand uvm_reg_field gpio_toggle_15; 
      rand uvm_reg_field gpio_toggle_14; 
      rand uvm_reg_field gpio_toggle_13; 
      rand uvm_reg_field gpio_toggle_12; 
      rand uvm_reg_field gpio_toggle_11; 
      rand uvm_reg_field gpio_toggle_10; 
      rand uvm_reg_field gpio_toggle_9; 
      rand uvm_reg_field gpio_toggle_8; 
      rand uvm_reg_field gpio_toggle_7; 
      rand uvm_reg_field gpio_toggle_6; 
      rand uvm_reg_field gpio_toggle_5; 
      rand uvm_reg_field gpio_toggle_4; 
      rand uvm_reg_field gpio_toggle_3; 
      rand uvm_reg_field gpio_toggle_2; 
      rand uvm_reg_field gpio_toggle_1; 
      rand uvm_reg_field gpio_toggle_0; 


      // Function: new
      // 
      function new(string name = "gpio_gpio_toggle_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_toggle_31 = uvm_reg_field::type_id::create("gpio_toggle_31");
         gpio_toggle_30 = uvm_reg_field::type_id::create("gpio_toggle_30");
         gpio_toggle_29 = uvm_reg_field::type_id::create("gpio_toggle_29");
         gpio_toggle_28 = uvm_reg_field::type_id::create("gpio_toggle_28");
         gpio_toggle_27 = uvm_reg_field::type_id::create("gpio_toggle_27");
         gpio_toggle_26 = uvm_reg_field::type_id::create("gpio_toggle_26");
         gpio_toggle_25 = uvm_reg_field::type_id::create("gpio_toggle_25");
         gpio_toggle_24 = uvm_reg_field::type_id::create("gpio_toggle_24");
         gpio_toggle_23 = uvm_reg_field::type_id::create("gpio_toggle_23");
         gpio_toggle_22 = uvm_reg_field::type_id::create("gpio_toggle_22");
         gpio_toggle_21 = uvm_reg_field::type_id::create("gpio_toggle_21");
         gpio_toggle_20 = uvm_reg_field::type_id::create("gpio_toggle_20");
         gpio_toggle_19 = uvm_reg_field::type_id::create("gpio_toggle_19");
         gpio_toggle_18 = uvm_reg_field::type_id::create("gpio_toggle_18");
         gpio_toggle_17 = uvm_reg_field::type_id::create("gpio_toggle_17");
         gpio_toggle_16 = uvm_reg_field::type_id::create("gpio_toggle_16");
         gpio_toggle_15 = uvm_reg_field::type_id::create("gpio_toggle_15");
         gpio_toggle_14 = uvm_reg_field::type_id::create("gpio_toggle_14");
         gpio_toggle_13 = uvm_reg_field::type_id::create("gpio_toggle_13");
         gpio_toggle_12 = uvm_reg_field::type_id::create("gpio_toggle_12");
         gpio_toggle_11 = uvm_reg_field::type_id::create("gpio_toggle_11");
         gpio_toggle_10 = uvm_reg_field::type_id::create("gpio_toggle_10");
         gpio_toggle_9 = uvm_reg_field::type_id::create("gpio_toggle_9");
         gpio_toggle_8 = uvm_reg_field::type_id::create("gpio_toggle_8");
         gpio_toggle_7 = uvm_reg_field::type_id::create("gpio_toggle_7");
         gpio_toggle_6 = uvm_reg_field::type_id::create("gpio_toggle_6");
         gpio_toggle_5 = uvm_reg_field::type_id::create("gpio_toggle_5");
         gpio_toggle_4 = uvm_reg_field::type_id::create("gpio_toggle_4");
         gpio_toggle_3 = uvm_reg_field::type_id::create("gpio_toggle_3");
         gpio_toggle_2 = uvm_reg_field::type_id::create("gpio_toggle_2");
         gpio_toggle_1 = uvm_reg_field::type_id::create("gpio_toggle_1");
         gpio_toggle_0 = uvm_reg_field::type_id::create("gpio_toggle_0");

         gpio_toggle_31.configure(this, 1, 31, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_30.configure(this, 1, 30, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_29.configure(this, 1, 29, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_28.configure(this, 1, 28, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_27.configure(this, 1, 27, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_26.configure(this, 1, 26, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_25.configure(this, 1, 25, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_24.configure(this, 1, 24, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_23.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_22.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_21.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_20.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_19.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_18.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_17.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_16.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_15.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_14.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_13.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_12.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_11.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_10.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_9.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_8.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_7.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_6.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_5.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_4.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_3.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_2.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_1.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_0.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_gpio_toggle_1
   // 
   // For each asserted bit in this register, toggle the corresponding bit in the padout register.
   //--------------------------------------------------------------------

   class gpio_gpio_toggle_1 extends uvm_reg;
      `uvm_object_utils(gpio_gpio_toggle_1)

      rand uvm_reg_field gpio_toggle_55; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_54; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_53; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_52; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_51; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_50; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_49; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_48; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_47; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_46; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_45; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_44; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_43; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_42; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_41; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_40; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_39; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_38; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_37; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_36; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_35; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_34; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_33; // For GPIO_TOGGLE1
      rand uvm_reg_field gpio_toggle_32; // For GPIO_TOGGLE1


      // Function: new
      // 
      function new(string name = "gpio_gpio_toggle_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         gpio_toggle_55 = uvm_reg_field::type_id::create("gpio_toggle_55");
         gpio_toggle_54 = uvm_reg_field::type_id::create("gpio_toggle_54");
         gpio_toggle_53 = uvm_reg_field::type_id::create("gpio_toggle_53");
         gpio_toggle_52 = uvm_reg_field::type_id::create("gpio_toggle_52");
         gpio_toggle_51 = uvm_reg_field::type_id::create("gpio_toggle_51");
         gpio_toggle_50 = uvm_reg_field::type_id::create("gpio_toggle_50");
         gpio_toggle_49 = uvm_reg_field::type_id::create("gpio_toggle_49");
         gpio_toggle_48 = uvm_reg_field::type_id::create("gpio_toggle_48");
         gpio_toggle_47 = uvm_reg_field::type_id::create("gpio_toggle_47");
         gpio_toggle_46 = uvm_reg_field::type_id::create("gpio_toggle_46");
         gpio_toggle_45 = uvm_reg_field::type_id::create("gpio_toggle_45");
         gpio_toggle_44 = uvm_reg_field::type_id::create("gpio_toggle_44");
         gpio_toggle_43 = uvm_reg_field::type_id::create("gpio_toggle_43");
         gpio_toggle_42 = uvm_reg_field::type_id::create("gpio_toggle_42");
         gpio_toggle_41 = uvm_reg_field::type_id::create("gpio_toggle_41");
         gpio_toggle_40 = uvm_reg_field::type_id::create("gpio_toggle_40");
         gpio_toggle_39 = uvm_reg_field::type_id::create("gpio_toggle_39");
         gpio_toggle_38 = uvm_reg_field::type_id::create("gpio_toggle_38");
         gpio_toggle_37 = uvm_reg_field::type_id::create("gpio_toggle_37");
         gpio_toggle_36 = uvm_reg_field::type_id::create("gpio_toggle_36");
         gpio_toggle_35 = uvm_reg_field::type_id::create("gpio_toggle_35");
         gpio_toggle_34 = uvm_reg_field::type_id::create("gpio_toggle_34");
         gpio_toggle_33 = uvm_reg_field::type_id::create("gpio_toggle_33");
         gpio_toggle_32 = uvm_reg_field::type_id::create("gpio_toggle_32");

         gpio_toggle_55.configure(this, 1, 23, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_54.configure(this, 1, 22, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_53.configure(this, 1, 21, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_52.configure(this, 1, 20, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_51.configure(this, 1, 19, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_50.configure(this, 1, 18, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_49.configure(this, 1, 17, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_48.configure(this, 1, 16, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_47.configure(this, 1, 15, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_46.configure(this, 1, 14, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_45.configure(this, 1, 13, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_44.configure(this, 1, 12, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_43.configure(this, 1, 11, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_42.configure(this, 1, 10, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_41.configure(this, 1, 9, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_40.configure(this, 1, 8, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_39.configure(this, 1, 7, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_38.configure(this, 1, 6, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_37.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_36.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_35.configure(this, 1, 3, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_34.configure(this, 1, 2, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_33.configure(this, 1, 1, "WO", 0, 1'b0, 1, 1, 0);
         gpio_toggle_32.configure(this, 1, 0, "WO", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_info
   // 
   // Info register that contains information about this peripheral.
   //--------------------------------------------------------------------

   class gpio_info extends uvm_reg;
      `uvm_object_utils(gpio_info)

      uvm_reg_field version; // The version number of the IPs.
      uvm_reg_field gpio_cnt; // Contains the number of GPIOs controlled by this peripheral.


      // Function: new
      // 
      function new(string name = "gpio_info");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         version = uvm_reg_field::type_id::create("version");
         gpio_cnt = uvm_reg_field::type_id::create("gpio_cnt");

         version.configure(this, 10, 10, "RO", 0, 10'b0000000001, 1, 0, 0);
         gpio_cnt.configure(this, 10, 0, "RO", 0, 10'b0000000000, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_fall_en_0
   // 
   // Enable Interrupts on falling edges for the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_fall_en_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_fall_en_0)

      rand uvm_reg_field intrpt_fall_en_31; 
      rand uvm_reg_field intrpt_fall_en_30; 
      rand uvm_reg_field intrpt_fall_en_29; 
      rand uvm_reg_field intrpt_fall_en_28; 
      rand uvm_reg_field intrpt_fall_en_27; 
      rand uvm_reg_field intrpt_fall_en_26; 
      rand uvm_reg_field intrpt_fall_en_25; 
      rand uvm_reg_field intrpt_fall_en_24; 
      rand uvm_reg_field intrpt_fall_en_23; 
      rand uvm_reg_field intrpt_fall_en_22; 
      rand uvm_reg_field intrpt_fall_en_21; 
      rand uvm_reg_field intrpt_fall_en_20; 
      rand uvm_reg_field intrpt_fall_en_19; 
      rand uvm_reg_field intrpt_fall_en_18; 
      rand uvm_reg_field intrpt_fall_en_17; 
      rand uvm_reg_field intrpt_fall_en_16; 
      rand uvm_reg_field intrpt_fall_en_15; 
      rand uvm_reg_field intrpt_fall_en_14; 
      rand uvm_reg_field intrpt_fall_en_13; 
      rand uvm_reg_field intrpt_fall_en_12; 
      rand uvm_reg_field intrpt_fall_en_11; 
      rand uvm_reg_field intrpt_fall_en_10; 
      rand uvm_reg_field intrpt_fall_en_9; 
      rand uvm_reg_field intrpt_fall_en_8; 
      rand uvm_reg_field intrpt_fall_en_7; 
      rand uvm_reg_field intrpt_fall_en_6; 
      rand uvm_reg_field intrpt_fall_en_5; 
      rand uvm_reg_field intrpt_fall_en_4; 
      rand uvm_reg_field intrpt_fall_en_3; 
      rand uvm_reg_field intrpt_fall_en_2; 
      rand uvm_reg_field intrpt_fall_en_1; 
      rand uvm_reg_field intrpt_fall_en_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_fall_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_fall_en_31 = uvm_reg_field::type_id::create("intrpt_fall_en_31");
         intrpt_fall_en_30 = uvm_reg_field::type_id::create("intrpt_fall_en_30");
         intrpt_fall_en_29 = uvm_reg_field::type_id::create("intrpt_fall_en_29");
         intrpt_fall_en_28 = uvm_reg_field::type_id::create("intrpt_fall_en_28");
         intrpt_fall_en_27 = uvm_reg_field::type_id::create("intrpt_fall_en_27");
         intrpt_fall_en_26 = uvm_reg_field::type_id::create("intrpt_fall_en_26");
         intrpt_fall_en_25 = uvm_reg_field::type_id::create("intrpt_fall_en_25");
         intrpt_fall_en_24 = uvm_reg_field::type_id::create("intrpt_fall_en_24");
         intrpt_fall_en_23 = uvm_reg_field::type_id::create("intrpt_fall_en_23");
         intrpt_fall_en_22 = uvm_reg_field::type_id::create("intrpt_fall_en_22");
         intrpt_fall_en_21 = uvm_reg_field::type_id::create("intrpt_fall_en_21");
         intrpt_fall_en_20 = uvm_reg_field::type_id::create("intrpt_fall_en_20");
         intrpt_fall_en_19 = uvm_reg_field::type_id::create("intrpt_fall_en_19");
         intrpt_fall_en_18 = uvm_reg_field::type_id::create("intrpt_fall_en_18");
         intrpt_fall_en_17 = uvm_reg_field::type_id::create("intrpt_fall_en_17");
         intrpt_fall_en_16 = uvm_reg_field::type_id::create("intrpt_fall_en_16");
         intrpt_fall_en_15 = uvm_reg_field::type_id::create("intrpt_fall_en_15");
         intrpt_fall_en_14 = uvm_reg_field::type_id::create("intrpt_fall_en_14");
         intrpt_fall_en_13 = uvm_reg_field::type_id::create("intrpt_fall_en_13");
         intrpt_fall_en_12 = uvm_reg_field::type_id::create("intrpt_fall_en_12");
         intrpt_fall_en_11 = uvm_reg_field::type_id::create("intrpt_fall_en_11");
         intrpt_fall_en_10 = uvm_reg_field::type_id::create("intrpt_fall_en_10");
         intrpt_fall_en_9 = uvm_reg_field::type_id::create("intrpt_fall_en_9");
         intrpt_fall_en_8 = uvm_reg_field::type_id::create("intrpt_fall_en_8");
         intrpt_fall_en_7 = uvm_reg_field::type_id::create("intrpt_fall_en_7");
         intrpt_fall_en_6 = uvm_reg_field::type_id::create("intrpt_fall_en_6");
         intrpt_fall_en_5 = uvm_reg_field::type_id::create("intrpt_fall_en_5");
         intrpt_fall_en_4 = uvm_reg_field::type_id::create("intrpt_fall_en_4");
         intrpt_fall_en_3 = uvm_reg_field::type_id::create("intrpt_fall_en_3");
         intrpt_fall_en_2 = uvm_reg_field::type_id::create("intrpt_fall_en_2");
         intrpt_fall_en_1 = uvm_reg_field::type_id::create("intrpt_fall_en_1");
         intrpt_fall_en_0 = uvm_reg_field::type_id::create("intrpt_fall_en_0");

         intrpt_fall_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_fall_en_1
   // 
   // Enable Interrupts on falling edges for the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_fall_en_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_fall_en_1)

      rand uvm_reg_field intrpt_fall_en_55; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_54; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_53; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_52; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_51; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_50; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_49; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_48; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_47; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_46; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_45; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_44; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_43; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_42; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_41; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_40; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_39; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_38; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_37; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_36; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_35; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_34; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_33; // For INTRPT_FALL_EN1
      rand uvm_reg_field intrpt_fall_en_32; // For INTRPT_FALL_EN1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_fall_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_fall_en_55 = uvm_reg_field::type_id::create("intrpt_fall_en_55");
         intrpt_fall_en_54 = uvm_reg_field::type_id::create("intrpt_fall_en_54");
         intrpt_fall_en_53 = uvm_reg_field::type_id::create("intrpt_fall_en_53");
         intrpt_fall_en_52 = uvm_reg_field::type_id::create("intrpt_fall_en_52");
         intrpt_fall_en_51 = uvm_reg_field::type_id::create("intrpt_fall_en_51");
         intrpt_fall_en_50 = uvm_reg_field::type_id::create("intrpt_fall_en_50");
         intrpt_fall_en_49 = uvm_reg_field::type_id::create("intrpt_fall_en_49");
         intrpt_fall_en_48 = uvm_reg_field::type_id::create("intrpt_fall_en_48");
         intrpt_fall_en_47 = uvm_reg_field::type_id::create("intrpt_fall_en_47");
         intrpt_fall_en_46 = uvm_reg_field::type_id::create("intrpt_fall_en_46");
         intrpt_fall_en_45 = uvm_reg_field::type_id::create("intrpt_fall_en_45");
         intrpt_fall_en_44 = uvm_reg_field::type_id::create("intrpt_fall_en_44");
         intrpt_fall_en_43 = uvm_reg_field::type_id::create("intrpt_fall_en_43");
         intrpt_fall_en_42 = uvm_reg_field::type_id::create("intrpt_fall_en_42");
         intrpt_fall_en_41 = uvm_reg_field::type_id::create("intrpt_fall_en_41");
         intrpt_fall_en_40 = uvm_reg_field::type_id::create("intrpt_fall_en_40");
         intrpt_fall_en_39 = uvm_reg_field::type_id::create("intrpt_fall_en_39");
         intrpt_fall_en_38 = uvm_reg_field::type_id::create("intrpt_fall_en_38");
         intrpt_fall_en_37 = uvm_reg_field::type_id::create("intrpt_fall_en_37");
         intrpt_fall_en_36 = uvm_reg_field::type_id::create("intrpt_fall_en_36");
         intrpt_fall_en_35 = uvm_reg_field::type_id::create("intrpt_fall_en_35");
         intrpt_fall_en_34 = uvm_reg_field::type_id::create("intrpt_fall_en_34");
         intrpt_fall_en_33 = uvm_reg_field::type_id::create("intrpt_fall_en_33");
         intrpt_fall_en_32 = uvm_reg_field::type_id::create("intrpt_fall_en_32");

         intrpt_fall_en_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_fall_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_fall_status_0
   // 
   // Asserted if there is any pending fall interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_fall_status_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_fall_status_0)

      uvm_reg_field intrpt_fall_status_31; 
      uvm_reg_field intrpt_fall_status_30; 
      uvm_reg_field intrpt_fall_status_29; 
      uvm_reg_field intrpt_fall_status_28; 
      uvm_reg_field intrpt_fall_status_27; 
      uvm_reg_field intrpt_fall_status_26; 
      uvm_reg_field intrpt_fall_status_25; 
      uvm_reg_field intrpt_fall_status_24; 
      uvm_reg_field intrpt_fall_status_23; 
      uvm_reg_field intrpt_fall_status_22; 
      uvm_reg_field intrpt_fall_status_21; 
      uvm_reg_field intrpt_fall_status_20; 
      uvm_reg_field intrpt_fall_status_19; 
      uvm_reg_field intrpt_fall_status_18; 
      uvm_reg_field intrpt_fall_status_17; 
      uvm_reg_field intrpt_fall_status_16; 
      uvm_reg_field intrpt_fall_status_15; 
      uvm_reg_field intrpt_fall_status_14; 
      uvm_reg_field intrpt_fall_status_13; 
      uvm_reg_field intrpt_fall_status_12; 
      uvm_reg_field intrpt_fall_status_11; 
      uvm_reg_field intrpt_fall_status_10; 
      uvm_reg_field intrpt_fall_status_9; 
      uvm_reg_field intrpt_fall_status_8; 
      uvm_reg_field intrpt_fall_status_7; 
      uvm_reg_field intrpt_fall_status_6; 
      uvm_reg_field intrpt_fall_status_5; 
      uvm_reg_field intrpt_fall_status_4; 
      uvm_reg_field intrpt_fall_status_3; 
      uvm_reg_field intrpt_fall_status_2; 
      uvm_reg_field intrpt_fall_status_1; 
      uvm_reg_field intrpt_fall_status_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_fall_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_fall_status_31 = uvm_reg_field::type_id::create("intrpt_fall_status_31");
         intrpt_fall_status_30 = uvm_reg_field::type_id::create("intrpt_fall_status_30");
         intrpt_fall_status_29 = uvm_reg_field::type_id::create("intrpt_fall_status_29");
         intrpt_fall_status_28 = uvm_reg_field::type_id::create("intrpt_fall_status_28");
         intrpt_fall_status_27 = uvm_reg_field::type_id::create("intrpt_fall_status_27");
         intrpt_fall_status_26 = uvm_reg_field::type_id::create("intrpt_fall_status_26");
         intrpt_fall_status_25 = uvm_reg_field::type_id::create("intrpt_fall_status_25");
         intrpt_fall_status_24 = uvm_reg_field::type_id::create("intrpt_fall_status_24");
         intrpt_fall_status_23 = uvm_reg_field::type_id::create("intrpt_fall_status_23");
         intrpt_fall_status_22 = uvm_reg_field::type_id::create("intrpt_fall_status_22");
         intrpt_fall_status_21 = uvm_reg_field::type_id::create("intrpt_fall_status_21");
         intrpt_fall_status_20 = uvm_reg_field::type_id::create("intrpt_fall_status_20");
         intrpt_fall_status_19 = uvm_reg_field::type_id::create("intrpt_fall_status_19");
         intrpt_fall_status_18 = uvm_reg_field::type_id::create("intrpt_fall_status_18");
         intrpt_fall_status_17 = uvm_reg_field::type_id::create("intrpt_fall_status_17");
         intrpt_fall_status_16 = uvm_reg_field::type_id::create("intrpt_fall_status_16");
         intrpt_fall_status_15 = uvm_reg_field::type_id::create("intrpt_fall_status_15");
         intrpt_fall_status_14 = uvm_reg_field::type_id::create("intrpt_fall_status_14");
         intrpt_fall_status_13 = uvm_reg_field::type_id::create("intrpt_fall_status_13");
         intrpt_fall_status_12 = uvm_reg_field::type_id::create("intrpt_fall_status_12");
         intrpt_fall_status_11 = uvm_reg_field::type_id::create("intrpt_fall_status_11");
         intrpt_fall_status_10 = uvm_reg_field::type_id::create("intrpt_fall_status_10");
         intrpt_fall_status_9 = uvm_reg_field::type_id::create("intrpt_fall_status_9");
         intrpt_fall_status_8 = uvm_reg_field::type_id::create("intrpt_fall_status_8");
         intrpt_fall_status_7 = uvm_reg_field::type_id::create("intrpt_fall_status_7");
         intrpt_fall_status_6 = uvm_reg_field::type_id::create("intrpt_fall_status_6");
         intrpt_fall_status_5 = uvm_reg_field::type_id::create("intrpt_fall_status_5");
         intrpt_fall_status_4 = uvm_reg_field::type_id::create("intrpt_fall_status_4");
         intrpt_fall_status_3 = uvm_reg_field::type_id::create("intrpt_fall_status_3");
         intrpt_fall_status_2 = uvm_reg_field::type_id::create("intrpt_fall_status_2");
         intrpt_fall_status_1 = uvm_reg_field::type_id::create("intrpt_fall_status_1");
         intrpt_fall_status_0 = uvm_reg_field::type_id::create("intrpt_fall_status_0");

         intrpt_fall_status_31.configure(this, 1, 31, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_30.configure(this, 1, 30, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_29.configure(this, 1, 29, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_28.configure(this, 1, 28, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_27.configure(this, 1, 27, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_26.configure(this, 1, 26, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_25.configure(this, 1, 25, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_24.configure(this, 1, 24, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_23.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_22.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_21.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_20.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_19.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_18.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_17.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_16.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_15.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_14.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_13.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_12.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_11.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_10.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_9.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_8.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_7.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_6.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_5.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_4.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_3.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_2.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_1.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_0.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_fall_status_1
   // 
   // Asserted if there is any pending fall interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_fall_status_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_fall_status_1)

      uvm_reg_field intrpt_fall_status_55; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_54; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_53; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_52; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_51; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_50; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_49; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_48; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_47; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_46; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_45; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_44; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_43; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_42; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_41; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_40; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_39; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_38; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_37; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_36; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_35; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_34; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_33; // For INTRPT_FALL_STATUS1
      uvm_reg_field intrpt_fall_status_32; // For INTRPT_FALL_STATUS1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_fall_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_fall_status_55 = uvm_reg_field::type_id::create("intrpt_fall_status_55");
         intrpt_fall_status_54 = uvm_reg_field::type_id::create("intrpt_fall_status_54");
         intrpt_fall_status_53 = uvm_reg_field::type_id::create("intrpt_fall_status_53");
         intrpt_fall_status_52 = uvm_reg_field::type_id::create("intrpt_fall_status_52");
         intrpt_fall_status_51 = uvm_reg_field::type_id::create("intrpt_fall_status_51");
         intrpt_fall_status_50 = uvm_reg_field::type_id::create("intrpt_fall_status_50");
         intrpt_fall_status_49 = uvm_reg_field::type_id::create("intrpt_fall_status_49");
         intrpt_fall_status_48 = uvm_reg_field::type_id::create("intrpt_fall_status_48");
         intrpt_fall_status_47 = uvm_reg_field::type_id::create("intrpt_fall_status_47");
         intrpt_fall_status_46 = uvm_reg_field::type_id::create("intrpt_fall_status_46");
         intrpt_fall_status_45 = uvm_reg_field::type_id::create("intrpt_fall_status_45");
         intrpt_fall_status_44 = uvm_reg_field::type_id::create("intrpt_fall_status_44");
         intrpt_fall_status_43 = uvm_reg_field::type_id::create("intrpt_fall_status_43");
         intrpt_fall_status_42 = uvm_reg_field::type_id::create("intrpt_fall_status_42");
         intrpt_fall_status_41 = uvm_reg_field::type_id::create("intrpt_fall_status_41");
         intrpt_fall_status_40 = uvm_reg_field::type_id::create("intrpt_fall_status_40");
         intrpt_fall_status_39 = uvm_reg_field::type_id::create("intrpt_fall_status_39");
         intrpt_fall_status_38 = uvm_reg_field::type_id::create("intrpt_fall_status_38");
         intrpt_fall_status_37 = uvm_reg_field::type_id::create("intrpt_fall_status_37");
         intrpt_fall_status_36 = uvm_reg_field::type_id::create("intrpt_fall_status_36");
         intrpt_fall_status_35 = uvm_reg_field::type_id::create("intrpt_fall_status_35");
         intrpt_fall_status_34 = uvm_reg_field::type_id::create("intrpt_fall_status_34");
         intrpt_fall_status_33 = uvm_reg_field::type_id::create("intrpt_fall_status_33");
         intrpt_fall_status_32 = uvm_reg_field::type_id::create("intrpt_fall_status_32");

         intrpt_fall_status_55.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_54.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_53.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_52.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_51.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_50.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_49.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_48.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_47.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_46.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_45.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_44.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_43.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_42.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_41.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_40.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_39.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_38.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_37.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_36.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_35.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_34.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_33.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_fall_status_32.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_high_en_0
   // 
   // Enable logic high level-sensitive Interrupts on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_high_en_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_high_en_0)

      rand uvm_reg_field intrpt_lvl_high_en_31; 
      rand uvm_reg_field intrpt_lvl_high_en_30; 
      rand uvm_reg_field intrpt_lvl_high_en_29; 
      rand uvm_reg_field intrpt_lvl_high_en_28; 
      rand uvm_reg_field intrpt_lvl_high_en_27; 
      rand uvm_reg_field intrpt_lvl_high_en_26; 
      rand uvm_reg_field intrpt_lvl_high_en_25; 
      rand uvm_reg_field intrpt_lvl_high_en_24; 
      rand uvm_reg_field intrpt_lvl_high_en_23; 
      rand uvm_reg_field intrpt_lvl_high_en_22; 
      rand uvm_reg_field intrpt_lvl_high_en_21; 
      rand uvm_reg_field intrpt_lvl_high_en_20; 
      rand uvm_reg_field intrpt_lvl_high_en_19; 
      rand uvm_reg_field intrpt_lvl_high_en_18; 
      rand uvm_reg_field intrpt_lvl_high_en_17; 
      rand uvm_reg_field intrpt_lvl_high_en_16; 
      rand uvm_reg_field intrpt_lvl_high_en_15; 
      rand uvm_reg_field intrpt_lvl_high_en_14; 
      rand uvm_reg_field intrpt_lvl_high_en_13; 
      rand uvm_reg_field intrpt_lvl_high_en_12; 
      rand uvm_reg_field intrpt_lvl_high_en_11; 
      rand uvm_reg_field intrpt_lvl_high_en_10; 
      rand uvm_reg_field intrpt_lvl_high_en_9; 
      rand uvm_reg_field intrpt_lvl_high_en_8; 
      rand uvm_reg_field intrpt_lvl_high_en_7; 
      rand uvm_reg_field intrpt_lvl_high_en_6; 
      rand uvm_reg_field intrpt_lvl_high_en_5; 
      rand uvm_reg_field intrpt_lvl_high_en_4; 
      rand uvm_reg_field intrpt_lvl_high_en_3; 
      rand uvm_reg_field intrpt_lvl_high_en_2; 
      rand uvm_reg_field intrpt_lvl_high_en_1; 
      rand uvm_reg_field intrpt_lvl_high_en_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_high_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_high_en_31 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_31");
         intrpt_lvl_high_en_30 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_30");
         intrpt_lvl_high_en_29 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_29");
         intrpt_lvl_high_en_28 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_28");
         intrpt_lvl_high_en_27 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_27");
         intrpt_lvl_high_en_26 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_26");
         intrpt_lvl_high_en_25 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_25");
         intrpt_lvl_high_en_24 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_24");
         intrpt_lvl_high_en_23 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_23");
         intrpt_lvl_high_en_22 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_22");
         intrpt_lvl_high_en_21 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_21");
         intrpt_lvl_high_en_20 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_20");
         intrpt_lvl_high_en_19 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_19");
         intrpt_lvl_high_en_18 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_18");
         intrpt_lvl_high_en_17 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_17");
         intrpt_lvl_high_en_16 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_16");
         intrpt_lvl_high_en_15 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_15");
         intrpt_lvl_high_en_14 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_14");
         intrpt_lvl_high_en_13 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_13");
         intrpt_lvl_high_en_12 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_12");
         intrpt_lvl_high_en_11 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_11");
         intrpt_lvl_high_en_10 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_10");
         intrpt_lvl_high_en_9 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_9");
         intrpt_lvl_high_en_8 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_8");
         intrpt_lvl_high_en_7 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_7");
         intrpt_lvl_high_en_6 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_6");
         intrpt_lvl_high_en_5 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_5");
         intrpt_lvl_high_en_4 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_4");
         intrpt_lvl_high_en_3 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_3");
         intrpt_lvl_high_en_2 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_2");
         intrpt_lvl_high_en_1 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_1");
         intrpt_lvl_high_en_0 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_0");

         intrpt_lvl_high_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_high_en_1
   // 
   // Enable logic high level-sensitive Interrupts on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_high_en_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_high_en_1)

      rand uvm_reg_field intrpt_lvl_high_en_55; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_54; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_53; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_52; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_51; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_50; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_49; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_48; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_47; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_46; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_45; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_44; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_43; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_42; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_41; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_40; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_39; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_38; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_37; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_36; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_35; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_34; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_33; // For INTRPT_LVL_HIGH_EN1
      rand uvm_reg_field intrpt_lvl_high_en_32; // For INTRPT_LVL_HIGH_EN1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_high_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_high_en_55 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_55");
         intrpt_lvl_high_en_54 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_54");
         intrpt_lvl_high_en_53 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_53");
         intrpt_lvl_high_en_52 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_52");
         intrpt_lvl_high_en_51 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_51");
         intrpt_lvl_high_en_50 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_50");
         intrpt_lvl_high_en_49 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_49");
         intrpt_lvl_high_en_48 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_48");
         intrpt_lvl_high_en_47 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_47");
         intrpt_lvl_high_en_46 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_46");
         intrpt_lvl_high_en_45 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_45");
         intrpt_lvl_high_en_44 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_44");
         intrpt_lvl_high_en_43 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_43");
         intrpt_lvl_high_en_42 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_42");
         intrpt_lvl_high_en_41 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_41");
         intrpt_lvl_high_en_40 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_40");
         intrpt_lvl_high_en_39 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_39");
         intrpt_lvl_high_en_38 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_38");
         intrpt_lvl_high_en_37 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_37");
         intrpt_lvl_high_en_36 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_36");
         intrpt_lvl_high_en_35 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_35");
         intrpt_lvl_high_en_34 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_34");
         intrpt_lvl_high_en_33 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_33");
         intrpt_lvl_high_en_32 = uvm_reg_field::type_id::create("intrpt_lvl_high_en_32");

         intrpt_lvl_high_en_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_high_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_high_status_0
   // 
   // Asserted if there is any pending high-level interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_high_status_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_high_status_0)

      uvm_reg_field intrpt_lvl_high_status_31; 
      uvm_reg_field intrpt_lvl_high_status_30; 
      uvm_reg_field intrpt_lvl_high_status_29; 
      uvm_reg_field intrpt_lvl_high_status_28; 
      uvm_reg_field intrpt_lvl_high_status_27; 
      uvm_reg_field intrpt_lvl_high_status_26; 
      uvm_reg_field intrpt_lvl_high_status_25; 
      uvm_reg_field intrpt_lvl_high_status_24; 
      uvm_reg_field intrpt_lvl_high_status_23; 
      uvm_reg_field intrpt_lvl_high_status_22; 
      uvm_reg_field intrpt_lvl_high_status_21; 
      uvm_reg_field intrpt_lvl_high_status_20; 
      uvm_reg_field intrpt_lvl_high_status_19; 
      uvm_reg_field intrpt_lvl_high_status_18; 
      uvm_reg_field intrpt_lvl_high_status_17; 
      uvm_reg_field intrpt_lvl_high_status_16; 
      uvm_reg_field intrpt_lvl_high_status_15; 
      uvm_reg_field intrpt_lvl_high_status_14; 
      uvm_reg_field intrpt_lvl_high_status_13; 
      uvm_reg_field intrpt_lvl_high_status_12; 
      uvm_reg_field intrpt_lvl_high_status_11; 
      uvm_reg_field intrpt_lvl_high_status_10; 
      uvm_reg_field intrpt_lvl_high_status_9; 
      uvm_reg_field intrpt_lvl_high_status_8; 
      uvm_reg_field intrpt_lvl_high_status_7; 
      uvm_reg_field intrpt_lvl_high_status_6; 
      uvm_reg_field intrpt_lvl_high_status_5; 
      uvm_reg_field intrpt_lvl_high_status_4; 
      uvm_reg_field intrpt_lvl_high_status_3; 
      uvm_reg_field intrpt_lvl_high_status_2; 
      uvm_reg_field intrpt_lvl_high_status_1; 
      uvm_reg_field intrpt_lvl_high_status_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_high_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_high_status_31 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_31");
         intrpt_lvl_high_status_30 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_30");
         intrpt_lvl_high_status_29 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_29");
         intrpt_lvl_high_status_28 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_28");
         intrpt_lvl_high_status_27 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_27");
         intrpt_lvl_high_status_26 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_26");
         intrpt_lvl_high_status_25 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_25");
         intrpt_lvl_high_status_24 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_24");
         intrpt_lvl_high_status_23 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_23");
         intrpt_lvl_high_status_22 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_22");
         intrpt_lvl_high_status_21 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_21");
         intrpt_lvl_high_status_20 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_20");
         intrpt_lvl_high_status_19 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_19");
         intrpt_lvl_high_status_18 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_18");
         intrpt_lvl_high_status_17 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_17");
         intrpt_lvl_high_status_16 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_16");
         intrpt_lvl_high_status_15 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_15");
         intrpt_lvl_high_status_14 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_14");
         intrpt_lvl_high_status_13 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_13");
         intrpt_lvl_high_status_12 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_12");
         intrpt_lvl_high_status_11 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_11");
         intrpt_lvl_high_status_10 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_10");
         intrpt_lvl_high_status_9 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_9");
         intrpt_lvl_high_status_8 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_8");
         intrpt_lvl_high_status_7 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_7");
         intrpt_lvl_high_status_6 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_6");
         intrpt_lvl_high_status_5 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_5");
         intrpt_lvl_high_status_4 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_4");
         intrpt_lvl_high_status_3 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_3");
         intrpt_lvl_high_status_2 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_2");
         intrpt_lvl_high_status_1 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_1");
         intrpt_lvl_high_status_0 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_0");

         intrpt_lvl_high_status_31.configure(this, 1, 31, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_30.configure(this, 1, 30, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_29.configure(this, 1, 29, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_28.configure(this, 1, 28, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_27.configure(this, 1, 27, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_26.configure(this, 1, 26, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_25.configure(this, 1, 25, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_24.configure(this, 1, 24, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_23.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_22.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_21.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_20.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_19.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_18.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_17.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_16.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_15.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_14.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_13.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_12.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_11.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_10.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_9.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_8.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_7.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_6.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_5.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_4.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_3.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_2.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_1.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_0.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_high_status_1
   // 
   // Asserted if there is any pending high-level interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_high_status_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_high_status_1)

      uvm_reg_field intrpt_lvl_high_status_55; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_54; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_53; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_52; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_51; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_50; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_49; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_48; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_47; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_46; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_45; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_44; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_43; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_42; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_41; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_40; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_39; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_38; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_37; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_36; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_35; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_34; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_33; // For INTRPT_LVL_HIGH_STATUS1
      uvm_reg_field intrpt_lvl_high_status_32; // For INTRPT_LVL_HIGH_STATUS1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_high_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_high_status_55 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_55");
         intrpt_lvl_high_status_54 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_54");
         intrpt_lvl_high_status_53 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_53");
         intrpt_lvl_high_status_52 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_52");
         intrpt_lvl_high_status_51 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_51");
         intrpt_lvl_high_status_50 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_50");
         intrpt_lvl_high_status_49 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_49");
         intrpt_lvl_high_status_48 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_48");
         intrpt_lvl_high_status_47 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_47");
         intrpt_lvl_high_status_46 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_46");
         intrpt_lvl_high_status_45 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_45");
         intrpt_lvl_high_status_44 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_44");
         intrpt_lvl_high_status_43 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_43");
         intrpt_lvl_high_status_42 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_42");
         intrpt_lvl_high_status_41 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_41");
         intrpt_lvl_high_status_40 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_40");
         intrpt_lvl_high_status_39 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_39");
         intrpt_lvl_high_status_38 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_38");
         intrpt_lvl_high_status_37 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_37");
         intrpt_lvl_high_status_36 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_36");
         intrpt_lvl_high_status_35 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_35");
         intrpt_lvl_high_status_34 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_34");
         intrpt_lvl_high_status_33 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_33");
         intrpt_lvl_high_status_32 = uvm_reg_field::type_id::create("intrpt_lvl_high_status_32");

         intrpt_lvl_high_status_55.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_54.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_53.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_52.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_51.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_50.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_49.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_48.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_47.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_46.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_45.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_44.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_43.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_42.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_41.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_40.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_39.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_38.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_37.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_36.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_35.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_34.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_33.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_high_status_32.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_low_en_0
   // 
   // Enable logic low level-sensitive Interrupts on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_low_en_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_low_en_0)

      rand uvm_reg_field intrpt_lvl_low_en_31; 
      rand uvm_reg_field intrpt_lvl_low_en_30; 
      rand uvm_reg_field intrpt_lvl_low_en_29; 
      rand uvm_reg_field intrpt_lvl_low_en_28; 
      rand uvm_reg_field intrpt_lvl_low_en_27; 
      rand uvm_reg_field intrpt_lvl_low_en_26; 
      rand uvm_reg_field intrpt_lvl_low_en_25; 
      rand uvm_reg_field intrpt_lvl_low_en_24; 
      rand uvm_reg_field intrpt_lvl_low_en_23; 
      rand uvm_reg_field intrpt_lvl_low_en_22; 
      rand uvm_reg_field intrpt_lvl_low_en_21; 
      rand uvm_reg_field intrpt_lvl_low_en_20; 
      rand uvm_reg_field intrpt_lvl_low_en_19; 
      rand uvm_reg_field intrpt_lvl_low_en_18; 
      rand uvm_reg_field intrpt_lvl_low_en_17; 
      rand uvm_reg_field intrpt_lvl_low_en_16; 
      rand uvm_reg_field intrpt_lvl_low_en_15; 
      rand uvm_reg_field intrpt_lvl_low_en_14; 
      rand uvm_reg_field intrpt_lvl_low_en_13; 
      rand uvm_reg_field intrpt_lvl_low_en_12; 
      rand uvm_reg_field intrpt_lvl_low_en_11; 
      rand uvm_reg_field intrpt_lvl_low_en_10; 
      rand uvm_reg_field intrpt_lvl_low_en_9; 
      rand uvm_reg_field intrpt_lvl_low_en_8; 
      rand uvm_reg_field intrpt_lvl_low_en_7; 
      rand uvm_reg_field intrpt_lvl_low_en_6; 
      rand uvm_reg_field intrpt_lvl_low_en_5; 
      rand uvm_reg_field intrpt_lvl_low_en_4; 
      rand uvm_reg_field intrpt_lvl_low_en_3; 
      rand uvm_reg_field intrpt_lvl_low_en_2; 
      rand uvm_reg_field intrpt_lvl_low_en_1; 
      rand uvm_reg_field intrpt_lvl_low_en_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_low_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_low_en_31 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_31");
         intrpt_lvl_low_en_30 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_30");
         intrpt_lvl_low_en_29 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_29");
         intrpt_lvl_low_en_28 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_28");
         intrpt_lvl_low_en_27 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_27");
         intrpt_lvl_low_en_26 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_26");
         intrpt_lvl_low_en_25 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_25");
         intrpt_lvl_low_en_24 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_24");
         intrpt_lvl_low_en_23 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_23");
         intrpt_lvl_low_en_22 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_22");
         intrpt_lvl_low_en_21 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_21");
         intrpt_lvl_low_en_20 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_20");
         intrpt_lvl_low_en_19 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_19");
         intrpt_lvl_low_en_18 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_18");
         intrpt_lvl_low_en_17 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_17");
         intrpt_lvl_low_en_16 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_16");
         intrpt_lvl_low_en_15 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_15");
         intrpt_lvl_low_en_14 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_14");
         intrpt_lvl_low_en_13 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_13");
         intrpt_lvl_low_en_12 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_12");
         intrpt_lvl_low_en_11 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_11");
         intrpt_lvl_low_en_10 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_10");
         intrpt_lvl_low_en_9 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_9");
         intrpt_lvl_low_en_8 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_8");
         intrpt_lvl_low_en_7 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_7");
         intrpt_lvl_low_en_6 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_6");
         intrpt_lvl_low_en_5 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_5");
         intrpt_lvl_low_en_4 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_4");
         intrpt_lvl_low_en_3 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_3");
         intrpt_lvl_low_en_2 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_2");
         intrpt_lvl_low_en_1 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_1");
         intrpt_lvl_low_en_0 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_0");

         intrpt_lvl_low_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_low_en_1
   // 
   // Enable logic low level-sensitive Interrupts on the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_low_en_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_low_en_1)

      rand uvm_reg_field intrpt_lvl_low_en_55; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_54; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_53; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_52; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_51; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_50; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_49; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_48; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_47; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_46; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_45; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_44; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_43; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_42; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_41; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_40; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_39; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_38; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_37; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_36; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_35; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_34; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_33; // For INTRPT_LVL_LOW_EN1
      rand uvm_reg_field intrpt_lvl_low_en_32; // For INTRPT_LVL_LOW_EN1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_low_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_low_en_55 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_55");
         intrpt_lvl_low_en_54 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_54");
         intrpt_lvl_low_en_53 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_53");
         intrpt_lvl_low_en_52 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_52");
         intrpt_lvl_low_en_51 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_51");
         intrpt_lvl_low_en_50 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_50");
         intrpt_lvl_low_en_49 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_49");
         intrpt_lvl_low_en_48 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_48");
         intrpt_lvl_low_en_47 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_47");
         intrpt_lvl_low_en_46 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_46");
         intrpt_lvl_low_en_45 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_45");
         intrpt_lvl_low_en_44 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_44");
         intrpt_lvl_low_en_43 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_43");
         intrpt_lvl_low_en_42 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_42");
         intrpt_lvl_low_en_41 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_41");
         intrpt_lvl_low_en_40 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_40");
         intrpt_lvl_low_en_39 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_39");
         intrpt_lvl_low_en_38 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_38");
         intrpt_lvl_low_en_37 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_37");
         intrpt_lvl_low_en_36 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_36");
         intrpt_lvl_low_en_35 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_35");
         intrpt_lvl_low_en_34 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_34");
         intrpt_lvl_low_en_33 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_33");
         intrpt_lvl_low_en_32 = uvm_reg_field::type_id::create("intrpt_lvl_low_en_32");

         intrpt_lvl_low_en_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_lvl_low_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_low_status_0
   // 
   // Asserted if there is any pending low-level interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_low_status_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_low_status_0)

      uvm_reg_field intrpt_lvl_low_status_31; 
      uvm_reg_field intrpt_lvl_low_status_30; 
      uvm_reg_field intrpt_lvl_low_status_29; 
      uvm_reg_field intrpt_lvl_low_status_28; 
      uvm_reg_field intrpt_lvl_low_status_27; 
      uvm_reg_field intrpt_lvl_low_status_26; 
      uvm_reg_field intrpt_lvl_low_status_25; 
      uvm_reg_field intrpt_lvl_low_status_24; 
      uvm_reg_field intrpt_lvl_low_status_23; 
      uvm_reg_field intrpt_lvl_low_status_22; 
      uvm_reg_field intrpt_lvl_low_status_21; 
      uvm_reg_field intrpt_lvl_low_status_20; 
      uvm_reg_field intrpt_lvl_low_status_19; 
      uvm_reg_field intrpt_lvl_low_status_18; 
      uvm_reg_field intrpt_lvl_low_status_17; 
      uvm_reg_field intrpt_lvl_low_status_16; 
      uvm_reg_field intrpt_lvl_low_status_15; 
      uvm_reg_field intrpt_lvl_low_status_14; 
      uvm_reg_field intrpt_lvl_low_status_13; 
      uvm_reg_field intrpt_lvl_low_status_12; 
      uvm_reg_field intrpt_lvl_low_status_11; 
      uvm_reg_field intrpt_lvl_low_status_10; 
      uvm_reg_field intrpt_lvl_low_status_9; 
      uvm_reg_field intrpt_lvl_low_status_8; 
      uvm_reg_field intrpt_lvl_low_status_7; 
      uvm_reg_field intrpt_lvl_low_status_6; 
      uvm_reg_field intrpt_lvl_low_status_5; 
      uvm_reg_field intrpt_lvl_low_status_4; 
      uvm_reg_field intrpt_lvl_low_status_3; 
      uvm_reg_field intrpt_lvl_low_status_2; 
      uvm_reg_field intrpt_lvl_low_status_1; 
      uvm_reg_field intrpt_lvl_low_status_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_low_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_low_status_31 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_31");
         intrpt_lvl_low_status_30 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_30");
         intrpt_lvl_low_status_29 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_29");
         intrpt_lvl_low_status_28 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_28");
         intrpt_lvl_low_status_27 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_27");
         intrpt_lvl_low_status_26 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_26");
         intrpt_lvl_low_status_25 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_25");
         intrpt_lvl_low_status_24 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_24");
         intrpt_lvl_low_status_23 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_23");
         intrpt_lvl_low_status_22 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_22");
         intrpt_lvl_low_status_21 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_21");
         intrpt_lvl_low_status_20 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_20");
         intrpt_lvl_low_status_19 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_19");
         intrpt_lvl_low_status_18 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_18");
         intrpt_lvl_low_status_17 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_17");
         intrpt_lvl_low_status_16 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_16");
         intrpt_lvl_low_status_15 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_15");
         intrpt_lvl_low_status_14 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_14");
         intrpt_lvl_low_status_13 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_13");
         intrpt_lvl_low_status_12 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_12");
         intrpt_lvl_low_status_11 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_11");
         intrpt_lvl_low_status_10 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_10");
         intrpt_lvl_low_status_9 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_9");
         intrpt_lvl_low_status_8 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_8");
         intrpt_lvl_low_status_7 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_7");
         intrpt_lvl_low_status_6 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_6");
         intrpt_lvl_low_status_5 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_5");
         intrpt_lvl_low_status_4 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_4");
         intrpt_lvl_low_status_3 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_3");
         intrpt_lvl_low_status_2 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_2");
         intrpt_lvl_low_status_1 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_1");
         intrpt_lvl_low_status_0 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_0");

         intrpt_lvl_low_status_31.configure(this, 1, 31, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_30.configure(this, 1, 30, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_29.configure(this, 1, 29, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_28.configure(this, 1, 28, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_27.configure(this, 1, 27, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_26.configure(this, 1, 26, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_25.configure(this, 1, 25, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_24.configure(this, 1, 24, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_23.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_22.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_21.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_20.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_19.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_18.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_17.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_16.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_15.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_14.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_13.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_12.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_11.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_10.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_9.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_8.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_7.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_6.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_5.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_4.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_3.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_2.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_1.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_0.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_lvl_low_status_1
   // 
   // Asserted if there is any pending low-level interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_lvl_low_status_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_lvl_low_status_1)

      uvm_reg_field intrpt_lvl_low_status_55; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_54; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_53; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_52; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_51; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_50; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_49; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_48; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_47; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_46; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_45; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_44; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_43; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_42; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_41; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_40; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_39; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_38; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_37; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_36; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_35; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_34; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_33; // For INTRPT_LVL_LOW_STATUS1
      uvm_reg_field intrpt_lvl_low_status_32; // For INTRPT_LVL_LOW_STATUS1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_lvl_low_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_lvl_low_status_55 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_55");
         intrpt_lvl_low_status_54 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_54");
         intrpt_lvl_low_status_53 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_53");
         intrpt_lvl_low_status_52 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_52");
         intrpt_lvl_low_status_51 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_51");
         intrpt_lvl_low_status_50 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_50");
         intrpt_lvl_low_status_49 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_49");
         intrpt_lvl_low_status_48 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_48");
         intrpt_lvl_low_status_47 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_47");
         intrpt_lvl_low_status_46 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_46");
         intrpt_lvl_low_status_45 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_45");
         intrpt_lvl_low_status_44 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_44");
         intrpt_lvl_low_status_43 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_43");
         intrpt_lvl_low_status_42 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_42");
         intrpt_lvl_low_status_41 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_41");
         intrpt_lvl_low_status_40 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_40");
         intrpt_lvl_low_status_39 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_39");
         intrpt_lvl_low_status_38 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_38");
         intrpt_lvl_low_status_37 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_37");
         intrpt_lvl_low_status_36 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_36");
         intrpt_lvl_low_status_35 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_35");
         intrpt_lvl_low_status_34 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_34");
         intrpt_lvl_low_status_33 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_33");
         intrpt_lvl_low_status_32 = uvm_reg_field::type_id::create("intrpt_lvl_low_status_32");

         intrpt_lvl_low_status_55.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_54.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_53.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_52.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_51.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_50.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_49.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_48.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_47.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_46.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_45.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_44.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_43.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_42.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_41.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_40.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_39.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_38.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_37.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_36.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_35.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_34.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_33.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_lvl_low_status_32.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_rise_en_0
   // 
   // Enable Interrupts on rising edges for the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_rise_en_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_rise_en_0)

      rand uvm_reg_field intrpt_rise_en_31; 
      rand uvm_reg_field intrpt_rise_en_30; 
      rand uvm_reg_field intrpt_rise_en_29; 
      rand uvm_reg_field intrpt_rise_en_28; 
      rand uvm_reg_field intrpt_rise_en_27; 
      rand uvm_reg_field intrpt_rise_en_26; 
      rand uvm_reg_field intrpt_rise_en_25; 
      rand uvm_reg_field intrpt_rise_en_24; 
      rand uvm_reg_field intrpt_rise_en_23; 
      rand uvm_reg_field intrpt_rise_en_22; 
      rand uvm_reg_field intrpt_rise_en_21; 
      rand uvm_reg_field intrpt_rise_en_20; 
      rand uvm_reg_field intrpt_rise_en_19; 
      rand uvm_reg_field intrpt_rise_en_18; 
      rand uvm_reg_field intrpt_rise_en_17; 
      rand uvm_reg_field intrpt_rise_en_16; 
      rand uvm_reg_field intrpt_rise_en_15; 
      rand uvm_reg_field intrpt_rise_en_14; 
      rand uvm_reg_field intrpt_rise_en_13; 
      rand uvm_reg_field intrpt_rise_en_12; 
      rand uvm_reg_field intrpt_rise_en_11; 
      rand uvm_reg_field intrpt_rise_en_10; 
      rand uvm_reg_field intrpt_rise_en_9; 
      rand uvm_reg_field intrpt_rise_en_8; 
      rand uvm_reg_field intrpt_rise_en_7; 
      rand uvm_reg_field intrpt_rise_en_6; 
      rand uvm_reg_field intrpt_rise_en_5; 
      rand uvm_reg_field intrpt_rise_en_4; 
      rand uvm_reg_field intrpt_rise_en_3; 
      rand uvm_reg_field intrpt_rise_en_2; 
      rand uvm_reg_field intrpt_rise_en_1; 
      rand uvm_reg_field intrpt_rise_en_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_rise_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_rise_en_31 = uvm_reg_field::type_id::create("intrpt_rise_en_31");
         intrpt_rise_en_30 = uvm_reg_field::type_id::create("intrpt_rise_en_30");
         intrpt_rise_en_29 = uvm_reg_field::type_id::create("intrpt_rise_en_29");
         intrpt_rise_en_28 = uvm_reg_field::type_id::create("intrpt_rise_en_28");
         intrpt_rise_en_27 = uvm_reg_field::type_id::create("intrpt_rise_en_27");
         intrpt_rise_en_26 = uvm_reg_field::type_id::create("intrpt_rise_en_26");
         intrpt_rise_en_25 = uvm_reg_field::type_id::create("intrpt_rise_en_25");
         intrpt_rise_en_24 = uvm_reg_field::type_id::create("intrpt_rise_en_24");
         intrpt_rise_en_23 = uvm_reg_field::type_id::create("intrpt_rise_en_23");
         intrpt_rise_en_22 = uvm_reg_field::type_id::create("intrpt_rise_en_22");
         intrpt_rise_en_21 = uvm_reg_field::type_id::create("intrpt_rise_en_21");
         intrpt_rise_en_20 = uvm_reg_field::type_id::create("intrpt_rise_en_20");
         intrpt_rise_en_19 = uvm_reg_field::type_id::create("intrpt_rise_en_19");
         intrpt_rise_en_18 = uvm_reg_field::type_id::create("intrpt_rise_en_18");
         intrpt_rise_en_17 = uvm_reg_field::type_id::create("intrpt_rise_en_17");
         intrpt_rise_en_16 = uvm_reg_field::type_id::create("intrpt_rise_en_16");
         intrpt_rise_en_15 = uvm_reg_field::type_id::create("intrpt_rise_en_15");
         intrpt_rise_en_14 = uvm_reg_field::type_id::create("intrpt_rise_en_14");
         intrpt_rise_en_13 = uvm_reg_field::type_id::create("intrpt_rise_en_13");
         intrpt_rise_en_12 = uvm_reg_field::type_id::create("intrpt_rise_en_12");
         intrpt_rise_en_11 = uvm_reg_field::type_id::create("intrpt_rise_en_11");
         intrpt_rise_en_10 = uvm_reg_field::type_id::create("intrpt_rise_en_10");
         intrpt_rise_en_9 = uvm_reg_field::type_id::create("intrpt_rise_en_9");
         intrpt_rise_en_8 = uvm_reg_field::type_id::create("intrpt_rise_en_8");
         intrpt_rise_en_7 = uvm_reg_field::type_id::create("intrpt_rise_en_7");
         intrpt_rise_en_6 = uvm_reg_field::type_id::create("intrpt_rise_en_6");
         intrpt_rise_en_5 = uvm_reg_field::type_id::create("intrpt_rise_en_5");
         intrpt_rise_en_4 = uvm_reg_field::type_id::create("intrpt_rise_en_4");
         intrpt_rise_en_3 = uvm_reg_field::type_id::create("intrpt_rise_en_3");
         intrpt_rise_en_2 = uvm_reg_field::type_id::create("intrpt_rise_en_2");
         intrpt_rise_en_1 = uvm_reg_field::type_id::create("intrpt_rise_en_1");
         intrpt_rise_en_0 = uvm_reg_field::type_id::create("intrpt_rise_en_0");

         intrpt_rise_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_rise_en_1
   // 
   // Enable Interrupts on rising edges for the corresponding GPIO
   //--------------------------------------------------------------------

   class gpio_intrpt_rise_en_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_rise_en_1)

      rand uvm_reg_field intrpt_rise_en_55; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_54; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_53; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_52; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_51; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_50; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_49; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_48; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_47; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_46; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_45; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_44; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_43; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_42; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_41; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_40; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_39; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_38; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_37; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_36; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_35; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_34; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_33; // For INTRPT_RISE_EN1
      rand uvm_reg_field intrpt_rise_en_32; // For INTRPT_RISE_EN1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_rise_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_rise_en_55 = uvm_reg_field::type_id::create("intrpt_rise_en_55");
         intrpt_rise_en_54 = uvm_reg_field::type_id::create("intrpt_rise_en_54");
         intrpt_rise_en_53 = uvm_reg_field::type_id::create("intrpt_rise_en_53");
         intrpt_rise_en_52 = uvm_reg_field::type_id::create("intrpt_rise_en_52");
         intrpt_rise_en_51 = uvm_reg_field::type_id::create("intrpt_rise_en_51");
         intrpt_rise_en_50 = uvm_reg_field::type_id::create("intrpt_rise_en_50");
         intrpt_rise_en_49 = uvm_reg_field::type_id::create("intrpt_rise_en_49");
         intrpt_rise_en_48 = uvm_reg_field::type_id::create("intrpt_rise_en_48");
         intrpt_rise_en_47 = uvm_reg_field::type_id::create("intrpt_rise_en_47");
         intrpt_rise_en_46 = uvm_reg_field::type_id::create("intrpt_rise_en_46");
         intrpt_rise_en_45 = uvm_reg_field::type_id::create("intrpt_rise_en_45");
         intrpt_rise_en_44 = uvm_reg_field::type_id::create("intrpt_rise_en_44");
         intrpt_rise_en_43 = uvm_reg_field::type_id::create("intrpt_rise_en_43");
         intrpt_rise_en_42 = uvm_reg_field::type_id::create("intrpt_rise_en_42");
         intrpt_rise_en_41 = uvm_reg_field::type_id::create("intrpt_rise_en_41");
         intrpt_rise_en_40 = uvm_reg_field::type_id::create("intrpt_rise_en_40");
         intrpt_rise_en_39 = uvm_reg_field::type_id::create("intrpt_rise_en_39");
         intrpt_rise_en_38 = uvm_reg_field::type_id::create("intrpt_rise_en_38");
         intrpt_rise_en_37 = uvm_reg_field::type_id::create("intrpt_rise_en_37");
         intrpt_rise_en_36 = uvm_reg_field::type_id::create("intrpt_rise_en_36");
         intrpt_rise_en_35 = uvm_reg_field::type_id::create("intrpt_rise_en_35");
         intrpt_rise_en_34 = uvm_reg_field::type_id::create("intrpt_rise_en_34");
         intrpt_rise_en_33 = uvm_reg_field::type_id::create("intrpt_rise_en_33");
         intrpt_rise_en_32 = uvm_reg_field::type_id::create("intrpt_rise_en_32");

         intrpt_rise_en_55.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_54.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_53.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_52.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_51.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_50.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_49.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_48.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_47.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_46.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_45.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_44.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_43.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         intrpt_rise_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_rise_status_0
   // 
   // Asserted if there is a pending rise interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_rise_status_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_rise_status_0)

      uvm_reg_field intrpt_rise_status_31; 
      uvm_reg_field intrpt_rise_status_30; 
      uvm_reg_field intrpt_rise_status_29; 
      uvm_reg_field intrpt_rise_status_28; 
      uvm_reg_field intrpt_rise_status_27; 
      uvm_reg_field intrpt_rise_status_26; 
      uvm_reg_field intrpt_rise_status_25; 
      uvm_reg_field intrpt_rise_status_24; 
      uvm_reg_field intrpt_rise_status_23; 
      uvm_reg_field intrpt_rise_status_22; 
      uvm_reg_field intrpt_rise_status_21; 
      uvm_reg_field intrpt_rise_status_20; 
      uvm_reg_field intrpt_rise_status_19; 
      uvm_reg_field intrpt_rise_status_18; 
      uvm_reg_field intrpt_rise_status_17; 
      uvm_reg_field intrpt_rise_status_16; 
      uvm_reg_field intrpt_rise_status_15; 
      uvm_reg_field intrpt_rise_status_14; 
      uvm_reg_field intrpt_rise_status_13; 
      uvm_reg_field intrpt_rise_status_12; 
      uvm_reg_field intrpt_rise_status_11; 
      uvm_reg_field intrpt_rise_status_10; 
      uvm_reg_field intrpt_rise_status_9; 
      uvm_reg_field intrpt_rise_status_8; 
      uvm_reg_field intrpt_rise_status_7; 
      uvm_reg_field intrpt_rise_status_6; 
      uvm_reg_field intrpt_rise_status_5; 
      uvm_reg_field intrpt_rise_status_4; 
      uvm_reg_field intrpt_rise_status_3; 
      uvm_reg_field intrpt_rise_status_2; 
      uvm_reg_field intrpt_rise_status_1; 
      uvm_reg_field intrpt_rise_status_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_rise_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_rise_status_31 = uvm_reg_field::type_id::create("intrpt_rise_status_31");
         intrpt_rise_status_30 = uvm_reg_field::type_id::create("intrpt_rise_status_30");
         intrpt_rise_status_29 = uvm_reg_field::type_id::create("intrpt_rise_status_29");
         intrpt_rise_status_28 = uvm_reg_field::type_id::create("intrpt_rise_status_28");
         intrpt_rise_status_27 = uvm_reg_field::type_id::create("intrpt_rise_status_27");
         intrpt_rise_status_26 = uvm_reg_field::type_id::create("intrpt_rise_status_26");
         intrpt_rise_status_25 = uvm_reg_field::type_id::create("intrpt_rise_status_25");
         intrpt_rise_status_24 = uvm_reg_field::type_id::create("intrpt_rise_status_24");
         intrpt_rise_status_23 = uvm_reg_field::type_id::create("intrpt_rise_status_23");
         intrpt_rise_status_22 = uvm_reg_field::type_id::create("intrpt_rise_status_22");
         intrpt_rise_status_21 = uvm_reg_field::type_id::create("intrpt_rise_status_21");
         intrpt_rise_status_20 = uvm_reg_field::type_id::create("intrpt_rise_status_20");
         intrpt_rise_status_19 = uvm_reg_field::type_id::create("intrpt_rise_status_19");
         intrpt_rise_status_18 = uvm_reg_field::type_id::create("intrpt_rise_status_18");
         intrpt_rise_status_17 = uvm_reg_field::type_id::create("intrpt_rise_status_17");
         intrpt_rise_status_16 = uvm_reg_field::type_id::create("intrpt_rise_status_16");
         intrpt_rise_status_15 = uvm_reg_field::type_id::create("intrpt_rise_status_15");
         intrpt_rise_status_14 = uvm_reg_field::type_id::create("intrpt_rise_status_14");
         intrpt_rise_status_13 = uvm_reg_field::type_id::create("intrpt_rise_status_13");
         intrpt_rise_status_12 = uvm_reg_field::type_id::create("intrpt_rise_status_12");
         intrpt_rise_status_11 = uvm_reg_field::type_id::create("intrpt_rise_status_11");
         intrpt_rise_status_10 = uvm_reg_field::type_id::create("intrpt_rise_status_10");
         intrpt_rise_status_9 = uvm_reg_field::type_id::create("intrpt_rise_status_9");
         intrpt_rise_status_8 = uvm_reg_field::type_id::create("intrpt_rise_status_8");
         intrpt_rise_status_7 = uvm_reg_field::type_id::create("intrpt_rise_status_7");
         intrpt_rise_status_6 = uvm_reg_field::type_id::create("intrpt_rise_status_6");
         intrpt_rise_status_5 = uvm_reg_field::type_id::create("intrpt_rise_status_5");
         intrpt_rise_status_4 = uvm_reg_field::type_id::create("intrpt_rise_status_4");
         intrpt_rise_status_3 = uvm_reg_field::type_id::create("intrpt_rise_status_3");
         intrpt_rise_status_2 = uvm_reg_field::type_id::create("intrpt_rise_status_2");
         intrpt_rise_status_1 = uvm_reg_field::type_id::create("intrpt_rise_status_1");
         intrpt_rise_status_0 = uvm_reg_field::type_id::create("intrpt_rise_status_0");

         intrpt_rise_status_31.configure(this, 1, 31, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_30.configure(this, 1, 30, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_29.configure(this, 1, 29, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_28.configure(this, 1, 28, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_27.configure(this, 1, 27, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_26.configure(this, 1, 26, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_25.configure(this, 1, 25, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_24.configure(this, 1, 24, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_23.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_22.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_21.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_20.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_19.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_18.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_17.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_16.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_15.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_14.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_13.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_12.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_11.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_10.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_9.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_8.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_7.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_6.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_5.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_4.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_3.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_2.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_1.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_0.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_rise_status_1
   // 
   // Asserted if there is a pending rise interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_rise_status_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_rise_status_1)

      uvm_reg_field intrpt_rise_status_55; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_54; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_53; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_52; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_51; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_50; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_49; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_48; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_47; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_46; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_45; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_44; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_43; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_42; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_41; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_40; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_39; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_38; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_37; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_36; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_35; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_34; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_33; // For INTRPT_RISE_STATUS1
      uvm_reg_field intrpt_rise_status_32; // For INTRPT_RISE_STATUS1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_rise_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_rise_status_55 = uvm_reg_field::type_id::create("intrpt_rise_status_55");
         intrpt_rise_status_54 = uvm_reg_field::type_id::create("intrpt_rise_status_54");
         intrpt_rise_status_53 = uvm_reg_field::type_id::create("intrpt_rise_status_53");
         intrpt_rise_status_52 = uvm_reg_field::type_id::create("intrpt_rise_status_52");
         intrpt_rise_status_51 = uvm_reg_field::type_id::create("intrpt_rise_status_51");
         intrpt_rise_status_50 = uvm_reg_field::type_id::create("intrpt_rise_status_50");
         intrpt_rise_status_49 = uvm_reg_field::type_id::create("intrpt_rise_status_49");
         intrpt_rise_status_48 = uvm_reg_field::type_id::create("intrpt_rise_status_48");
         intrpt_rise_status_47 = uvm_reg_field::type_id::create("intrpt_rise_status_47");
         intrpt_rise_status_46 = uvm_reg_field::type_id::create("intrpt_rise_status_46");
         intrpt_rise_status_45 = uvm_reg_field::type_id::create("intrpt_rise_status_45");
         intrpt_rise_status_44 = uvm_reg_field::type_id::create("intrpt_rise_status_44");
         intrpt_rise_status_43 = uvm_reg_field::type_id::create("intrpt_rise_status_43");
         intrpt_rise_status_42 = uvm_reg_field::type_id::create("intrpt_rise_status_42");
         intrpt_rise_status_41 = uvm_reg_field::type_id::create("intrpt_rise_status_41");
         intrpt_rise_status_40 = uvm_reg_field::type_id::create("intrpt_rise_status_40");
         intrpt_rise_status_39 = uvm_reg_field::type_id::create("intrpt_rise_status_39");
         intrpt_rise_status_38 = uvm_reg_field::type_id::create("intrpt_rise_status_38");
         intrpt_rise_status_37 = uvm_reg_field::type_id::create("intrpt_rise_status_37");
         intrpt_rise_status_36 = uvm_reg_field::type_id::create("intrpt_rise_status_36");
         intrpt_rise_status_35 = uvm_reg_field::type_id::create("intrpt_rise_status_35");
         intrpt_rise_status_34 = uvm_reg_field::type_id::create("intrpt_rise_status_34");
         intrpt_rise_status_33 = uvm_reg_field::type_id::create("intrpt_rise_status_33");
         intrpt_rise_status_32 = uvm_reg_field::type_id::create("intrpt_rise_status_32");

         intrpt_rise_status_55.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_54.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_53.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_52.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_51.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_50.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_49.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_48.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_47.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_46.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_45.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_44.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_43.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_42.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_41.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_40.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_39.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_38.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_37.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_36.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_35.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_34.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_33.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_rise_status_32.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_status_0
   // 
   // Asserted if there is any pending interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears all pending interrupts (rise, fall, low, high) of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_status_0 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_status_0)

      uvm_reg_field intrpt_status_31; 
      uvm_reg_field intrpt_status_30; 
      uvm_reg_field intrpt_status_29; 
      uvm_reg_field intrpt_status_28; 
      uvm_reg_field intrpt_status_27; 
      uvm_reg_field intrpt_status_26; 
      uvm_reg_field intrpt_status_25; 
      uvm_reg_field intrpt_status_24; 
      uvm_reg_field intrpt_status_23; 
      uvm_reg_field intrpt_status_22; 
      uvm_reg_field intrpt_status_21; 
      uvm_reg_field intrpt_status_20; 
      uvm_reg_field intrpt_status_19; 
      uvm_reg_field intrpt_status_18; 
      uvm_reg_field intrpt_status_17; 
      uvm_reg_field intrpt_status_16; 
      uvm_reg_field intrpt_status_15; 
      uvm_reg_field intrpt_status_14; 
      uvm_reg_field intrpt_status_13; 
      uvm_reg_field intrpt_status_12; 
      uvm_reg_field intrpt_status_11; 
      uvm_reg_field intrpt_status_10; 
      uvm_reg_field intrpt_status_9; 
      uvm_reg_field intrpt_status_8; 
      uvm_reg_field intrpt_status_7; 
      uvm_reg_field intrpt_status_6; 
      uvm_reg_field intrpt_status_5; 
      uvm_reg_field intrpt_status_4; 
      uvm_reg_field intrpt_status_3; 
      uvm_reg_field intrpt_status_2; 
      uvm_reg_field intrpt_status_1; 
      uvm_reg_field intrpt_status_0; 


      // Function: new
      // 
      function new(string name = "gpio_intrpt_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_status_31 = uvm_reg_field::type_id::create("intrpt_status_31");
         intrpt_status_30 = uvm_reg_field::type_id::create("intrpt_status_30");
         intrpt_status_29 = uvm_reg_field::type_id::create("intrpt_status_29");
         intrpt_status_28 = uvm_reg_field::type_id::create("intrpt_status_28");
         intrpt_status_27 = uvm_reg_field::type_id::create("intrpt_status_27");
         intrpt_status_26 = uvm_reg_field::type_id::create("intrpt_status_26");
         intrpt_status_25 = uvm_reg_field::type_id::create("intrpt_status_25");
         intrpt_status_24 = uvm_reg_field::type_id::create("intrpt_status_24");
         intrpt_status_23 = uvm_reg_field::type_id::create("intrpt_status_23");
         intrpt_status_22 = uvm_reg_field::type_id::create("intrpt_status_22");
         intrpt_status_21 = uvm_reg_field::type_id::create("intrpt_status_21");
         intrpt_status_20 = uvm_reg_field::type_id::create("intrpt_status_20");
         intrpt_status_19 = uvm_reg_field::type_id::create("intrpt_status_19");
         intrpt_status_18 = uvm_reg_field::type_id::create("intrpt_status_18");
         intrpt_status_17 = uvm_reg_field::type_id::create("intrpt_status_17");
         intrpt_status_16 = uvm_reg_field::type_id::create("intrpt_status_16");
         intrpt_status_15 = uvm_reg_field::type_id::create("intrpt_status_15");
         intrpt_status_14 = uvm_reg_field::type_id::create("intrpt_status_14");
         intrpt_status_13 = uvm_reg_field::type_id::create("intrpt_status_13");
         intrpt_status_12 = uvm_reg_field::type_id::create("intrpt_status_12");
         intrpt_status_11 = uvm_reg_field::type_id::create("intrpt_status_11");
         intrpt_status_10 = uvm_reg_field::type_id::create("intrpt_status_10");
         intrpt_status_9 = uvm_reg_field::type_id::create("intrpt_status_9");
         intrpt_status_8 = uvm_reg_field::type_id::create("intrpt_status_8");
         intrpt_status_7 = uvm_reg_field::type_id::create("intrpt_status_7");
         intrpt_status_6 = uvm_reg_field::type_id::create("intrpt_status_6");
         intrpt_status_5 = uvm_reg_field::type_id::create("intrpt_status_5");
         intrpt_status_4 = uvm_reg_field::type_id::create("intrpt_status_4");
         intrpt_status_3 = uvm_reg_field::type_id::create("intrpt_status_3");
         intrpt_status_2 = uvm_reg_field::type_id::create("intrpt_status_2");
         intrpt_status_1 = uvm_reg_field::type_id::create("intrpt_status_1");
         intrpt_status_0 = uvm_reg_field::type_id::create("intrpt_status_0");

         intrpt_status_31.configure(this, 1, 31, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_30.configure(this, 1, 30, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_29.configure(this, 1, 29, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_28.configure(this, 1, 28, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_27.configure(this, 1, 27, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_26.configure(this, 1, 26, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_25.configure(this, 1, 25, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_24.configure(this, 1, 24, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_23.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_22.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_21.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_20.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_19.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_18.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_17.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_16.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_15.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_14.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_13.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_12.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_11.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_10.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_9.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_8.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_7.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_6.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_5.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_4.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_3.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_2.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_1.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_0.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_intrpt_status_1
   // 
   // Asserted if there is any pending interrupts on corresponding GPIOs.
   // Writing 1 to a specific bit clears all pending interrupts (rise, fall, low, high) of the corresponding GPIO.
   //--------------------------------------------------------------------

   class gpio_intrpt_status_1 extends uvm_reg;
      `uvm_object_utils(gpio_intrpt_status_1)

      uvm_reg_field intrpt_status_55; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_54; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_53; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_52; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_51; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_50; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_49; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_48; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_47; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_46; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_45; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_44; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_43; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_42; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_41; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_40; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_39; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_38; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_37; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_36; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_35; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_34; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_33; // For INTRPT_STATUS1
      uvm_reg_field intrpt_status_32; // For INTRPT_STATUS1


      // Function: new
      // 
      function new(string name = "gpio_intrpt_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         intrpt_status_55 = uvm_reg_field::type_id::create("intrpt_status_55");
         intrpt_status_54 = uvm_reg_field::type_id::create("intrpt_status_54");
         intrpt_status_53 = uvm_reg_field::type_id::create("intrpt_status_53");
         intrpt_status_52 = uvm_reg_field::type_id::create("intrpt_status_52");
         intrpt_status_51 = uvm_reg_field::type_id::create("intrpt_status_51");
         intrpt_status_50 = uvm_reg_field::type_id::create("intrpt_status_50");
         intrpt_status_49 = uvm_reg_field::type_id::create("intrpt_status_49");
         intrpt_status_48 = uvm_reg_field::type_id::create("intrpt_status_48");
         intrpt_status_47 = uvm_reg_field::type_id::create("intrpt_status_47");
         intrpt_status_46 = uvm_reg_field::type_id::create("intrpt_status_46");
         intrpt_status_45 = uvm_reg_field::type_id::create("intrpt_status_45");
         intrpt_status_44 = uvm_reg_field::type_id::create("intrpt_status_44");
         intrpt_status_43 = uvm_reg_field::type_id::create("intrpt_status_43");
         intrpt_status_42 = uvm_reg_field::type_id::create("intrpt_status_42");
         intrpt_status_41 = uvm_reg_field::type_id::create("intrpt_status_41");
         intrpt_status_40 = uvm_reg_field::type_id::create("intrpt_status_40");
         intrpt_status_39 = uvm_reg_field::type_id::create("intrpt_status_39");
         intrpt_status_38 = uvm_reg_field::type_id::create("intrpt_status_38");
         intrpt_status_37 = uvm_reg_field::type_id::create("intrpt_status_37");
         intrpt_status_36 = uvm_reg_field::type_id::create("intrpt_status_36");
         intrpt_status_35 = uvm_reg_field::type_id::create("intrpt_status_35");
         intrpt_status_34 = uvm_reg_field::type_id::create("intrpt_status_34");
         intrpt_status_33 = uvm_reg_field::type_id::create("intrpt_status_33");
         intrpt_status_32 = uvm_reg_field::type_id::create("intrpt_status_32");

         intrpt_status_55.configure(this, 1, 23, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_54.configure(this, 1, 22, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_53.configure(this, 1, 21, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_52.configure(this, 1, 20, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_51.configure(this, 1, 19, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_50.configure(this, 1, 18, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_49.configure(this, 1, 17, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_48.configure(this, 1, 16, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_47.configure(this, 1, 15, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_46.configure(this, 1, 14, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_45.configure(this, 1, 13, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_44.configure(this, 1, 12, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_43.configure(this, 1, 11, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_42.configure(this, 1, 10, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_41.configure(this, 1, 9, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_40.configure(this, 1, 8, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_39.configure(this, 1, 7, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_38.configure(this, 1, 6, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_37.configure(this, 1, 5, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_36.configure(this, 1, 4, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_35.configure(this, 1, 3, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_34.configure(this, 1, 2, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_33.configure(this, 1, 1, "W1C", 0, 1'b0, 1, 0, 0);
         intrpt_status_32.configure(this, 1, 0, "W1C", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_config_asf_cfg
   // 
   // Active-safety feature configuration
   //--------------------------------------------------------------------

   class i3c_config_asf_cfg extends uvm_reg;
      `uvm_object_utils(i3c_config_asf_cfg)

      rand uvm_reg_field asf_passthrough_en; // Tie-off control bit, when set to: 1’b1 – the parity is
                                             // sourced from the external parity port 1’b0 – the parity is
                                             // sourced from an internal parity generator placed right
                                             // after top level I/O boundary


      // Function: new
      // 
      function new(string name = "i3c_config_asf_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         asf_passthrough_en = uvm_reg_field::type_id::create("asf_passthrough_en");

         asf_passthrough_en.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_config_cfg1
   // 
   // Configure static device configuration. Any change to this register (except for RSTCYCLES) requires reseting the I3C peripheral
   //--------------------------------------------------------------------

   class i3c_config_cfg1 extends uvm_reg;
      `uvm_object_utils(i3c_config_cfg1)

      rand uvm_reg_field pid_inst_id; // This input represents Provisional ID bits [15:12]. It is
                                    // used for identifying individual devices.
                                    // This port should be stable after de-assertion
                                    // of local reset thus can be considered as
                                    // quasi static during the IP operation.
                                    // The actual value of device PID will be
                                    // updated after the first sys_clk clock cycle
                                    // after reset de-assertion.
      rand uvm_reg_field pid_mfr; // This input represents Provisional ID bits [47:33]. It is
                                 // used for manufacturer identification code assigned by MIPI
                                 // Alliance to chip vendors.
                                 // This port should be stable after de-assertion
                                 // of local reset thus can be considered as
                                 // quasi static during the IP operation.
                                 // The actual value of device PID will be
                                 // updated after the first sys_clk clock cycle
                                 // after reset de-assertion.
      rand uvm_reg_field device_role; // Change the device mode (master or slave) of the I3C peripheral. After the device
                                    // mode has been changed, the I3C peripheral needs to be reset!
      rand uvm_reg_field rstcycles; // Configures for how many peripheral clock cycles the reset signals shall remain asserted
                                    // when using local or global reset on the system.


      // Function: new
      // 
      function new(string name = "i3c_config_cfg1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pid_inst_id = uvm_reg_field::type_id::create("pid_inst_id");
         pid_mfr = uvm_reg_field::type_id::create("pid_mfr");
         device_role = uvm_reg_field::type_id::create("device_role");
         rstcycles = uvm_reg_field::type_id::create("rstcycles");

         pid_inst_id.configure(this, 4, 24, "RW", 0, 4'h0, 1, 1, 0);
         pid_mfr.configure(this, 15, 9, "RW", 0, 15'b000000111001001, 1, 1, 0);
         device_role.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         rstcycles.configure(this, 8, 0, "RW", 0, 8'h14, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_config_cfg2
   // 
   // Configure static device configuration. Any change to this register (except for RSTCYCLES) requires reseting the I3C peripheral
   //--------------------------------------------------------------------

   class i3c_config_cfg2 extends uvm_reg;
      `uvm_object_utils(i3c_config_cfg2)

      rand uvm_reg_field bus_idle_timer; // Input that correlates the per_clk frequency
                                       // with the timing requirement of Bus Idle
                                       // Condition.
                                       // Thus it sets the number of per_clk cycles when both the SCL Line and the SDA Line are
                                       // released High, needed to indicate that the Bus Idle Condition is met. The correct value of this port is
                                       // defined by the following equation:
                                       // bus_idle_timer[17: 0] = per_clk_freq ∗ 1001.0μs
                                       // This port should be stable after de-assertion
                                       // of n_sys_reset_l thus can be considered as
                                       // quasi static during the IP operation.
      rand uvm_reg_field bus_avail_timer; // Input that correlates the per_clk frequency with the
                                          // timing requirement of Bus Available Condition.
                                          // Thus it sets the number of sys_clk cycles when both the
                                          // SCL Line and the SDA Line are released High, needed to
                                          // indicate that the Bus Available Condition is met. The
                                          // correct value of this port is defined by the following
                                          // equation: bus_avail_timer[7: 0] = per_clk_freq ∗ 1.0μs
                                          // This port should be stable after de-assertion of
                                          // n_sys_reset_l thus can be considered as quasi during the
                                          // IP operation.


      // Function: new
      // 
      function new(string name = "i3c_config_cfg2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         bus_idle_timer = uvm_reg_field::type_id::create("bus_idle_timer");
         bus_avail_timer = uvm_reg_field::type_id::create("bus_avail_timer");

         bus_idle_timer.configure(this, 18, 8, "RW", 0, 18'b000000000000100100, 1, 1, 0);
         bus_avail_timer.configure(this, 8, 0, "RW", 0, 8'h04, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_config_swrst
   // 
   // Perform software reset of the whole IP
   //--------------------------------------------------------------------

   class i3c_config_swrst extends uvm_reg;
      `uvm_object_utils(i3c_config_swrst)

      rand uvm_reg_field locrst; // LOCK calibration output code
                                 // Can be read out synchronously with rising edge of FREF
                                 // This is the final value used by the SAR algorithm to set the initial VCO
                                 // frequency.
                                 // It can be stored for future use with FCALBYP to speed up subsequent
                                 // lock times.
      rand uvm_reg_field globrst; // Global reset signal. Writing a logic one asserts the global reset for RSTCYCLES number of
                                 // peripheral clock cycles. The bit is auto cleared.


      // Function: new
      // 
      function new(string name = "i3c_config_swrst");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         locrst = uvm_reg_field::type_id::create("locrst");
         globrst = uvm_reg_field::type_id::create("globrst");

         locrst.configure(this, 1, 1, "WO", 0, 1'b1, 1, 1, 0);
         globrst.configure(this, 1, 0, "WO", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_ctrl
   // 
   // Main Control Register
   //--------------------------------------------------------------------

   class i3c_ctrl extends uvm_reg;
      `uvm_object_utils(i3c_ctrl)

      rand uvm_reg_field dev_en; // Enables IP
      rand uvm_reg_field halt_en; // Enables halt on abort function
      rand uvm_reg_field mcs; // Writing 1 start exection of cmd fifo
      rand uvm_reg_field mcs_en; // If set to ‘1’ the IP will wait with starting of
                                 // command execution until mcs bit would be set to
                                 // ‘1’.
                                 // If set to ‘0’, the IP will start to execute commands
                                 // automatically if at least one is present in the CMD
                                 // FIFOs and the mcs bit is disregarded.
      rand uvm_reg_field i3c_11_supp; 
      rand uvm_reg_field thd_del; 
      rand uvm_reg_field hj_disec; 
      rand uvm_reg_field mst_ack; 
      rand uvm_reg_field hj_ack; 
      rand uvm_reg_field hj_init; 
      rand uvm_reg_field mst_init; 
      rand uvm_reg_field ahdr_opt; 
      rand uvm_reg_field bus_mode; 


      // Function: new
      // 
      function new(string name = "i3c_ctrl");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         dev_en = uvm_reg_field::type_id::create("dev_en");
         halt_en = uvm_reg_field::type_id::create("halt_en");
         mcs = uvm_reg_field::type_id::create("mcs");
         mcs_en = uvm_reg_field::type_id::create("mcs_en");
         i3c_11_supp = uvm_reg_field::type_id::create("i3c_11_supp");
         thd_del = uvm_reg_field::type_id::create("thd_del");
         hj_disec = uvm_reg_field::type_id::create("hj_disec");
         mst_ack = uvm_reg_field::type_id::create("mst_ack");
         hj_ack = uvm_reg_field::type_id::create("hj_ack");
         hj_init = uvm_reg_field::type_id::create("hj_init");
         mst_init = uvm_reg_field::type_id::create("mst_init");
         ahdr_opt = uvm_reg_field::type_id::create("ahdr_opt");
         bus_mode = uvm_reg_field::type_id::create("bus_mode");

         dev_en.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         halt_en.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         mcs.configure(this, 1, 29, "WO", 0, 1'b0, 1, 1, 0);
         mcs_en.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         i3c_11_supp.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         thd_del.configure(this, 2, 24, "RW", 0, 2'b00, 1, 1, 0);
         hj_disec.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         mst_ack.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         hj_ack.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         hj_init.configure(this, 1, 5, "WO", 0, 1'b0, 1, 1, 0);
         mst_init.configure(this, 1, 4, "WO", 0, 1'b0, 1, 1, 0);
         ahdr_opt.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         bus_mode.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_dev_id
   // 
   // ID Register for Cadence IP
   //--------------------------------------------------------------------

   class i3c_dev_id extends uvm_reg;
      `uvm_object_utils(i3c_dev_id)

      uvm_reg_field reserved; 
      uvm_reg_field dev_id; // Device ID


      // Function: new
      // 
      function new(string name = "i3c_dev_id");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         dev_id = uvm_reg_field::type_id::create("dev_id");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         dev_id.configure(this, 16, 0, "RO", 0, 16'h5034, 1, 0, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_prescl_ctrl
   // 
   //--------------------------------------------------------------------

   class i3c_prescl_ctrl extends uvm_reg;
      `uvm_object_utils(i3c_prescl_ctrl)

      rand uvm_reg_field i2c; 
      uvm_reg_field reserved; 
      rand uvm_reg_field i3c; 


      // Function: new
      // 
      function new(string name = "i3c_prescl_ctrl");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         i2c = uvm_reg_field::type_id::create("i2c");
         reserved = uvm_reg_field::type_id::create("reserved");
         i3c = uvm_reg_field::type_id::create("i3c");

         i2c.configure(this, 16, 16, "RW", 0, 16'h007c, 1, 1, 1);
         reserved.configure(this, 6, 10, "RO", 0, 6'b000000, 1, 0, 0);
         i3c.configure(this, 10, 0, "RW", 0, 10'b0000000100, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_sir_map_5
   // 
   //--------------------------------------------------------------------

   class i3c_sir_map_5 extends uvm_reg;
      `uvm_object_utils(i3c_sir_map_5)

      uvm_reg_field reserved; 
      rand uvm_reg_field devid_10_role; 
      rand uvm_reg_field devid_10_slow; 
      rand uvm_reg_field devid_10_pl; 
      rand uvm_reg_field devid_10_da; 
      rand uvm_reg_field devid_10_resp; 


      // Function: new
      // 
      function new(string name = "i3c_sir_map_5");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         devid_10_role = uvm_reg_field::type_id::create("devid_10_role");
         devid_10_slow = uvm_reg_field::type_id::create("devid_10_slow");
         devid_10_pl = uvm_reg_field::type_id::create("devid_10_pl");
         devid_10_da = uvm_reg_field::type_id::create("devid_10_da");
         devid_10_resp = uvm_reg_field::type_id::create("devid_10_resp");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         devid_10_role.configure(this, 2, 14, "RW", 0, 2'b00, 1, 1, 0);
         devid_10_slow.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         devid_10_pl.configure(this, 5, 8, "RW", 0, 5'b00000, 1, 1, 0);
         devid_10_da.configure(this, 7, 1, "RW", 0, 7'b1111111, 1, 1, 0);
         devid_10_resp.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: l1_memory
   // 
   // L1 Memory (modeled as single memory since UVM RAL does not really support interleaved address mapping)
   //--------------------------------------------------------------------

   class l1_memory extends uvm_mem;
      `uvm_object_utils(l1_memory)



      // Function: new
      // 
      function new(string name = "l1_memory");
         super.new(name, 'h10000, 32, "RW", UVM_NO_COVERAGE);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: l2_memory
   // 
   // L2 Memory (modeled as single memory since UVM RAL does not really support interleaved address mapping)
   //--------------------------------------------------------------------

   class l2_memory extends uvm_mem;
      `uvm_object_utils(l2_memory)



      // Function: new
      // 
      function new(string name = "l2_memory");
         super.new(name, 'h80000, 32, "RW", UVM_NO_COVERAGE);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pll_config_cfg1
   // 
   // Configure general PLL settings
   //--------------------------------------------------------------------

   class pll_config_cfg1 extends uvm_reg;
      `uvm_object_utils(pll_config_cfg1)

      rand uvm_reg_field lockgate; // Enable clock gate on output clock with LOCK signal.
                                 // 1'b0 -> The output clock gate is enabled regardless the value of LOCK.
                                 // 1'b1 -> Output clock is gated with LOCK signal to filter unstable output clock.
      rand uvm_reg_field lockcount; // Number of PFD cycles to count without a cycle slip before LOCK goes
                                    // high
                                    // 2'b00 -> 8
                                    // 2'b01 -> 16 (default)
                                    // 2'b10 -> 32
                                    // 2'b11 -> 64
      rand uvm_reg_field foutvcoen; // VCO rate output clock enable
                                    // 1’b0 –> FOUTVCO=0
                                    // 1’b1 –> FOUTVCO is enabled
                                    // This port is not in Siracusa so it should remain powered off by default.
      rand uvm_reg_field foutpostdiven; // Post divided output enable
                                       // 1’b0 –> FOUTPOSTDIV=0
                                       // 1’b1 –> FOUTPOSTDIV is enabled
                                       // The PLL contains circuitry to ensure that FOUTPOSTDIV is glitch-free
                                       // when FOUTPOSTDIVEN is toggled. Turning this PLL port of disables the
                                       // output clock of the PLL used in the system!
      rand uvm_reg_field pllen; // Global enable signal for the PLL
                              // 1’b0 –> PLL is in low-leakage power down mode. All digital logic is reset.
                              // 1’b1 –> PLL is enabled
                              // Minimum low pulse width is 4ns in order to properly reset the PLL.


      // Function: new
      // 
      function new(string name = "pll_config_cfg1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         lockgate = uvm_reg_field::type_id::create("lockgate");
         lockcount = uvm_reg_field::type_id::create("lockcount");
         foutvcoen = uvm_reg_field::type_id::create("foutvcoen");
         foutpostdiven = uvm_reg_field::type_id::create("foutpostdiven");
         pllen = uvm_reg_field::type_id::create("pllen");

         lockgate.configure(this, 1, 6, "RW", 0, 1'b1, 1, 1, 0);
         lockcount.configure(this, 2, 4, "RW", 0, 2'b01, 1, 1, 0);
         foutvcoen.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         foutpostdiven.configure(this, 1, 1, "RW", 0, 1'b1, 1, 1, 0);
         pllen.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pll_config_cfg2
   // 
   // Configure the target frequency of the PLL. After reset, the PLL starts up at 50 MHz.
   //--------------------------------------------------------------------

   class pll_config_cfg2 extends uvm_reg;
      `uvm_object_utils(pll_config_cfg2)

      rand uvm_reg_field freq_change_mask_cnt; // Enable a masking of the PLL clock for FREQ_CHANGE_CNT number of reference clock cycles after any changes to the CFG2 register to
                                             // prevent cycle glitches arriving to logic.
      rand uvm_reg_field failsafe_en; // Enable a failsafe mode where the clock enable signal is asserted after at most 256 reference
                                    // clock cycles, regardless whether the PLL asserts the LOCK signal. This mode should be used in
                                    // the bootrom to prevent us locking us out of the system due to a PLL that never locks during booting.
      rand uvm_reg_field vcodivsel; // Fixed VCO divider
                                    // 1’b0 –> Divide-by-1
                                    // 1’b1 –> Divide-by-2
      rand uvm_reg_field postdiv; // Post divider value (1 to 16)
                                 // Actual divide value is POSTDIV+1 (e.g if POSTDIV=0, divide = 1)
      rand uvm_reg_field fbdiv; // PLL Feedback divide value (256 to 13333)
                              // Actual maximum is 16383, but this value is outside of
                              // the useful functional range of the VCO and PFD


      // Function: new
      // 
      function new(string name = "pll_config_cfg2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         freq_change_mask_cnt = uvm_reg_field::type_id::create("freq_change_mask_cnt");
         failsafe_en = uvm_reg_field::type_id::create("failsafe_en");
         vcodivsel = uvm_reg_field::type_id::create("vcodivsel");
         postdiv = uvm_reg_field::type_id::create("postdiv");
         fbdiv = uvm_reg_field::type_id::create("fbdiv");

         freq_change_mask_cnt.configure(this, 8, 20, "RW", 0, 8'h20, 1, 1, 0);
         failsafe_en.configure(this, 1, 19, "RW", 0, 1'b1, 1, 1, 0);
         vcodivsel.configure(this, 1, 18, "RW", 0, 1'b1, 1, 1, 0);
         postdiv.configure(this, 4, 14, "RW", 0, 4'h0, 1, 1, 0);
         fbdiv.configure(this, 14, 0, "RW", 0, 14'b00101111101011, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pll_config_cfg3
   // 
   // Configure calibration settings of the PLL.
   //--------------------------------------------------------------------

   class pll_config_cfg3 extends uvm_reg;
      `uvm_object_utils(pll_config_cfg3)

      rand uvm_reg_field fcalbyp; // Frequency calibration bypass
                                 // 1'b0 -> Use internal SAR frequency calibration method
                                 // 1'b1 -> FCALIN is used to set the startup current DAC for three FREF
                                 // periods after PLLEN goes high, or indefinitely if FCALTEST=1'b1.
      rand uvm_reg_field fcaltest; // LOCK calibration input code
                                 // 8’d0 –> minimum frequency at startup
                                 // 8’d255 –> maximum frequency at startup
                                 // If FCALBYP=1 then this value is used to set the startup current DAC for
                                 // three FREF periods
                                 // after PLLEN goes high, or indefinitely if FCALTEST=1’b1
      rand uvm_reg_field fcalin; // LOCK calibration input code
                                 // 8’d0 –> minimum frequency at startup
                                 // 8’d255 –> maximum frequency at startup
                                 // If FCA LBYP=1 then this value is used to set the startup current DAC for
                                 // three FREF periods after PLLEN goes high, or indefinitely if FCALTEST=1’b1


      // Function: new
      // 
      function new(string name = "pll_config_cfg3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         fcalbyp = uvm_reg_field::type_id::create("fcalbyp");
         fcaltest = uvm_reg_field::type_id::create("fcaltest");
         fcalin = uvm_reg_field::type_id::create("fcalin");

         fcalbyp.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         fcaltest.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         fcalin.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pll_config_status
   // 
   // Status register of the PLL
   //--------------------------------------------------------------------

   class pll_config_status extends uvm_reg;
      `uvm_object_utils(pll_config_status)

      uvm_reg_field fcalout; // LOCK calibration output code
                           // Can be read out synchronously with rising edge of FREF
                           // This is the final value used by the SAR algorithm to set the initial VCO
                           // frequency.
                           // It can be stored for future use with FCALBYP to speed up subsequent
                           // lock times.
      uvm_reg_field lock; // Lock signal Indicates no cycle slips between the feedback clock and FPFD for
                        // LOCKCOUNT consecutive cycles.


      // Function: new
      // 
      function new(string name = "pll_config_status");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         fcalout = uvm_reg_field::type_id::create("fcalout");
         lock = uvm_reg_field::type_id::create("lock");

         fcalout.configure(this, 8, 16, "RO", 0, 8'h00, 1, 0, 1);
         lock.configure(this, 1, 0, "RO", 0, 1'b0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: private_bank_soc
   // 
   // Private Memory Bank used in SoC domain
   //--------------------------------------------------------------------

   class private_bank_soc extends uvm_mem;
      `uvm_object_utils(private_bank_soc)



      // Function: new
      // 
      function new(string name = "private_bank_soc");
         super.new(name, 'h2000, 32, "RW", UVM_NO_COVERAGE);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_ctrl_pad_dbg_mode_en_0
   // 
   // Enable the corresponding GPIO pads debug functionality.
   //--------------------------------------------------------------------

   class siracusa_ctrl_pad_dbg_mode_en_0 extends uvm_reg;
      `uvm_object_utils(siracusa_ctrl_pad_dbg_mode_en_0)

      rand uvm_reg_field pad_dbg_mode_en_31; 
      rand uvm_reg_field pad_dbg_mode_en_30; 
      rand uvm_reg_field pad_dbg_mode_en_29; 
      rand uvm_reg_field pad_dbg_mode_en_28; 
      rand uvm_reg_field pad_dbg_mode_en_27; 
      rand uvm_reg_field pad_dbg_mode_en_26; 
      rand uvm_reg_field pad_dbg_mode_en_25; 
      rand uvm_reg_field pad_dbg_mode_en_24; 
      rand uvm_reg_field pad_dbg_mode_en_23; 
      rand uvm_reg_field pad_dbg_mode_en_22; 
      rand uvm_reg_field pad_dbg_mode_en_21; 
      rand uvm_reg_field pad_dbg_mode_en_20; 
      rand uvm_reg_field pad_dbg_mode_en_19; 
      rand uvm_reg_field pad_dbg_mode_en_18; 
      rand uvm_reg_field pad_dbg_mode_en_17; 
      rand uvm_reg_field pad_dbg_mode_en_16; 
      rand uvm_reg_field pad_dbg_mode_en_15; 
      rand uvm_reg_field pad_dbg_mode_en_14; 
      rand uvm_reg_field pad_dbg_mode_en_13; 
      rand uvm_reg_field pad_dbg_mode_en_12; 
      rand uvm_reg_field pad_dbg_mode_en_11; 
      rand uvm_reg_field pad_dbg_mode_en_10; 
      rand uvm_reg_field pad_dbg_mode_en_9; 
      rand uvm_reg_field pad_dbg_mode_en_8; 
      rand uvm_reg_field pad_dbg_mode_en_7; 
      rand uvm_reg_field pad_dbg_mode_en_6; 
      rand uvm_reg_field pad_dbg_mode_en_5; 
      rand uvm_reg_field pad_dbg_mode_en_4; 
      rand uvm_reg_field pad_dbg_mode_en_3; 
      rand uvm_reg_field pad_dbg_mode_en_2; 
      rand uvm_reg_field pad_dbg_mode_en_1; 
      rand uvm_reg_field pad_dbg_mode_en_0; 


      // Function: new
      // 
      function new(string name = "siracusa_ctrl_pad_dbg_mode_en_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_dbg_mode_en_31 = uvm_reg_field::type_id::create("pad_dbg_mode_en_31");
         pad_dbg_mode_en_30 = uvm_reg_field::type_id::create("pad_dbg_mode_en_30");
         pad_dbg_mode_en_29 = uvm_reg_field::type_id::create("pad_dbg_mode_en_29");
         pad_dbg_mode_en_28 = uvm_reg_field::type_id::create("pad_dbg_mode_en_28");
         pad_dbg_mode_en_27 = uvm_reg_field::type_id::create("pad_dbg_mode_en_27");
         pad_dbg_mode_en_26 = uvm_reg_field::type_id::create("pad_dbg_mode_en_26");
         pad_dbg_mode_en_25 = uvm_reg_field::type_id::create("pad_dbg_mode_en_25");
         pad_dbg_mode_en_24 = uvm_reg_field::type_id::create("pad_dbg_mode_en_24");
         pad_dbg_mode_en_23 = uvm_reg_field::type_id::create("pad_dbg_mode_en_23");
         pad_dbg_mode_en_22 = uvm_reg_field::type_id::create("pad_dbg_mode_en_22");
         pad_dbg_mode_en_21 = uvm_reg_field::type_id::create("pad_dbg_mode_en_21");
         pad_dbg_mode_en_20 = uvm_reg_field::type_id::create("pad_dbg_mode_en_20");
         pad_dbg_mode_en_19 = uvm_reg_field::type_id::create("pad_dbg_mode_en_19");
         pad_dbg_mode_en_18 = uvm_reg_field::type_id::create("pad_dbg_mode_en_18");
         pad_dbg_mode_en_17 = uvm_reg_field::type_id::create("pad_dbg_mode_en_17");
         pad_dbg_mode_en_16 = uvm_reg_field::type_id::create("pad_dbg_mode_en_16");
         pad_dbg_mode_en_15 = uvm_reg_field::type_id::create("pad_dbg_mode_en_15");
         pad_dbg_mode_en_14 = uvm_reg_field::type_id::create("pad_dbg_mode_en_14");
         pad_dbg_mode_en_13 = uvm_reg_field::type_id::create("pad_dbg_mode_en_13");
         pad_dbg_mode_en_12 = uvm_reg_field::type_id::create("pad_dbg_mode_en_12");
         pad_dbg_mode_en_11 = uvm_reg_field::type_id::create("pad_dbg_mode_en_11");
         pad_dbg_mode_en_10 = uvm_reg_field::type_id::create("pad_dbg_mode_en_10");
         pad_dbg_mode_en_9 = uvm_reg_field::type_id::create("pad_dbg_mode_en_9");
         pad_dbg_mode_en_8 = uvm_reg_field::type_id::create("pad_dbg_mode_en_8");
         pad_dbg_mode_en_7 = uvm_reg_field::type_id::create("pad_dbg_mode_en_7");
         pad_dbg_mode_en_6 = uvm_reg_field::type_id::create("pad_dbg_mode_en_6");
         pad_dbg_mode_en_5 = uvm_reg_field::type_id::create("pad_dbg_mode_en_5");
         pad_dbg_mode_en_4 = uvm_reg_field::type_id::create("pad_dbg_mode_en_4");
         pad_dbg_mode_en_3 = uvm_reg_field::type_id::create("pad_dbg_mode_en_3");
         pad_dbg_mode_en_2 = uvm_reg_field::type_id::create("pad_dbg_mode_en_2");
         pad_dbg_mode_en_1 = uvm_reg_field::type_id::create("pad_dbg_mode_en_1");
         pad_dbg_mode_en_0 = uvm_reg_field::type_id::create("pad_dbg_mode_en_0");

         pad_dbg_mode_en_31.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_30.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_29.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_28.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_27.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_26.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_25.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_24.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_23.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_22.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_21.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_20.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_19.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_18.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_17.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_16.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_15.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_14.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_13.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_12.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_11.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_10.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_9.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_8.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_7.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_6.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_5.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_4.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_3.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_2.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_0.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_ctrl_pad_dbg_mode_en_1
   // 
   // Enable the corresponding GPIO pads debug functionality.
   //--------------------------------------------------------------------

   class siracusa_ctrl_pad_dbg_mode_en_1 extends uvm_reg;
      `uvm_object_utils(siracusa_ctrl_pad_dbg_mode_en_1)

      rand uvm_reg_field pad_dbg_mode_en_42; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_41; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_40; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_39; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_38; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_37; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_36; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_35; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_34; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_33; // For PAD_DBG_MODE_EN1
      rand uvm_reg_field pad_dbg_mode_en_32; // For PAD_DBG_MODE_EN1


      // Function: new
      // 
      function new(string name = "siracusa_ctrl_pad_dbg_mode_en_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_dbg_mode_en_42 = uvm_reg_field::type_id::create("pad_dbg_mode_en_42");
         pad_dbg_mode_en_41 = uvm_reg_field::type_id::create("pad_dbg_mode_en_41");
         pad_dbg_mode_en_40 = uvm_reg_field::type_id::create("pad_dbg_mode_en_40");
         pad_dbg_mode_en_39 = uvm_reg_field::type_id::create("pad_dbg_mode_en_39");
         pad_dbg_mode_en_38 = uvm_reg_field::type_id::create("pad_dbg_mode_en_38");
         pad_dbg_mode_en_37 = uvm_reg_field::type_id::create("pad_dbg_mode_en_37");
         pad_dbg_mode_en_36 = uvm_reg_field::type_id::create("pad_dbg_mode_en_36");
         pad_dbg_mode_en_35 = uvm_reg_field::type_id::create("pad_dbg_mode_en_35");
         pad_dbg_mode_en_34 = uvm_reg_field::type_id::create("pad_dbg_mode_en_34");
         pad_dbg_mode_en_33 = uvm_reg_field::type_id::create("pad_dbg_mode_en_33");
         pad_dbg_mode_en_32 = uvm_reg_field::type_id::create("pad_dbg_mode_en_32");

         pad_dbg_mode_en_42.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_41.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_40.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_39.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_38.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_37.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_36.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_35.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_34.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_33.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pad_dbg_mode_en_32.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio00_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio00_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio00_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio00_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio00_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio00. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio00_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio00_mux_sel)

      rand uvm_reg_field pad_gpio00_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio00_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio00_mux_sel = uvm_reg_field::type_id::create("pad_gpio00_mux_sel");

         pad_gpio00_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio01_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio01_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio01_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio01_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio01_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio01. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio01_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio01_mux_sel)

      rand uvm_reg_field pad_gpio01_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio01_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio01_mux_sel = uvm_reg_field::type_id::create("pad_gpio01_mux_sel");

         pad_gpio01_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio02_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio02_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio02_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio02_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio02_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio02. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio02_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio02_mux_sel)

      rand uvm_reg_field pad_gpio02_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio02_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio02_mux_sel = uvm_reg_field::type_id::create("pad_gpio02_mux_sel");

         pad_gpio02_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio03_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio03_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio03_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio03_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio03_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio03. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio03_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio03_mux_sel)

      rand uvm_reg_field pad_gpio03_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio03_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio03_mux_sel = uvm_reg_field::type_id::create("pad_gpio03_mux_sel");

         pad_gpio03_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio04_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio04_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio04_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio04_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio04_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio04. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio04_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio04_mux_sel)

      rand uvm_reg_field pad_gpio04_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio04_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio04_mux_sel = uvm_reg_field::type_id::create("pad_gpio04_mux_sel");

         pad_gpio04_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio05_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio05_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio05_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio05_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio05_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio05. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio05_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio05_mux_sel)

      rand uvm_reg_field pad_gpio05_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio05_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio05_mux_sel = uvm_reg_field::type_id::create("pad_gpio05_mux_sel");

         pad_gpio05_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio06_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio06_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio06_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio06_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio06_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio06. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio06_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio06_mux_sel)

      rand uvm_reg_field pad_gpio06_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio06_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio06_mux_sel = uvm_reg_field::type_id::create("pad_gpio06_mux_sel");

         pad_gpio06_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio07_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio07_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio07_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio07_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio07_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio07. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio07_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio07_mux_sel)

      rand uvm_reg_field pad_gpio07_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio07_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio07_mux_sel = uvm_reg_field::type_id::create("pad_gpio07_mux_sel");

         pad_gpio07_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio08_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio08_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio08_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio08_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio08_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio08. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio08_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio08_mux_sel)

      rand uvm_reg_field pad_gpio08_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio08_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio08_mux_sel = uvm_reg_field::type_id::create("pad_gpio08_mux_sel");

         pad_gpio08_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio09_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio09_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio09_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio09_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio09_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio09. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio09_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio09_mux_sel)

      rand uvm_reg_field pad_gpio09_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio09_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio09_mux_sel = uvm_reg_field::type_id::create("pad_gpio09_mux_sel");

         pad_gpio09_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio10_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio10_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio10_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio10_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio10_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio10. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio10_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio10_mux_sel)

      rand uvm_reg_field pad_gpio10_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio10_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio10_mux_sel = uvm_reg_field::type_id::create("pad_gpio10_mux_sel");

         pad_gpio10_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio11_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio11_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio11_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio11_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio11_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio11. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio11_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio11_mux_sel)

      rand uvm_reg_field pad_gpio11_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio11_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio11_mux_sel = uvm_reg_field::type_id::create("pad_gpio11_mux_sel");

         pad_gpio11_mux_sel.configure(this, 4, 0, "RW", 0, 4'h1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio12_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio12_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio12_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio12_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio12_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio12. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio12_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio12_mux_sel)

      rand uvm_reg_field pad_gpio12_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio12_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio12_mux_sel = uvm_reg_field::type_id::create("pad_gpio12_mux_sel");

         pad_gpio12_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio13_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio13_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio13_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio13_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio13_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio13. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio13_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio13_mux_sel)

      rand uvm_reg_field pad_gpio13_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio13_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio13_mux_sel = uvm_reg_field::type_id::create("pad_gpio13_mux_sel");

         pad_gpio13_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio14_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio14_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio14_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio14_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio14_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio14. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio14_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio14_mux_sel)

      rand uvm_reg_field pad_gpio14_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio14_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio14_mux_sel = uvm_reg_field::type_id::create("pad_gpio14_mux_sel");

         pad_gpio14_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio15_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio15_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio15_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio15_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio15_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio15. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio15_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio15_mux_sel)

      rand uvm_reg_field pad_gpio15_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio15_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio15_mux_sel = uvm_reg_field::type_id::create("pad_gpio15_mux_sel");

         pad_gpio15_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio16_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio16_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio16_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio16_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio16_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio16. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio16_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio16_mux_sel)

      rand uvm_reg_field pad_gpio16_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio16_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio16_mux_sel = uvm_reg_field::type_id::create("pad_gpio16_mux_sel");

         pad_gpio16_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio17_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio17_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio17_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio17_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio17_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio17. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio17_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio17_mux_sel)

      rand uvm_reg_field pad_gpio17_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio17_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio17_mux_sel = uvm_reg_field::type_id::create("pad_gpio17_mux_sel");

         pad_gpio17_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio18_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio18_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio18_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio18_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio18_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio18. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio18_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio18_mux_sel)

      rand uvm_reg_field pad_gpio18_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio18_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio18_mux_sel = uvm_reg_field::type_id::create("pad_gpio18_mux_sel");

         pad_gpio18_mux_sel.configure(this, 2, 0, "RW", 0, 2'b01, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio19_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio19_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio19_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio19_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio19_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio19. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio19_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio19_mux_sel)

      rand uvm_reg_field pad_gpio19_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio19_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio19_mux_sel = uvm_reg_field::type_id::create("pad_gpio19_mux_sel");

         pad_gpio19_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio20_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio20_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio20_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio20_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio20_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio20. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio20_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio20_mux_sel)

      rand uvm_reg_field pad_gpio20_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio20_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio20_mux_sel = uvm_reg_field::type_id::create("pad_gpio20_mux_sel");

         pad_gpio20_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio21_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio21_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio21_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio21_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio21_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio21. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio21_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio21_mux_sel)

      rand uvm_reg_field pad_gpio21_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio21_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio21_mux_sel = uvm_reg_field::type_id::create("pad_gpio21_mux_sel");

         pad_gpio21_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio22_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio22_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio22_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio22_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio22_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio22. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio22_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio22_mux_sel)

      rand uvm_reg_field pad_gpio22_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio22_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio22_mux_sel = uvm_reg_field::type_id::create("pad_gpio22_mux_sel");

         pad_gpio22_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio23_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio23_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio23_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio23_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio23_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio23. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio23_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio23_mux_sel)

      rand uvm_reg_field pad_gpio23_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio23_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio23_mux_sel = uvm_reg_field::type_id::create("pad_gpio23_mux_sel");

         pad_gpio23_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio24_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio24_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio24_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio24_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio24_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio24. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio24_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio24_mux_sel)

      rand uvm_reg_field pad_gpio24_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio24_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio24_mux_sel = uvm_reg_field::type_id::create("pad_gpio24_mux_sel");

         pad_gpio24_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio25_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio25_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio25_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio25_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio25_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio25. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio25_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio25_mux_sel)

      rand uvm_reg_field pad_gpio25_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio25_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio25_mux_sel = uvm_reg_field::type_id::create("pad_gpio25_mux_sel");

         pad_gpio25_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio26_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio26_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio26_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio26_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio26_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio26. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio26_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio26_mux_sel)

      rand uvm_reg_field pad_gpio26_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio26_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio26_mux_sel = uvm_reg_field::type_id::create("pad_gpio26_mux_sel");

         pad_gpio26_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio27_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio27_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio27_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio27_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio27_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio27. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio27_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio27_mux_sel)

      rand uvm_reg_field pad_gpio27_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio27_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio27_mux_sel = uvm_reg_field::type_id::create("pad_gpio27_mux_sel");

         pad_gpio27_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio28_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio28_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio28_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio28_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio28_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio28. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio28_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio28_mux_sel)

      rand uvm_reg_field pad_gpio28_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio28_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio28_mux_sel = uvm_reg_field::type_id::create("pad_gpio28_mux_sel");

         pad_gpio28_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio29_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio29_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio29_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio29_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio29_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio29. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio29_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio29_mux_sel)

      rand uvm_reg_field pad_gpio29_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio29_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio29_mux_sel = uvm_reg_field::type_id::create("pad_gpio29_mux_sel");

         pad_gpio29_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio30_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio30_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio30_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio30_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio30_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio30. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio30_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio30_mux_sel)

      rand uvm_reg_field pad_gpio30_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio30_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio30_mux_sel = uvm_reg_field::type_id::create("pad_gpio30_mux_sel");

         pad_gpio30_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio31_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio31_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio31_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio31_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio31_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio31. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio31_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio31_mux_sel)

      rand uvm_reg_field pad_gpio31_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio31_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio31_mux_sel = uvm_reg_field::type_id::create("pad_gpio31_mux_sel");

         pad_gpio31_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio32_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio32_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio32_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio32_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio32_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio32. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio32_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio32_mux_sel)

      rand uvm_reg_field pad_gpio32_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio32_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio32_mux_sel = uvm_reg_field::type_id::create("pad_gpio32_mux_sel");

         pad_gpio32_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio33_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio33_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio33_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio33_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio33_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio33. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio33_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio33_mux_sel)

      rand uvm_reg_field pad_gpio33_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio33_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio33_mux_sel = uvm_reg_field::type_id::create("pad_gpio33_mux_sel");

         pad_gpio33_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio34_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio34_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio34_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio34_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio34_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio34. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio34_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio34_mux_sel)

      rand uvm_reg_field pad_gpio34_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio34_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio34_mux_sel = uvm_reg_field::type_id::create("pad_gpio34_mux_sel");

         pad_gpio34_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio35_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio35_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio35_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio35_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio35_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio35. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio35_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio35_mux_sel)

      rand uvm_reg_field pad_gpio35_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio35_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio35_mux_sel = uvm_reg_field::type_id::create("pad_gpio35_mux_sel");

         pad_gpio35_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio36_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio36_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio36_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio36_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio36_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio36. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio36_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio36_mux_sel)

      rand uvm_reg_field pad_gpio36_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio36_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio36_mux_sel = uvm_reg_field::type_id::create("pad_gpio36_mux_sel");

         pad_gpio36_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio37_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio37_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio37_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio37_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio37_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio37. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio37_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio37_mux_sel)

      rand uvm_reg_field pad_gpio37_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio37_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio37_mux_sel = uvm_reg_field::type_id::create("pad_gpio37_mux_sel");

         pad_gpio37_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio38_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio38_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio38_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio38_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio38_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio38. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio38_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio38_mux_sel)

      rand uvm_reg_field pad_gpio38_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio38_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio38_mux_sel = uvm_reg_field::type_id::create("pad_gpio38_mux_sel");

         pad_gpio38_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio39_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio39_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio39_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio39_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio39_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio39. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio39_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio39_mux_sel)

      rand uvm_reg_field pad_gpio39_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio39_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio39_mux_sel = uvm_reg_field::type_id::create("pad_gpio39_mux_sel");

         pad_gpio39_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio40_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio40_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio40_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio40_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio40_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio40. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio40_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio40_mux_sel)

      rand uvm_reg_field pad_gpio40_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio40_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio40_mux_sel = uvm_reg_field::type_id::create("pad_gpio40_mux_sel");

         pad_gpio40_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio41_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio41_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio41_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio41_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio41_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio41. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio41_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio41_mux_sel)

      rand uvm_reg_field pad_gpio41_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio41_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio41_mux_sel = uvm_reg_field::type_id::create("pad_gpio41_mux_sel");

         pad_gpio41_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio42_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio42_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio42_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio42_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_pad_gpio42_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio42. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_pad_gpio42_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_debug_config_pad_gpio42_mux_sel)

      rand uvm_reg_field pad_gpio42_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_pad_gpio42_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio42_mux_sel = uvm_reg_field::type_id::create("pad_gpio42_mux_sel");

         pad_gpio42_mux_sel.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio00_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio00_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio00_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio00_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio00_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio00. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio00_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio00_mux_sel)

      rand uvm_reg_field pad_gpio00_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio00_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio00_mux_sel = uvm_reg_field::type_id::create("pad_gpio00_mux_sel");

         pad_gpio00_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio01_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio01_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio01_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio01_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio01_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio01. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio01_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio01_mux_sel)

      rand uvm_reg_field pad_gpio01_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio01_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio01_mux_sel = uvm_reg_field::type_id::create("pad_gpio01_mux_sel");

         pad_gpio01_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio02_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio02_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio02_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio02_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio02_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio02. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio02_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio02_mux_sel)

      rand uvm_reg_field pad_gpio02_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio02_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio02_mux_sel = uvm_reg_field::type_id::create("pad_gpio02_mux_sel");

         pad_gpio02_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio03_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio03_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio03_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio03_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio03_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio03. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio03_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio03_mux_sel)

      rand uvm_reg_field pad_gpio03_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio03_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio03_mux_sel = uvm_reg_field::type_id::create("pad_gpio03_mux_sel");

         pad_gpio03_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio04_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio04_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio04_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio04_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio04_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio04. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio04_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio04_mux_sel)

      rand uvm_reg_field pad_gpio04_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio04_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio04_mux_sel = uvm_reg_field::type_id::create("pad_gpio04_mux_sel");

         pad_gpio04_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio05_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio05_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio05_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio05_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio05_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio05. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio05_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio05_mux_sel)

      rand uvm_reg_field pad_gpio05_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio05_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio05_mux_sel = uvm_reg_field::type_id::create("pad_gpio05_mux_sel");

         pad_gpio05_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio06_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio06_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio06_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio06_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio06_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio06. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio06_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio06_mux_sel)

      rand uvm_reg_field pad_gpio06_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio06_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio06_mux_sel = uvm_reg_field::type_id::create("pad_gpio06_mux_sel");

         pad_gpio06_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio07_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio07_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio07_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio07_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio07_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio07. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio07_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio07_mux_sel)

      rand uvm_reg_field pad_gpio07_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio07_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio07_mux_sel = uvm_reg_field::type_id::create("pad_gpio07_mux_sel");

         pad_gpio07_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio08_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio08_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio08_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio08_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio08_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio08. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio08_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio08_mux_sel)

      rand uvm_reg_field pad_gpio08_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio08_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio08_mux_sel = uvm_reg_field::type_id::create("pad_gpio08_mux_sel");

         pad_gpio08_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio09_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio09_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio09_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio09_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio09_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio09. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio09_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio09_mux_sel)

      rand uvm_reg_field pad_gpio09_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio09_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio09_mux_sel = uvm_reg_field::type_id::create("pad_gpio09_mux_sel");

         pad_gpio09_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio10_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio10_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio10_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio10_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio10_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio10. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio10_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio10_mux_sel)

      rand uvm_reg_field pad_gpio10_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio10_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio10_mux_sel = uvm_reg_field::type_id::create("pad_gpio10_mux_sel");

         pad_gpio10_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio11_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio11_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio11_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio11_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio11_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio11. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio11_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio11_mux_sel)

      rand uvm_reg_field pad_gpio11_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio11_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio11_mux_sel = uvm_reg_field::type_id::create("pad_gpio11_mux_sel");

         pad_gpio11_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio12_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio12_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio12_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio12_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio12_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio12. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio12_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio12_mux_sel)

      rand uvm_reg_field pad_gpio12_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio12_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio12_mux_sel = uvm_reg_field::type_id::create("pad_gpio12_mux_sel");

         pad_gpio12_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio13_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio13_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio13_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio13_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio13_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio13. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio13_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio13_mux_sel)

      rand uvm_reg_field pad_gpio13_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio13_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio13_mux_sel = uvm_reg_field::type_id::create("pad_gpio13_mux_sel");

         pad_gpio13_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio14_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio14_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio14_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio14_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio14_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio14. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio14_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio14_mux_sel)

      rand uvm_reg_field pad_gpio14_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio14_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio14_mux_sel = uvm_reg_field::type_id::create("pad_gpio14_mux_sel");

         pad_gpio14_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio15_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio15_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio15_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio15_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio15_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio15. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio15_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio15_mux_sel)

      rand uvm_reg_field pad_gpio15_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio15_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio15_mux_sel = uvm_reg_field::type_id::create("pad_gpio15_mux_sel");

         pad_gpio15_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio16_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio16_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio16_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio16_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio16_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio16. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio16_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio16_mux_sel)

      rand uvm_reg_field pad_gpio16_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio16_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio16_mux_sel = uvm_reg_field::type_id::create("pad_gpio16_mux_sel");

         pad_gpio16_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio17_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio17_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio17_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio17_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio17_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio17. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio17_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio17_mux_sel)

      rand uvm_reg_field pad_gpio17_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio17_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio17_mux_sel = uvm_reg_field::type_id::create("pad_gpio17_mux_sel");

         pad_gpio17_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio18_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio18_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio18_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio18_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio18_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio18. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio18_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio18_mux_sel)

      rand uvm_reg_field pad_gpio18_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio18_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio18_mux_sel = uvm_reg_field::type_id::create("pad_gpio18_mux_sel");

         pad_gpio18_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio19_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio19_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio19_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio19_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio19_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio19. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio19_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio19_mux_sel)

      rand uvm_reg_field pad_gpio19_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio19_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio19_mux_sel = uvm_reg_field::type_id::create("pad_gpio19_mux_sel");

         pad_gpio19_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio20_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio20_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio20_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio20_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio20_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio20. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio20_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio20_mux_sel)

      rand uvm_reg_field pad_gpio20_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio20_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio20_mux_sel = uvm_reg_field::type_id::create("pad_gpio20_mux_sel");

         pad_gpio20_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio21_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio21_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio21_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio21_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio21_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio21. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio21_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio21_mux_sel)

      rand uvm_reg_field pad_gpio21_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio21_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio21_mux_sel = uvm_reg_field::type_id::create("pad_gpio21_mux_sel");

         pad_gpio21_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio22_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio22_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio22_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio22_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio22_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio22. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio22_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio22_mux_sel)

      rand uvm_reg_field pad_gpio22_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio22_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio22_mux_sel = uvm_reg_field::type_id::create("pad_gpio22_mux_sel");

         pad_gpio22_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio23_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio23_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio23_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio23_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio23_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio23. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio23_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio23_mux_sel)

      rand uvm_reg_field pad_gpio23_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio23_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio23_mux_sel = uvm_reg_field::type_id::create("pad_gpio23_mux_sel");

         pad_gpio23_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio24_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio24_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio24_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio24_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio24_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio24. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio24_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio24_mux_sel)

      rand uvm_reg_field pad_gpio24_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio24_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio24_mux_sel = uvm_reg_field::type_id::create("pad_gpio24_mux_sel");

         pad_gpio24_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio25_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio25_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio25_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio25_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio25_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio25. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio25_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio25_mux_sel)

      rand uvm_reg_field pad_gpio25_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio25_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio25_mux_sel = uvm_reg_field::type_id::create("pad_gpio25_mux_sel");

         pad_gpio25_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio26_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio26_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio26_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio26_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio26_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio26. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio26_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio26_mux_sel)

      rand uvm_reg_field pad_gpio26_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio26_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio26_mux_sel = uvm_reg_field::type_id::create("pad_gpio26_mux_sel");

         pad_gpio26_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio27_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio27_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio27_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio27_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio27_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio27. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio27_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio27_mux_sel)

      rand uvm_reg_field pad_gpio27_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio27_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio27_mux_sel = uvm_reg_field::type_id::create("pad_gpio27_mux_sel");

         pad_gpio27_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio28_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio28_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio28_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio28_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio28_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio28. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio28_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio28_mux_sel)

      rand uvm_reg_field pad_gpio28_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio28_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio28_mux_sel = uvm_reg_field::type_id::create("pad_gpio28_mux_sel");

         pad_gpio28_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio29_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio29_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio29_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio29_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio29_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio29. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio29_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio29_mux_sel)

      rand uvm_reg_field pad_gpio29_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio29_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio29_mux_sel = uvm_reg_field::type_id::create("pad_gpio29_mux_sel");

         pad_gpio29_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio30_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio30_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio30_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio30_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio30_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio30. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio30_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio30_mux_sel)

      rand uvm_reg_field pad_gpio30_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio30_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio30_mux_sel = uvm_reg_field::type_id::create("pad_gpio30_mux_sel");

         pad_gpio30_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio31_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio31_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio31_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio31_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio31_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio31. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio31_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio31_mux_sel)

      rand uvm_reg_field pad_gpio31_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio31_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio31_mux_sel = uvm_reg_field::type_id::create("pad_gpio31_mux_sel");

         pad_gpio31_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio32_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio32_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio32_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio32_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio32_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio32. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio32_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio32_mux_sel)

      rand uvm_reg_field pad_gpio32_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio32_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio32_mux_sel = uvm_reg_field::type_id::create("pad_gpio32_mux_sel");

         pad_gpio32_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio33_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio33_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio33_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio33_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio33_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio33. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio33_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio33_mux_sel)

      rand uvm_reg_field pad_gpio33_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio33_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio33_mux_sel = uvm_reg_field::type_id::create("pad_gpio33_mux_sel");

         pad_gpio33_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio34_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio34_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio34_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio34_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio34_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio34. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio34_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio34_mux_sel)

      rand uvm_reg_field pad_gpio34_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio34_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio34_mux_sel = uvm_reg_field::type_id::create("pad_gpio34_mux_sel");

         pad_gpio34_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio35_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio35_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio35_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio35_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio35_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio35. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio35_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio35_mux_sel)

      rand uvm_reg_field pad_gpio35_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio35_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio35_mux_sel = uvm_reg_field::type_id::create("pad_gpio35_mux_sel");

         pad_gpio35_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio36_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio36_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio36_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio36_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio36_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio36. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio36_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio36_mux_sel)

      rand uvm_reg_field pad_gpio36_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio36_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio36_mux_sel = uvm_reg_field::type_id::create("pad_gpio36_mux_sel");

         pad_gpio36_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio37_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio37_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio37_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio37_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio37_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio37. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio37_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio37_mux_sel)

      rand uvm_reg_field pad_gpio37_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio37_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio37_mux_sel = uvm_reg_field::type_id::create("pad_gpio37_mux_sel");

         pad_gpio37_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio38_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio38_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio38_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio38_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio38_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio38. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio38_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio38_mux_sel)

      rand uvm_reg_field pad_gpio38_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio38_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio38_mux_sel = uvm_reg_field::type_id::create("pad_gpio38_mux_sel");

         pad_gpio38_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio39_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio39_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio39_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio39_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio39_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio39. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio39_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio39_mux_sel)

      rand uvm_reg_field pad_gpio39_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio39_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio39_mux_sel = uvm_reg_field::type_id::create("pad_gpio39_mux_sel");

         pad_gpio39_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio40_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio40_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio40_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio40_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio40_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio40. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio40_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio40_mux_sel)

      rand uvm_reg_field pad_gpio40_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio40_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio40_mux_sel = uvm_reg_field::type_id::create("pad_gpio40_mux_sel");

         pad_gpio40_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio41_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio41_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio41_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio41_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio41_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio41. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio41_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio41_mux_sel)

      rand uvm_reg_field pad_gpio41_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio41_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio41_mux_sel = uvm_reg_field::type_id::create("pad_gpio41_mux_sel");

         pad_gpio41_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio42_cfg
   // 
   // Pad signal configuration.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio42_cfg extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio42_cfg)

      rand uvm_reg_field tx_en; // TX driver enable, active low
      rand uvm_reg_field st_en; // Schmitt-trigger enable, active high
      rand uvm_reg_field ret_en; // Enable retention mode, active-high
      rand uvm_reg_field pull_sel; // 1 -> use pull-up resistor (if pull_en == 1), 0 -> use pull-down resistor
      rand uvm_reg_field pull_en; // Enable pull up/down (depends on pull_sel) resistor, active-high
      rand uvm_reg_field drv3; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv2; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv1; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field drv0; // Choose the driving strength of the pad. LSB = ~3mA
      rand uvm_reg_field chip2pad; // Connects to pad's TX driver


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio42_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         tx_en = uvm_reg_field::type_id::create("tx_en");
         st_en = uvm_reg_field::type_id::create("st_en");
         ret_en = uvm_reg_field::type_id::create("ret_en");
         pull_sel = uvm_reg_field::type_id::create("pull_sel");
         pull_en = uvm_reg_field::type_id::create("pull_en");
         drv3 = uvm_reg_field::type_id::create("drv3");
         drv2 = uvm_reg_field::type_id::create("drv2");
         drv1 = uvm_reg_field::type_id::create("drv1");
         drv0 = uvm_reg_field::type_id::create("drv0");
         chip2pad = uvm_reg_field::type_id::create("chip2pad");

         tx_en.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         st_en.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         ret_en.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         pull_sel.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         pull_en.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         drv3.configure(this, 1, 4, "RW", 0, 1'b1, 1, 1, 0);
         drv2.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         drv1.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         drv0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         chip2pad.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_pad_gpio42_mux_sel
   // 
   // Pad signal port multiplex selection for pad pad_gpio42. The programmed value defines which port
   // is connected to the pad.
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_pad_gpio42_mux_sel extends uvm_reg;
      `uvm_object_utils(siracusa_pads_functional_config_pad_gpio42_mux_sel)

      rand uvm_reg_field pad_gpio42_mux_sel; 


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_pad_gpio42_mux_sel");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio42_mux_sel = uvm_reg_field::type_id::create("pad_gpio42_mux_sel");

         pad_gpio42_mux_sel.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: udma_cpi_rx_saddr
   // 
   //--------------------------------------------------------------------

   class udma_cpi_rx_saddr extends uvm_reg;
      `uvm_object_utils(udma_cpi_rx_saddr)

      rand uvm_reg_field rx_saddr; // RX Camera uDMA transfer address of associated buffer register


      // Function: new
      // 
      function new(string name = "udma_cpi_rx_saddr");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         rx_saddr = uvm_reg_field::type_id::create("rx_saddr");

         rx_saddr.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: udma_cpi_rx_size
   // 
   //--------------------------------------------------------------------

   class udma_cpi_rx_size extends uvm_reg;
      `uvm_object_utils(udma_cpi_rx_size)

      rand uvm_reg_field rx_size; // RX Camera uDMA transfer size of buffer register


      // Function: new
      // 
      function new(string name = "udma_cpi_rx_size");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         rx_size = uvm_reg_field::type_id::create("rx_size");

         rx_size.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory
   // 
   // 4 MB weight memory block
   //--------------------------------------------------------------------

   class weight_memory extends uvm_mem;
      `uvm_object_utils(weight_memory)



      // Function: new
      // 
      function new(string name = "weight_memory");
         super.new(name, 'h100000, 32, "RW", UVM_NO_COVERAGE);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_cfg
   // 
   // Change settings for virtual memory mode of the weight memory
   //--------------------------------------------------------------------

   class weight_memory_config_cfg extends uvm_reg;
      `uvm_object_utils(weight_memory_config_cfg)

      rand uvm_reg_field vmm_en; // Enable weight memory virtual memory mode.
      rand uvm_reg_field prio_mode; // Change the priority mode for arbitration betweeen cluster and accelerator access


      // Function: new
      // 
      function new(string name = "weight_memory_config_cfg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         vmm_en = uvm_reg_field::type_id::create("vmm_en");
         prio_mode = uvm_reg_field::type_id::create("prio_mode");

         vmm_en.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         prio_mode.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_pwr_0
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_pwr_0 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_pwr_0)

      rand uvm_reg_field sleep_en_0; // Initiate lightsleep/wakeup sequence
      rand uvm_reg_field pwr_on_0; // Initiate power on/off cycling sequence


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_pwr_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         sleep_en_0 = uvm_reg_field::type_id::create("sleep_en_0");
         pwr_on_0 = uvm_reg_field::type_id::create("pwr_on_0");

         sleep_en_0.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pwr_on_0.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_pwr_1
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_pwr_1 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_pwr_1)

      rand uvm_reg_field sleep_en_1; // For MRAM_BANK_PWR1
      rand uvm_reg_field pwr_on_1; // For MRAM_BANK_PWR1


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_pwr_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         sleep_en_1 = uvm_reg_field::type_id::create("sleep_en_1");
         pwr_on_1 = uvm_reg_field::type_id::create("pwr_on_1");

         sleep_en_1.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pwr_on_1.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_pwr_2
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_pwr_2 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_pwr_2)

      rand uvm_reg_field sleep_en_2; // For MRAM_BANK_PWR2
      rand uvm_reg_field pwr_on_2; // For MRAM_BANK_PWR2


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_pwr_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         sleep_en_2 = uvm_reg_field::type_id::create("sleep_en_2");
         pwr_on_2 = uvm_reg_field::type_id::create("pwr_on_2");

         sleep_en_2.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pwr_on_2.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_pwr_3
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_pwr_3 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_pwr_3)

      rand uvm_reg_field sleep_en_3; // For MRAM_BANK_PWR3
      rand uvm_reg_field pwr_on_3; // For MRAM_BANK_PWR3


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_pwr_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         sleep_en_3 = uvm_reg_field::type_id::create("sleep_en_3");
         pwr_on_3 = uvm_reg_field::type_id::create("pwr_on_3");

         sleep_en_3.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         pwr_on_3.configure(this, 1, 0, "RW", 0, 1'b1, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfga_0
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfga_0 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfga_0)

      rand uvm_reg_field ds_dur_0; // Number of cycles to wait between rst_b deassertion and start of normal operation
      rand uvm_reg_field trst_dur_0; // Number of cycles to wait between power_on and rst_b deassertion


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfga_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ds_dur_0 = uvm_reg_field::type_id::create("ds_dur_0");
         trst_dur_0 = uvm_reg_field::type_id::create("trst_dur_0");

         ds_dur_0.configure(this, 16, 16, "RW", 0, 16'h09c4, 1, 1, 1);
         trst_dur_0.configure(this, 16, 0, "RW", 0, 16'h0005, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfga_1
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfga_1 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfga_1)

      rand uvm_reg_field ds_dur_1; // For MRAM_BANK_SEQ_CFGA1
      rand uvm_reg_field trst_dur_1; // For MRAM_BANK_SEQ_CFGA1


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfga_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ds_dur_1 = uvm_reg_field::type_id::create("ds_dur_1");
         trst_dur_1 = uvm_reg_field::type_id::create("trst_dur_1");

         ds_dur_1.configure(this, 16, 16, "RW", 0, 16'h09c4, 1, 1, 1);
         trst_dur_1.configure(this, 16, 0, "RW", 0, 16'h0005, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfga_2
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfga_2 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfga_2)

      rand uvm_reg_field ds_dur_2; // For MRAM_BANK_SEQ_CFGA2
      rand uvm_reg_field trst_dur_2; // For MRAM_BANK_SEQ_CFGA2


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfga_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ds_dur_2 = uvm_reg_field::type_id::create("ds_dur_2");
         trst_dur_2 = uvm_reg_field::type_id::create("trst_dur_2");

         ds_dur_2.configure(this, 16, 16, "RW", 0, 16'h09c4, 1, 1, 1);
         trst_dur_2.configure(this, 16, 0, "RW", 0, 16'h0005, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfga_3
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfga_3 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfga_3)

      rand uvm_reg_field ds_dur_3; // For MRAM_BANK_SEQ_CFGA3
      rand uvm_reg_field trst_dur_3; // For MRAM_BANK_SEQ_CFGA3


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfga_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ds_dur_3 = uvm_reg_field::type_id::create("ds_dur_3");
         trst_dur_3 = uvm_reg_field::type_id::create("trst_dur_3");

         ds_dur_3.configure(this, 16, 16, "RW", 0, 16'h09c4, 1, 1, 1);
         trst_dur_3.configure(this, 16, 0, "RW", 0, 16'h0005, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfgb_0
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfgb_0 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfgb_0)

      rand uvm_reg_field ls_dur_0; // Number of cycles to wait between ls deassertion and start of normal operation


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfgb_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ls_dur_0 = uvm_reg_field::type_id::create("ls_dur_0");

         ls_dur_0.configure(this, 16, 0, "RW", 0, 16'h0032, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfgb_1
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfgb_1 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfgb_1)

      rand uvm_reg_field ls_dur_1; // For MRAM_BANK_SEQ_CFGB1


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfgb_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ls_dur_1 = uvm_reg_field::type_id::create("ls_dur_1");

         ls_dur_1.configure(this, 16, 0, "RW", 0, 16'h0032, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfgb_2
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfgb_2 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfgb_2)

      rand uvm_reg_field ls_dur_2; // For MRAM_BANK_SEQ_CFGB2


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfgb_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ls_dur_2 = uvm_reg_field::type_id::create("ls_dur_2");

         ls_dur_2.configure(this, 16, 0, "RW", 0, 16'h0032, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_seq_cfgb_3
   // 
   // Change the power sequencing durations
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_seq_cfgb_3 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_seq_cfgb_3)

      rand uvm_reg_field ls_dur_3; // For MRAM_BANK_SEQ_CFGB3


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_seq_cfgb_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         ls_dur_3 = uvm_reg_field::type_id::create("ls_dur_3");

         ls_dur_3.configure(this, 16, 0, "RW", 0, 16'h0032, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_status_0
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_status_0 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_status_0)

      uvm_reg_field status_cut1_0; // Initiate lightsleep/wakeup sequence
      uvm_reg_field status_cut0_0; // Initiate power on/off cycling sequence


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_status_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         status_cut1_0 = uvm_reg_field::type_id::create("status_cut1_0");
         status_cut0_0 = uvm_reg_field::type_id::create("status_cut0_0");

         status_cut1_0.configure(this, 4, 4, "RO", 0, 4'h0, 1, 0, 0);
         status_cut0_0.configure(this, 4, 0, "RO", 0, 4'h0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_status_1
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_status_1 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_status_1)

      uvm_reg_field status_cut1_1; // For MRAM_BANK_STATUS1
      uvm_reg_field status_cut0_1; // For MRAM_BANK_STATUS1


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_status_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         status_cut1_1 = uvm_reg_field::type_id::create("status_cut1_1");
         status_cut0_1 = uvm_reg_field::type_id::create("status_cut0_1");

         status_cut1_1.configure(this, 4, 4, "RO", 0, 4'h0, 1, 0, 0);
         status_cut0_1.configure(this, 4, 0, "RO", 0, 4'h0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_status_2
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_status_2 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_status_2)

      uvm_reg_field status_cut1_2; // For MRAM_BANK_STATUS2
      uvm_reg_field status_cut0_2; // For MRAM_BANK_STATUS2


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_status_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         status_cut1_2 = uvm_reg_field::type_id::create("status_cut1_2");
         status_cut0_2 = uvm_reg_field::type_id::create("status_cut0_2");

         status_cut1_2.configure(this, 4, 4, "RO", 0, 4'h0, 1, 0, 0);
         status_cut0_2.configure(this, 4, 0, "RO", 0, 4'h0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_bank_status_3
   // 
   // Change the power state of the individual MRAM banks
   //--------------------------------------------------------------------

   class weight_memory_config_mram_bank_status_3 extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_bank_status_3)

      uvm_reg_field status_cut1_3; // For MRAM_BANK_STATUS3
      uvm_reg_field status_cut0_3; // For MRAM_BANK_STATUS3


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_bank_status_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         status_cut1_3 = uvm_reg_field::type_id::create("status_cut1_3");
         status_cut0_3 = uvm_reg_field::type_id::create("status_cut0_3");

         status_cut1_3.configure(this, 4, 4, "RO", 0, 4'h0, 1, 0, 0);
         status_cut0_3.configure(this, 4, 0, "RO", 0, 4'h0, 1, 0, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_mram_clk_div
   // 
   // Change the clock divider settings of the MRAM banks. The MRAMs are
   // driven with SoC Clock divided by CLK_DIV_CFG*2 (thus even division only).
   // A value of zero bypasses the divider thus directly driving MRAM with SoC clock.
   //--------------------------------------------------------------------

   class weight_memory_config_mram_clk_div extends uvm_reg;
      `uvm_object_utils(weight_memory_config_mram_clk_div)

      rand uvm_reg_field mram_clk_div; 


      // Function: new
      // 
      function new(string name = "weight_memory_config_mram_clk_div");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         mram_clk_div = uvm_reg_field::type_id::create("mram_clk_div");

         mram_clk_div.configure(this, 4, 0, "RW", 0, 4'h0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_vmm_mram_page_idx
   // 
   // Index of the currently stored page in MRAM.
   //--------------------------------------------------------------------

   class weight_memory_config_vmm_mram_page_idx extends uvm_reg;
      `uvm_object_utils(weight_memory_config_vmm_mram_page_idx)

      rand uvm_reg_field vmm_mram_page_idx; 


      // Function: new
      // 
      function new(string name = "weight_memory_config_vmm_mram_page_idx");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         vmm_mram_page_idx = uvm_reg_field::type_id::create("vmm_mram_page_idx");

         vmm_mram_page_idx.configure(this, 10, 0, "RW", 0, 10'b0000000000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_vmm_sram_page_idx
   // 
   // Index of the currently stored page in SRAM.
   //--------------------------------------------------------------------

   class weight_memory_config_vmm_sram_page_idx extends uvm_reg;
      `uvm_object_utils(weight_memory_config_vmm_sram_page_idx)

      rand uvm_reg_field vmm_sram_page_idx; 


      // Function: new
      // 
      function new(string name = "weight_memory_config_vmm_sram_page_idx");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         vmm_sram_page_idx = uvm_reg_field::type_id::create("vmm_sram_page_idx");

         vmm_sram_page_idx.configure(this, 10, 0, "RW", 0, 10'b0000000000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_vmm_status
   // 
   // Status of virtual memory mode.
   //--------------------------------------------------------------------

   class weight_memory_config_vmm_status extends uvm_reg;
      `uvm_object_utils(weight_memory_config_vmm_status)

      uvm_reg_field vmm_pf_status; // Indicates if there is a pending page fault. Clear the page fault by writing the right page to either MRAM or SRAM and updating the VMM_<XXX>_PAGE_IDX register.
      uvm_reg_field vmm_pf_idx; // Index of the page that caused a page fault. Only valid if VMM_PF_STATUS == 1


      // Function: new
      // 
      function new(string name = "weight_memory_config_vmm_status");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         vmm_pf_status = uvm_reg_field::type_id::create("vmm_pf_status");
         vmm_pf_idx = uvm_reg_field::type_id::create("vmm_pf_idx");

         vmm_pf_status.configure(this, 1, 16, "RO", 0, 1'b0, 1, 0, 0);
         vmm_pf_idx.configure(this, 10, 0, "RO", 0, 10'b0000000000, 1, 0, 0);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: apb_soc_ctrl_block
   // 
   //--------------------------------------------------------------------

   class apb_soc_ctrl_block extends uvm_reg_block;
      `uvm_object_utils(apb_soc_ctrl_block)

      rand apb_soc_ctrl_corestatus corestatus; // Corestatus Register

      uvm_reg_map apb_soc_ctrl_map; 


      // Function: new
      // 
      function new(string name = "apb_soc_ctrl_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         corestatus = apb_soc_ctrl_corestatus::type_id::create("corestatus");
         corestatus.configure(this, null, "r_corestatus");
         corestatus.build();

         apb_soc_ctrl_map = create_map("apb_soc_ctrl_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = apb_soc_ctrl_map;

         apb_soc_ctrl_map.add_reg(corestatus, 'ha0, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_config_block
   // 
   //--------------------------------------------------------------------

   class i3c_config_block extends uvm_reg_block;
      `uvm_object_utils(i3c_config_block)

      rand i3c_config_swrst swrst; // Perform software reset of the whole IP
      rand i3c_config_cfg1 cfg1; // Configure static device configuration. Any change to this register (except for RSTCYCLES) requires reseting the I3C peripheral
      rand i3c_config_cfg2 cfg2; // Configure static device configuration. Any change to this register (except for RSTCYCLES) requires reseting the I3C peripheral
      rand i3c_config_asf_cfg asf_cfg; // Active-safety feature configuration

      uvm_reg_map i3c_config_map; // Default Map


      // Function: new
      // 
      function new(string name = "i3c_config_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         swrst = i3c_config_swrst::type_id::create("swrst");
         swrst.configure(this, null, "");
         swrst.add_hdl_path_slice("u_swrst_locrst.q", 1, 1);
         swrst.add_hdl_path_slice("u_swrst_globrst.q", 0, 1);
         swrst.build();

         cfg1 = i3c_config_cfg1::type_id::create("cfg1");
         cfg1.configure(this, null, "");
         cfg1.add_hdl_path_slice("u_cfg1_pid_inst_id.q", 24, 4);
         cfg1.add_hdl_path_slice("u_cfg1_pid_mfr.q", 9, 15);
         cfg1.add_hdl_path_slice("u_cfg1_device_role.q", 8, 1);
         cfg1.add_hdl_path_slice("u_cfg1_rstcycles.q", 0, 8);
         cfg1.build();

         cfg2 = i3c_config_cfg2::type_id::create("cfg2");
         cfg2.configure(this, null, "");
         cfg2.add_hdl_path_slice("u_cfg2_bus_idle_timer.q", 8, 18);
         cfg2.add_hdl_path_slice("u_cfg2_bus_avail_timer.q", 0, 8);
         cfg2.build();

         asf_cfg = i3c_config_asf_cfg::type_id::create("asf_cfg");
         asf_cfg.configure(this, null, "");
         asf_cfg.add_hdl_path_slice("u_asf_cfg.q", 0, 1);
         asf_cfg.build();

         i3c_config_map = create_map("i3c_config_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = i3c_config_map;

         i3c_config_map.add_reg(swrst, 'h0, "RW");
         i3c_config_map.add_reg(cfg1, 'h4, "RW");
         i3c_config_map.add_reg(cfg2, 'h8, "RW");
         i3c_config_map.add_reg(asf_cfg, 'hc, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_ctrl_block
   // 
   // I3C Configuration Registers
   //--------------------------------------------------------------------

   class i3c_ctrl_block extends uvm_reg_block;
      `uvm_object_utils(i3c_ctrl_block)

      rand i3c_dev_id dev_id; // ID Register for Cadence IP
      rand i3c_ctrl ctrl; // Main Control Register
      rand i3c_prescl_ctrl prescl_ctrl; 
      rand i3c_sir_map_5 sir_map_5; 

      uvm_reg_map i3c_ctrl_map; // Default Map


      // Function: new
      // 
      function new(string name = "i3c_ctrl_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         dev_id = i3c_dev_id::type_id::create("dev_id");
         dev_id.configure(this, null, "i_reg_file");
         dev_id.build();

         ctrl = i3c_ctrl::type_id::create("ctrl");
         ctrl.configure(this);
         ctrl.build();

         prescl_ctrl = i3c_prescl_ctrl::type_id::create("prescl_ctrl");
         prescl_ctrl.configure(this);
         prescl_ctrl.build();

         sir_map_5 = i3c_sir_map_5::type_id::create("sir_map_5");
         sir_map_5.configure(this);
         sir_map_5.build();

         i3c_ctrl_map = create_map("i3c_ctrl_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = i3c_ctrl_map;

         i3c_ctrl_map.add_reg(dev_id, 'h0, "RW");
         i3c_ctrl_map.add_reg(ctrl, 'h10, "RW");
         i3c_ctrl_map.add_reg(prescl_ctrl, 'h14, "RW");
         i3c_ctrl_map.add_reg(sir_map_5, 'h194, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: i3c_block
   // 
   // I3C Configuration Registers
   //--------------------------------------------------------------------

   class i3c_block extends uvm_reg_block;
      `uvm_object_utils(i3c_block)

      rand i3c_config_block cfg; 
      rand i3c_ctrl_block ctrl; 

      uvm_reg_map i3c_map; // Default Map


      // Function: new
      // 
      function new(string name = "i3c_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         cfg = i3c_config_block::type_id::create("cfg");
         cfg.configure(this, "i_reg_file");
         cfg.build();

         ctrl = i3c_ctrl_block::type_id::create("ctrl");
         ctrl.configure(this, "i_i3c_master");
         ctrl.build();

         i3c_map = create_map("i3c_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = i3c_map;

         i3c_map.add_submap(cfg.i3c_config_map, 'h0);
         i3c_map.add_submap(ctrl.i3c_ctrl_map, 'h400);

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: gpio_block
   // 
   //--------------------------------------------------------------------

   class gpio_block extends uvm_reg_block;
      `uvm_object_utils(gpio_block)

      rand gpio_info info; // Info register that contains information about this peripheral.
      rand gpio_cfg cfg; // Global configuration register for the peripheral
      rand gpio_gpio_mode_0 gpio_mode_0; // Set the IO Mode of the GPIO.
      rand gpio_gpio_mode_1 gpio_mode_1; // Set the IO Mode of the GPIO.
      rand gpio_gpio_mode_2 gpio_mode_2; // Set the IO Mode of the GPIO.
      rand gpio_gpio_mode_3 gpio_mode_3; // Set the IO Mode of the GPIO.
      rand gpio_gpio_en_0 gpio_en_0; // Enable sampling on the corresponding GPIO
      rand gpio_gpio_en_1 gpio_en_1; // Enable sampling on the corresponding GPIO
      rand gpio_gpio_in_0 gpio_in_0; // Read the current input values of all GPIOs.
      rand gpio_gpio_in_1 gpio_in_1; // Read the current input values of all GPIOs.
      rand gpio_gpio_out_0 gpio_out_0; // Set the output value of the corresponding GPIOs.
      rand gpio_gpio_out_1 gpio_out_1; // Set the output value of the corresponding GPIOs.
      rand gpio_gpio_set_0 gpio_set_0; // For each asserted bit in this register, set the corresponding bit in the padout register.
      rand gpio_gpio_set_1 gpio_set_1; // For each asserted bit in this register, set the corresponding bit in the padout register.
      rand gpio_gpio_clear_0 gpio_clear_0; // For each asserted bit in this register, clear the corresponding bit in the padout register.
      rand gpio_gpio_clear_1 gpio_clear_1; // For each asserted bit in this register, clear the corresponding bit in the padout register.
      rand gpio_gpio_toggle_0 gpio_toggle_0; // For each asserted bit in this register, toggle the corresponding bit in the padout register.
      rand gpio_gpio_toggle_1 gpio_toggle_1; // For each asserted bit in this register, toggle the corresponding bit in the padout register.
      rand gpio_intrpt_rise_en_0 intrpt_rise_en_0; // Enable Interrupts on rising edges for the corresponding GPIO
      rand gpio_intrpt_rise_en_1 intrpt_rise_en_1; // Enable Interrupts on rising edges for the corresponding GPIO
      rand gpio_intrpt_fall_en_0 intrpt_fall_en_0; // Enable Interrupts on falling edges for the corresponding GPIO
      rand gpio_intrpt_fall_en_1 intrpt_fall_en_1; // Enable Interrupts on falling edges for the corresponding GPIO
      rand gpio_intrpt_lvl_high_en_0 intrpt_lvl_high_en_0; // Enable logic high level-sensitive Interrupts on the corresponding GPIO
      rand gpio_intrpt_lvl_high_en_1 intrpt_lvl_high_en_1; // Enable logic high level-sensitive Interrupts on the corresponding GPIO
      rand gpio_intrpt_lvl_low_en_0 intrpt_lvl_low_en_0; // Enable logic low level-sensitive Interrupts on the corresponding GPIO
      rand gpio_intrpt_lvl_low_en_1 intrpt_lvl_low_en_1; // Enable logic low level-sensitive Interrupts on the corresponding GPIO
      rand gpio_intrpt_status_0 intrpt_status_0; // Asserted if there is any pending interrupts on corresponding GPIOs.
                                                // Writing 1 to a specific bit clears all pending interrupts (rise, fall, low, high) of the corresponding GPIO.
      rand gpio_intrpt_status_1 intrpt_status_1; // Asserted if there is any pending interrupts on corresponding GPIOs.
                                                // Writing 1 to a specific bit clears all pending interrupts (rise, fall, low, high) of the corresponding GPIO.
      rand gpio_intrpt_rise_status_0 intrpt_rise_status_0; // Asserted if there is a pending rise interrupts on corresponding GPIOs.
                                                         // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_rise_status_1 intrpt_rise_status_1; // Asserted if there is a pending rise interrupts on corresponding GPIOs.
                                                         // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_fall_status_0 intrpt_fall_status_0; // Asserted if there is any pending fall interrupts on corresponding GPIOs.
                                                         // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_fall_status_1 intrpt_fall_status_1; // Asserted if there is any pending fall interrupts on corresponding GPIOs.
                                                         // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_lvl_high_status_0 intrpt_lvl_high_status_0; // Asserted if there is any pending high-level interrupts on corresponding GPIOs.
                                                                  // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_lvl_high_status_1 intrpt_lvl_high_status_1; // Asserted if there is any pending high-level interrupts on corresponding GPIOs.
                                                                  // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_lvl_low_status_0 intrpt_lvl_low_status_0; // Asserted if there is any pending low-level interrupts on corresponding GPIOs.
                                                               // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.
      rand gpio_intrpt_lvl_low_status_1 intrpt_lvl_low_status_1; // Asserted if there is any pending low-level interrupts on corresponding GPIOs.
                                                               // Writing 1 to a specific bit clears the pending interrupt of the corresponding GPIO.

      uvm_reg_map gpio_map; // Default Map


      // Function: new
      // 
      function new(string name = "gpio_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         info = gpio_info::type_id::create("info");
         info.configure(this, null, "");
         info.add_hdl_path_slice("u_info_version.qs", 10, 10);
         info.add_hdl_path_slice("u_info_gpio_cnt.qs", 0, 10);
         info.build();

         cfg = gpio_cfg::type_id::create("cfg");
         cfg.configure(this, null, "");
         cfg.add_hdl_path_slice("u_cfg_reserved.q", 1, 1);
         cfg.add_hdl_path_slice("u_cfg_intrpt_mode.q", 0, 1);
         cfg.build();

         gpio_mode_0 = gpio_gpio_mode_0::type_id::create("gpio_mode_0");
         gpio_mode_0.configure(this, null, "");
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_15.q", 30, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_14.q", 28, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_13.q", 26, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_12.q", 24, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_11.q", 22, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_10.q", 20, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_9.q", 18, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_8.q", 16, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_7.q", 14, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_6.q", 12, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_5.q", 10, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_4.q", 8, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_3.q", 6, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_2.q", 4, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_1.q", 2, 2);
         gpio_mode_0.add_hdl_path_slice("u_gpio_mode_0_mode_0.q", 0, 2);
         gpio_mode_0.build();

         gpio_mode_1 = gpio_gpio_mode_1::type_id::create("gpio_mode_1");
         gpio_mode_1.configure(this, null, "");
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_31.q", 30, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_30.q", 28, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_29.q", 26, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_28.q", 24, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_27.q", 22, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_26.q", 20, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_25.q", 18, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_24.q", 16, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_23.q", 14, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_22.q", 12, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_21.q", 10, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_20.q", 8, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_19.q", 6, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_18.q", 4, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_17.q", 2, 2);
         gpio_mode_1.add_hdl_path_slice("u_gpio_mode_1_mode_16.q", 0, 2);
         gpio_mode_1.build();

         gpio_mode_2 = gpio_gpio_mode_2::type_id::create("gpio_mode_2");
         gpio_mode_2.configure(this, null, "");
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_47.q", 30, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_46.q", 28, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_45.q", 26, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_44.q", 24, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_43.q", 22, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_42.q", 20, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_41.q", 18, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_40.q", 16, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_39.q", 14, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_38.q", 12, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_37.q", 10, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_36.q", 8, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_35.q", 6, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_34.q", 4, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_33.q", 2, 2);
         gpio_mode_2.add_hdl_path_slice("u_gpio_mode_2_mode_32.q", 0, 2);
         gpio_mode_2.build();

         gpio_mode_3 = gpio_gpio_mode_3::type_id::create("gpio_mode_3");
         gpio_mode_3.configure(this, null, "");
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_55.q", 14, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_54.q", 12, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_53.q", 10, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_52.q", 8, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_51.q", 6, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_50.q", 4, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_49.q", 2, 2);
         gpio_mode_3.add_hdl_path_slice("u_gpio_mode_3_mode_48.q", 0, 2);
         gpio_mode_3.build();

         gpio_en_0 = gpio_gpio_en_0::type_id::create("gpio_en_0");
         gpio_en_0.configure(this, null, "");
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_31.q", 31, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_30.q", 30, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_29.q", 29, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_28.q", 28, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_27.q", 27, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_26.q", 26, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_25.q", 25, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_24.q", 24, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_23.q", 23, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_22.q", 22, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_21.q", 21, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_20.q", 20, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_19.q", 19, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_18.q", 18, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_17.q", 17, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_16.q", 16, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_15.q", 15, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_14.q", 14, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_13.q", 13, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_12.q", 12, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_11.q", 11, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_10.q", 10, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_9.q", 9, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_8.q", 8, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_7.q", 7, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_6.q", 6, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_5.q", 5, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_4.q", 4, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_3.q", 3, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_2.q", 2, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_1.q", 1, 1);
         gpio_en_0.add_hdl_path_slice("u_gpio_en_0_gpio_en_0.q", 0, 1);
         gpio_en_0.build();

         gpio_en_1 = gpio_gpio_en_1::type_id::create("gpio_en_1");
         gpio_en_1.configure(this, null, "");
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_55.q", 23, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_54.q", 22, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_53.q", 21, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_52.q", 20, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_51.q", 19, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_50.q", 18, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_49.q", 17, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_48.q", 16, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_47.q", 15, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_46.q", 14, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_45.q", 13, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_44.q", 12, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_43.q", 11, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_42.q", 10, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_41.q", 9, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_40.q", 8, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_39.q", 7, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_38.q", 6, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_37.q", 5, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_36.q", 4, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_35.q", 3, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_34.q", 2, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_33.q", 1, 1);
         gpio_en_1.add_hdl_path_slice("u_gpio_en_1_gpio_en_32.q", 0, 1);
         gpio_en_1.build();

         gpio_in_0 = gpio_gpio_in_0::type_id::create("gpio_in_0");
         gpio_in_0.configure(this, null, "");
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_31.qs", 31, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_30.qs", 30, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_29.qs", 29, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_28.qs", 28, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_27.qs", 27, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_26.qs", 26, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_25.qs", 25, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_24.qs", 24, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_23.qs", 23, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_22.qs", 22, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_21.qs", 21, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_20.qs", 20, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_19.qs", 19, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_18.qs", 18, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_17.qs", 17, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_16.qs", 16, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_15.qs", 15, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_14.qs", 14, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_13.qs", 13, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_12.qs", 12, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_11.qs", 11, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_10.qs", 10, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_9.qs", 9, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_8.qs", 8, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_7.qs", 7, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_6.qs", 6, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_5.qs", 5, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_4.qs", 4, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_3.qs", 3, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_2.qs", 2, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_1.qs", 1, 1);
         gpio_in_0.add_hdl_path_slice("u_gpio_in_0_gpio_in_0.qs", 0, 1);
         gpio_in_0.build();

         gpio_in_1 = gpio_gpio_in_1::type_id::create("gpio_in_1");
         gpio_in_1.configure(this, null, "");
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_55.qs", 23, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_54.qs", 22, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_53.qs", 21, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_52.qs", 20, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_51.qs", 19, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_50.qs", 18, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_49.qs", 17, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_48.qs", 16, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_47.qs", 15, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_46.qs", 14, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_45.qs", 13, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_44.qs", 12, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_43.qs", 11, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_42.qs", 10, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_41.qs", 9, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_40.qs", 8, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_39.qs", 7, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_38.qs", 6, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_37.qs", 5, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_36.qs", 4, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_35.qs", 3, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_34.qs", 2, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_33.qs", 1, 1);
         gpio_in_1.add_hdl_path_slice("u_gpio_in_1_gpio_in_32.qs", 0, 1);
         gpio_in_1.build();

         gpio_out_0 = gpio_gpio_out_0::type_id::create("gpio_out_0");
         gpio_out_0.configure(this, null, "");
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_31.q", 31, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_30.q", 30, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_29.q", 29, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_28.q", 28, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_27.q", 27, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_26.q", 26, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_25.q", 25, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_24.q", 24, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_23.q", 23, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_22.q", 22, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_21.q", 21, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_20.q", 20, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_19.q", 19, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_18.q", 18, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_17.q", 17, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_16.q", 16, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_15.q", 15, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_14.q", 14, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_13.q", 13, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_12.q", 12, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_11.q", 11, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_10.q", 10, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_9.q", 9, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_8.q", 8, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_7.q", 7, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_6.q", 6, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_5.q", 5, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_4.q", 4, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_3.q", 3, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_2.q", 2, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_1.q", 1, 1);
         gpio_out_0.add_hdl_path_slice("u_gpio_out_0_gpio_out_0.q", 0, 1);
         gpio_out_0.build();

         gpio_out_1 = gpio_gpio_out_1::type_id::create("gpio_out_1");
         gpio_out_1.configure(this, null, "");
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_55.q", 23, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_54.q", 22, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_53.q", 21, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_52.q", 20, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_51.q", 19, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_50.q", 18, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_49.q", 17, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_48.q", 16, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_47.q", 15, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_46.q", 14, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_45.q", 13, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_44.q", 12, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_43.q", 11, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_42.q", 10, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_41.q", 9, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_40.q", 8, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_39.q", 7, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_38.q", 6, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_37.q", 5, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_36.q", 4, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_35.q", 3, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_34.q", 2, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_33.q", 1, 1);
         gpio_out_1.add_hdl_path_slice("u_gpio_out_1_gpio_out_32.q", 0, 1);
         gpio_out_1.build();

         gpio_set_0 = gpio_gpio_set_0::type_id::create("gpio_set_0");
         gpio_set_0.configure(this, null, "");
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_31.qs", 31, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_30.qs", 30, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_29.qs", 29, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_28.qs", 28, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_27.qs", 27, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_26.qs", 26, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_25.qs", 25, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_24.qs", 24, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_23.qs", 23, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_22.qs", 22, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_21.qs", 21, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_20.qs", 20, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_19.qs", 19, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_18.qs", 18, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_17.qs", 17, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_16.qs", 16, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_15.qs", 15, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_14.qs", 14, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_13.qs", 13, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_12.qs", 12, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_11.qs", 11, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_10.qs", 10, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_9.qs", 9, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_8.qs", 8, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_7.qs", 7, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_6.qs", 6, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_5.qs", 5, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_4.qs", 4, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_3.qs", 3, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_2.qs", 2, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_1.qs", 1, 1);
         gpio_set_0.add_hdl_path_slice("u_gpio_set_0_gpio_set_0.qs", 0, 1);
         gpio_set_0.build();

         gpio_set_1 = gpio_gpio_set_1::type_id::create("gpio_set_1");
         gpio_set_1.configure(this, null, "");
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_55.qs", 23, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_54.qs", 22, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_53.qs", 21, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_52.qs", 20, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_51.qs", 19, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_50.qs", 18, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_49.qs", 17, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_48.qs", 16, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_47.qs", 15, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_46.qs", 14, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_45.qs", 13, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_44.qs", 12, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_43.qs", 11, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_42.qs", 10, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_41.qs", 9, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_40.qs", 8, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_39.qs", 7, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_38.qs", 6, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_37.qs", 5, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_36.qs", 4, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_35.qs", 3, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_34.qs", 2, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_33.qs", 1, 1);
         gpio_set_1.add_hdl_path_slice("u_gpio_set_1_gpio_set_32.qs", 0, 1);
         gpio_set_1.build();

         gpio_clear_0 = gpio_gpio_clear_0::type_id::create("gpio_clear_0");
         gpio_clear_0.configure(this, null, "");
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_31.qs", 31, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_30.qs", 30, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_29.qs", 29, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_28.qs", 28, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_27.qs", 27, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_26.qs", 26, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_25.qs", 25, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_24.qs", 24, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_23.qs", 23, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_22.qs", 22, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_21.qs", 21, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_20.qs", 20, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_19.qs", 19, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_18.qs", 18, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_17.qs", 17, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_16.qs", 16, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_15.qs", 15, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_14.qs", 14, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_13.qs", 13, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_12.qs", 12, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_11.qs", 11, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_10.qs", 10, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_9.qs", 9, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_8.qs", 8, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_7.qs", 7, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_6.qs", 6, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_5.qs", 5, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_4.qs", 4, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_3.qs", 3, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_2.qs", 2, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_1.qs", 1, 1);
         gpio_clear_0.add_hdl_path_slice("u_gpio_clear_0_gpio_clear_0.qs", 0, 1);
         gpio_clear_0.build();

         gpio_clear_1 = gpio_gpio_clear_1::type_id::create("gpio_clear_1");
         gpio_clear_1.configure(this, null, "");
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_55.qs", 23, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_54.qs", 22, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_53.qs", 21, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_52.qs", 20, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_51.qs", 19, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_50.qs", 18, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_49.qs", 17, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_48.qs", 16, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_47.qs", 15, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_46.qs", 14, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_45.qs", 13, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_44.qs", 12, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_43.qs", 11, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_42.qs", 10, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_41.qs", 9, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_40.qs", 8, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_39.qs", 7, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_38.qs", 6, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_37.qs", 5, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_36.qs", 4, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_35.qs", 3, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_34.qs", 2, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_33.qs", 1, 1);
         gpio_clear_1.add_hdl_path_slice("u_gpio_clear_1_gpio_clear_32.qs", 0, 1);
         gpio_clear_1.build();

         gpio_toggle_0 = gpio_gpio_toggle_0::type_id::create("gpio_toggle_0");
         gpio_toggle_0.configure(this, null, "");
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_31.qs", 31, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_30.qs", 30, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_29.qs", 29, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_28.qs", 28, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_27.qs", 27, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_26.qs", 26, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_25.qs", 25, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_24.qs", 24, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_23.qs", 23, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_22.qs", 22, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_21.qs", 21, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_20.qs", 20, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_19.qs", 19, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_18.qs", 18, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_17.qs", 17, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_16.qs", 16, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_15.qs", 15, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_14.qs", 14, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_13.qs", 13, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_12.qs", 12, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_11.qs", 11, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_10.qs", 10, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_9.qs", 9, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_8.qs", 8, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_7.qs", 7, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_6.qs", 6, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_5.qs", 5, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_4.qs", 4, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_3.qs", 3, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_2.qs", 2, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_1.qs", 1, 1);
         gpio_toggle_0.add_hdl_path_slice("u_gpio_toggle_0_gpio_toggle_0.qs", 0, 1);
         gpio_toggle_0.build();

         gpio_toggle_1 = gpio_gpio_toggle_1::type_id::create("gpio_toggle_1");
         gpio_toggle_1.configure(this, null, "");
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_55.qs", 23, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_54.qs", 22, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_53.qs", 21, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_52.qs", 20, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_51.qs", 19, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_50.qs", 18, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_49.qs", 17, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_48.qs", 16, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_47.qs", 15, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_46.qs", 14, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_45.qs", 13, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_44.qs", 12, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_43.qs", 11, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_42.qs", 10, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_41.qs", 9, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_40.qs", 8, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_39.qs", 7, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_38.qs", 6, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_37.qs", 5, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_36.qs", 4, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_35.qs", 3, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_34.qs", 2, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_33.qs", 1, 1);
         gpio_toggle_1.add_hdl_path_slice("u_gpio_toggle_1_gpio_toggle_32.qs", 0, 1);
         gpio_toggle_1.build();

         intrpt_rise_en_0 = gpio_intrpt_rise_en_0::type_id::create("intrpt_rise_en_0");
         intrpt_rise_en_0.configure(this, null, "");
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_31.q", 31, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_30.q", 30, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_29.q", 29, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_28.q", 28, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_27.q", 27, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_26.q", 26, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_25.q", 25, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_24.q", 24, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_23.q", 23, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_22.q", 22, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_21.q", 21, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_20.q", 20, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_19.q", 19, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_18.q", 18, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_17.q", 17, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_16.q", 16, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_15.q", 15, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_14.q", 14, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_13.q", 13, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_12.q", 12, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_11.q", 11, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_10.q", 10, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_9.q", 9, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_8.q", 8, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_7.q", 7, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_6.q", 6, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_5.q", 5, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_4.q", 4, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_3.q", 3, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_2.q", 2, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_1.q", 1, 1);
         intrpt_rise_en_0.add_hdl_path_slice("u_intrpt_rise_en_0_intrpt_rise_en_0.q", 0, 1);
         intrpt_rise_en_0.build();

         intrpt_rise_en_1 = gpio_intrpt_rise_en_1::type_id::create("intrpt_rise_en_1");
         intrpt_rise_en_1.configure(this, null, "");
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_55.q", 23, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_54.q", 22, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_53.q", 21, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_52.q", 20, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_51.q", 19, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_50.q", 18, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_49.q", 17, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_48.q", 16, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_47.q", 15, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_46.q", 14, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_45.q", 13, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_44.q", 12, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_43.q", 11, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_42.q", 10, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_41.q", 9, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_40.q", 8, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_39.q", 7, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_38.q", 6, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_37.q", 5, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_36.q", 4, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_35.q", 3, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_34.q", 2, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_33.q", 1, 1);
         intrpt_rise_en_1.add_hdl_path_slice("u_intrpt_rise_en_1_intrpt_rise_en_32.q", 0, 1);
         intrpt_rise_en_1.build();

         intrpt_fall_en_0 = gpio_intrpt_fall_en_0::type_id::create("intrpt_fall_en_0");
         intrpt_fall_en_0.configure(this, null, "");
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_31.q", 31, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_30.q", 30, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_29.q", 29, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_28.q", 28, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_27.q", 27, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_26.q", 26, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_25.q", 25, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_24.q", 24, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_23.q", 23, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_22.q", 22, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_21.q", 21, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_20.q", 20, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_19.q", 19, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_18.q", 18, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_17.q", 17, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_16.q", 16, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_15.q", 15, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_14.q", 14, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_13.q", 13, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_12.q", 12, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_11.q", 11, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_10.q", 10, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_9.q", 9, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_8.q", 8, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_7.q", 7, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_6.q", 6, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_5.q", 5, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_4.q", 4, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_3.q", 3, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_2.q", 2, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_1.q", 1, 1);
         intrpt_fall_en_0.add_hdl_path_slice("u_intrpt_fall_en_0_intrpt_fall_en_0.q", 0, 1);
         intrpt_fall_en_0.build();

         intrpt_fall_en_1 = gpio_intrpt_fall_en_1::type_id::create("intrpt_fall_en_1");
         intrpt_fall_en_1.configure(this, null, "");
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_55.q", 23, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_54.q", 22, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_53.q", 21, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_52.q", 20, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_51.q", 19, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_50.q", 18, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_49.q", 17, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_48.q", 16, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_47.q", 15, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_46.q", 14, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_45.q", 13, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_44.q", 12, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_43.q", 11, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_42.q", 10, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_41.q", 9, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_40.q", 8, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_39.q", 7, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_38.q", 6, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_37.q", 5, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_36.q", 4, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_35.q", 3, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_34.q", 2, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_33.q", 1, 1);
         intrpt_fall_en_1.add_hdl_path_slice("u_intrpt_fall_en_1_intrpt_fall_en_32.q", 0, 1);
         intrpt_fall_en_1.build();

         intrpt_lvl_high_en_0 = gpio_intrpt_lvl_high_en_0::type_id::create("intrpt_lvl_high_en_0");
         intrpt_lvl_high_en_0.configure(this, null, "");
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_31.q", 31, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_30.q", 30, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_29.q", 29, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_28.q", 28, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_27.q", 27, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_26.q", 26, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_25.q", 25, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_24.q", 24, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_23.q", 23, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_22.q", 22, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_21.q", 21, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_20.q", 20, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_19.q", 19, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_18.q", 18, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_17.q", 17, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_16.q", 16, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_15.q", 15, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_14.q", 14, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_13.q", 13, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_12.q", 12, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_11.q", 11, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_10.q", 10, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_9.q", 9, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_8.q", 8, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_7.q", 7, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_6.q", 6, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_5.q", 5, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_4.q", 4, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_3.q", 3, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_2.q", 2, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_1.q", 1, 1);
         intrpt_lvl_high_en_0.add_hdl_path_slice("u_intrpt_lvl_high_en_0_intrpt_lvl_high_en_0.q", 0, 1);
         intrpt_lvl_high_en_0.build();

         intrpt_lvl_high_en_1 = gpio_intrpt_lvl_high_en_1::type_id::create("intrpt_lvl_high_en_1");
         intrpt_lvl_high_en_1.configure(this, null, "");
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_55.q", 23, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_54.q", 22, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_53.q", 21, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_52.q", 20, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_51.q", 19, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_50.q", 18, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_49.q", 17, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_48.q", 16, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_47.q", 15, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_46.q", 14, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_45.q", 13, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_44.q", 12, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_43.q", 11, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_42.q", 10, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_41.q", 9, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_40.q", 8, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_39.q", 7, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_38.q", 6, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_37.q", 5, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_36.q", 4, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_35.q", 3, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_34.q", 2, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_33.q", 1, 1);
         intrpt_lvl_high_en_1.add_hdl_path_slice("u_intrpt_lvl_high_en_1_intrpt_lvl_high_en_32.q", 0, 1);
         intrpt_lvl_high_en_1.build();

         intrpt_lvl_low_en_0 = gpio_intrpt_lvl_low_en_0::type_id::create("intrpt_lvl_low_en_0");
         intrpt_lvl_low_en_0.configure(this, null, "");
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_31.q", 31, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_30.q", 30, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_29.q", 29, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_28.q", 28, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_27.q", 27, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_26.q", 26, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_25.q", 25, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_24.q", 24, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_23.q", 23, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_22.q", 22, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_21.q", 21, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_20.q", 20, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_19.q", 19, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_18.q", 18, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_17.q", 17, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_16.q", 16, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_15.q", 15, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_14.q", 14, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_13.q", 13, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_12.q", 12, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_11.q", 11, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_10.q", 10, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_9.q", 9, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_8.q", 8, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_7.q", 7, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_6.q", 6, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_5.q", 5, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_4.q", 4, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_3.q", 3, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_2.q", 2, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_1.q", 1, 1);
         intrpt_lvl_low_en_0.add_hdl_path_slice("u_intrpt_lvl_low_en_0_intrpt_lvl_low_en_0.q", 0, 1);
         intrpt_lvl_low_en_0.build();

         intrpt_lvl_low_en_1 = gpio_intrpt_lvl_low_en_1::type_id::create("intrpt_lvl_low_en_1");
         intrpt_lvl_low_en_1.configure(this, null, "");
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_55.q", 23, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_54.q", 22, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_53.q", 21, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_52.q", 20, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_51.q", 19, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_50.q", 18, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_49.q", 17, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_48.q", 16, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_47.q", 15, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_46.q", 14, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_45.q", 13, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_44.q", 12, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_43.q", 11, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_42.q", 10, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_41.q", 9, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_40.q", 8, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_39.q", 7, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_38.q", 6, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_37.q", 5, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_36.q", 4, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_35.q", 3, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_34.q", 2, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_33.q", 1, 1);
         intrpt_lvl_low_en_1.add_hdl_path_slice("u_intrpt_lvl_low_en_1_intrpt_lvl_low_en_32.q", 0, 1);
         intrpt_lvl_low_en_1.build();

         intrpt_status_0 = gpio_intrpt_status_0::type_id::create("intrpt_status_0");
         intrpt_status_0.configure(this, null, "");
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_31.qs", 31, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_30.qs", 30, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_29.qs", 29, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_28.qs", 28, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_27.qs", 27, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_26.qs", 26, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_25.qs", 25, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_24.qs", 24, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_23.qs", 23, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_22.qs", 22, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_21.qs", 21, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_20.qs", 20, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_19.qs", 19, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_18.qs", 18, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_17.qs", 17, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_16.qs", 16, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_15.qs", 15, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_14.qs", 14, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_13.qs", 13, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_12.qs", 12, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_11.qs", 11, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_10.qs", 10, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_9.qs", 9, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_8.qs", 8, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_7.qs", 7, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_6.qs", 6, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_5.qs", 5, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_4.qs", 4, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_3.qs", 3, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_2.qs", 2, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_1.qs", 1, 1);
         intrpt_status_0.add_hdl_path_slice("u_intrpt_status_0_intrpt_status_0.qs", 0, 1);
         intrpt_status_0.build();

         intrpt_status_1 = gpio_intrpt_status_1::type_id::create("intrpt_status_1");
         intrpt_status_1.configure(this, null, "");
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_55.qs", 23, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_54.qs", 22, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_53.qs", 21, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_52.qs", 20, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_51.qs", 19, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_50.qs", 18, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_49.qs", 17, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_48.qs", 16, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_47.qs", 15, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_46.qs", 14, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_45.qs", 13, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_44.qs", 12, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_43.qs", 11, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_42.qs", 10, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_41.qs", 9, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_40.qs", 8, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_39.qs", 7, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_38.qs", 6, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_37.qs", 5, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_36.qs", 4, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_35.qs", 3, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_34.qs", 2, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_33.qs", 1, 1);
         intrpt_status_1.add_hdl_path_slice("u_intrpt_status_1_intrpt_status_32.qs", 0, 1);
         intrpt_status_1.build();

         intrpt_rise_status_0 = gpio_intrpt_rise_status_0::type_id::create("intrpt_rise_status_0");
         intrpt_rise_status_0.configure(this, null, "");
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_31.q", 31, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_30.q", 30, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_29.q", 29, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_28.q", 28, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_27.q", 27, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_26.q", 26, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_25.q", 25, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_24.q", 24, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_23.q", 23, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_22.q", 22, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_21.q", 21, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_20.q", 20, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_19.q", 19, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_18.q", 18, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_17.q", 17, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_16.q", 16, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_15.q", 15, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_14.q", 14, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_13.q", 13, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_12.q", 12, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_11.q", 11, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_10.q", 10, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_9.q", 9, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_8.q", 8, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_7.q", 7, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_6.q", 6, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_5.q", 5, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_4.q", 4, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_3.q", 3, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_2.q", 2, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_1.q", 1, 1);
         intrpt_rise_status_0.add_hdl_path_slice("u_intrpt_rise_status_0_intrpt_rise_status_0.q", 0, 1);
         intrpt_rise_status_0.build();

         intrpt_rise_status_1 = gpio_intrpt_rise_status_1::type_id::create("intrpt_rise_status_1");
         intrpt_rise_status_1.configure(this, null, "");
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_55.q", 23, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_54.q", 22, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_53.q", 21, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_52.q", 20, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_51.q", 19, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_50.q", 18, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_49.q", 17, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_48.q", 16, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_47.q", 15, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_46.q", 14, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_45.q", 13, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_44.q", 12, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_43.q", 11, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_42.q", 10, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_41.q", 9, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_40.q", 8, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_39.q", 7, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_38.q", 6, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_37.q", 5, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_36.q", 4, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_35.q", 3, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_34.q", 2, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_33.q", 1, 1);
         intrpt_rise_status_1.add_hdl_path_slice("u_intrpt_rise_status_1_intrpt_rise_status_32.q", 0, 1);
         intrpt_rise_status_1.build();

         intrpt_fall_status_0 = gpio_intrpt_fall_status_0::type_id::create("intrpt_fall_status_0");
         intrpt_fall_status_0.configure(this, null, "");
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_31.q", 31, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_30.q", 30, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_29.q", 29, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_28.q", 28, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_27.q", 27, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_26.q", 26, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_25.q", 25, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_24.q", 24, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_23.q", 23, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_22.q", 22, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_21.q", 21, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_20.q", 20, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_19.q", 19, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_18.q", 18, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_17.q", 17, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_16.q", 16, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_15.q", 15, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_14.q", 14, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_13.q", 13, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_12.q", 12, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_11.q", 11, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_10.q", 10, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_9.q", 9, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_8.q", 8, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_7.q", 7, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_6.q", 6, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_5.q", 5, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_4.q", 4, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_3.q", 3, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_2.q", 2, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_1.q", 1, 1);
         intrpt_fall_status_0.add_hdl_path_slice("u_intrpt_fall_status_0_intrpt_fall_status_0.q", 0, 1);
         intrpt_fall_status_0.build();

         intrpt_fall_status_1 = gpio_intrpt_fall_status_1::type_id::create("intrpt_fall_status_1");
         intrpt_fall_status_1.configure(this, null, "");
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_55.q", 23, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_54.q", 22, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_53.q", 21, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_52.q", 20, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_51.q", 19, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_50.q", 18, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_49.q", 17, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_48.q", 16, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_47.q", 15, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_46.q", 14, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_45.q", 13, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_44.q", 12, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_43.q", 11, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_42.q", 10, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_41.q", 9, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_40.q", 8, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_39.q", 7, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_38.q", 6, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_37.q", 5, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_36.q", 4, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_35.q", 3, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_34.q", 2, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_33.q", 1, 1);
         intrpt_fall_status_1.add_hdl_path_slice("u_intrpt_fall_status_1_intrpt_fall_status_32.q", 0, 1);
         intrpt_fall_status_1.build();

         intrpt_lvl_high_status_0 = gpio_intrpt_lvl_high_status_0::type_id::create("intrpt_lvl_high_status_0");
         intrpt_lvl_high_status_0.configure(this, null, "");
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_31.q", 31, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_30.q", 30, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_29.q", 29, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_28.q", 28, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_27.q", 27, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_26.q", 26, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_25.q", 25, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_24.q", 24, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_23.q", 23, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_22.q", 22, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_21.q", 21, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_20.q", 20, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_19.q", 19, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_18.q", 18, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_17.q", 17, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_16.q", 16, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_15.q", 15, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_14.q", 14, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_13.q", 13, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_12.q", 12, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_11.q", 11, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_10.q", 10, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_9.q", 9, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_8.q", 8, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_7.q", 7, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_6.q", 6, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_5.q", 5, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_4.q", 4, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_3.q", 3, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_2.q", 2, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_1.q", 1, 1);
         intrpt_lvl_high_status_0.add_hdl_path_slice("u_intrpt_lvl_high_status_0_intrpt_lvl_high_status_0.q", 0, 1);
         intrpt_lvl_high_status_0.build();

         intrpt_lvl_high_status_1 = gpio_intrpt_lvl_high_status_1::type_id::create("intrpt_lvl_high_status_1");
         intrpt_lvl_high_status_1.configure(this, null, "");
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_55.q", 23, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_54.q", 22, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_53.q", 21, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_52.q", 20, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_51.q", 19, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_50.q", 18, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_49.q", 17, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_48.q", 16, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_47.q", 15, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_46.q", 14, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_45.q", 13, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_44.q", 12, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_43.q", 11, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_42.q", 10, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_41.q", 9, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_40.q", 8, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_39.q", 7, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_38.q", 6, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_37.q", 5, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_36.q", 4, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_35.q", 3, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_34.q", 2, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_33.q", 1, 1);
         intrpt_lvl_high_status_1.add_hdl_path_slice("u_intrpt_lvl_high_status_1_intrpt_lvl_high_status_32.q", 0, 1);
         intrpt_lvl_high_status_1.build();

         intrpt_lvl_low_status_0 = gpio_intrpt_lvl_low_status_0::type_id::create("intrpt_lvl_low_status_0");
         intrpt_lvl_low_status_0.configure(this, null, "");
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_31.q", 31, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_30.q", 30, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_29.q", 29, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_28.q", 28, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_27.q", 27, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_26.q", 26, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_25.q", 25, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_24.q", 24, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_23.q", 23, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_22.q", 22, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_21.q", 21, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_20.q", 20, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_19.q", 19, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_18.q", 18, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_17.q", 17, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_16.q", 16, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_15.q", 15, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_14.q", 14, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_13.q", 13, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_12.q", 12, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_11.q", 11, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_10.q", 10, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_9.q", 9, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_8.q", 8, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_7.q", 7, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_6.q", 6, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_5.q", 5, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_4.q", 4, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_3.q", 3, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_2.q", 2, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_1.q", 1, 1);
         intrpt_lvl_low_status_0.add_hdl_path_slice("u_intrpt_lvl_low_status_0_intrpt_lvl_low_status_0.q", 0, 1);
         intrpt_lvl_low_status_0.build();

         intrpt_lvl_low_status_1 = gpio_intrpt_lvl_low_status_1::type_id::create("intrpt_lvl_low_status_1");
         intrpt_lvl_low_status_1.configure(this, null, "");
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_55.q", 23, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_54.q", 22, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_53.q", 21, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_52.q", 20, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_51.q", 19, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_50.q", 18, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_49.q", 17, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_48.q", 16, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_47.q", 15, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_46.q", 14, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_45.q", 13, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_44.q", 12, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_43.q", 11, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_42.q", 10, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_41.q", 9, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_40.q", 8, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_39.q", 7, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_38.q", 6, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_37.q", 5, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_36.q", 4, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_35.q", 3, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_34.q", 2, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_33.q", 1, 1);
         intrpt_lvl_low_status_1.add_hdl_path_slice("u_intrpt_lvl_low_status_1_intrpt_lvl_low_status_32.q", 0, 1);
         intrpt_lvl_low_status_1.build();

         gpio_map = create_map("gpio_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = gpio_map;

         gpio_map.add_reg(info, 'h0, "RW");
         gpio_map.add_reg(cfg, 'h4, "RW");
         gpio_map.add_reg(gpio_mode_0, 'h8, "RW");
         gpio_map.add_reg(gpio_mode_1, 'hc, "RW");
         gpio_map.add_reg(gpio_mode_2, 'h10, "RW");
         gpio_map.add_reg(gpio_mode_3, 'h14, "RW");
         gpio_map.add_reg(gpio_en_0, 'h80, "RW");
         gpio_map.add_reg(gpio_en_1, 'h84, "RW");
         gpio_map.add_reg(gpio_in_0, 'h100, "RW");
         gpio_map.add_reg(gpio_in_1, 'h104, "RW");
         gpio_map.add_reg(gpio_out_0, 'h180, "RW");
         gpio_map.add_reg(gpio_out_1, 'h184, "RW");
         gpio_map.add_reg(gpio_set_0, 'h200, "RW");
         gpio_map.add_reg(gpio_set_1, 'h204, "RW");
         gpio_map.add_reg(gpio_clear_0, 'h280, "RW");
         gpio_map.add_reg(gpio_clear_1, 'h284, "RW");
         gpio_map.add_reg(gpio_toggle_0, 'h300, "RW");
         gpio_map.add_reg(gpio_toggle_1, 'h304, "RW");
         gpio_map.add_reg(intrpt_rise_en_0, 'h380, "RW");
         gpio_map.add_reg(intrpt_rise_en_1, 'h384, "RW");
         gpio_map.add_reg(intrpt_fall_en_0, 'h400, "RW");
         gpio_map.add_reg(intrpt_fall_en_1, 'h404, "RW");
         gpio_map.add_reg(intrpt_lvl_high_en_0, 'h480, "RW");
         gpio_map.add_reg(intrpt_lvl_high_en_1, 'h484, "RW");
         gpio_map.add_reg(intrpt_lvl_low_en_0, 'h500, "RW");
         gpio_map.add_reg(intrpt_lvl_low_en_1, 'h504, "RW");
         gpio_map.add_reg(intrpt_status_0, 'h580, "RW");
         gpio_map.add_reg(intrpt_status_1, 'h584, "RW");
         gpio_map.add_reg(intrpt_rise_status_0, 'h600, "RW");
         gpio_map.add_reg(intrpt_rise_status_1, 'h604, "RW");
         gpio_map.add_reg(intrpt_fall_status_0, 'h680, "RW");
         gpio_map.add_reg(intrpt_fall_status_1, 'h684, "RW");
         gpio_map.add_reg(intrpt_lvl_high_status_0, 'h700, "RW");
         gpio_map.add_reg(intrpt_lvl_high_status_1, 'h704, "RW");
         gpio_map.add_reg(intrpt_lvl_low_status_0, 'h780, "RW");
         gpio_map.add_reg(intrpt_lvl_low_status_1, 'h784, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pulp_io_block
   // 
   // cpi reg
   //--------------------------------------------------------------------

   class pulp_io_block extends uvm_reg_block;
      `uvm_object_utils(pulp_io_block)

      rand udma_cpi_rx_saddr rx_saddr; // RX Camera uDMA transfer address of associated buffer register
      rand udma_cpi_rx_size rx_size; // RX Camera uDMA transfer size of buffer register



      // Function: new
      // 
      function new(string name = "pulp_io_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         rx_saddr = udma_cpi_rx_saddr::type_id::create("rx_saddr");
         rx_saddr.configure(this, null, "i_udma_subsystem.cpi[0].i_udma_cpi_wrap.i_camera_if.u_reg_if.r_rx_startaddr");
         rx_saddr.build();

         rx_size = udma_cpi_rx_size::type_id::create("rx_size");
         rx_size.configure(this, null, "i_udma_subsystem.cpi[0].i_udma_cpi_wrap.i_camera_if.u_reg_if.cfg_rx_bytes_left_i");
         rx_size.build();

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: soc_peripherals_block
   // 
   // SoC Peripherals
   //--------------------------------------------------------------------

   class soc_peripherals_block extends uvm_reg_block;
      `uvm_object_utils(soc_peripherals_block)

      rand apb_soc_ctrl_block apb_soc_ctrl; // SoC Control Register File
      rand i3c_block i3c0; // I3C0 Config Registers
      rand i3c_block i3c1; // I3C1 Config Registers
      rand gpio_block gpio; // GPIO Registers
      rand pulp_io_block pulp_io; // io peripherals

      uvm_reg_map soc_peripherals_map; 


      // Function: new
      // 
      function new(string name = "soc_peripherals_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         apb_soc_ctrl = apb_soc_ctrl_block::type_id::create("apb_soc_ctrl");
         apb_soc_ctrl.configure(this, "i_apb_soc_ctrl");
         apb_soc_ctrl.build();

         i3c0 = i3c_block::type_id::create("i3c0");
         i3c0.configure(this, "i_i3c0");
         i3c0.build();

         i3c1 = i3c_block::type_id::create("i3c1");
         i3c1.configure(this, "i_i3c1");
         i3c1.build();

         gpio = gpio_block::type_id::create("gpio");
         gpio.configure(this, "i_pulp_io.i_gpio.i_gpio_apb_wrap.i_gpio.i_gpio.i_reg_file");
         gpio.build();

         pulp_io = pulp_io_block::type_id::create("pulp_io");
         pulp_io.configure(this, "i_pulp_io");
         pulp_io.build();

         soc_peripherals_map = create_map("soc_peripherals_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = soc_peripherals_map;

         soc_peripherals_map.add_submap(apb_soc_ctrl.apb_soc_ctrl_map, 'h4000);
         soc_peripherals_map.add_submap(i3c0.i3c_map, 'h20000);
         soc_peripherals_map.add_submap(i3c1.i3c_map, 'h30000);
         soc_peripherals_map.add_submap(gpio.gpio_map, 'h1000);

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: soc_block
   // 
   // SoC Domain
   //--------------------------------------------------------------------

   class soc_block extends uvm_reg_block;
      `uvm_object_utils(soc_block)

      rand soc_peripherals_block soc_peripherals; // SoC Peripherals
      private_bank_soc private_bank0; // Private Bank 0
      private_bank_soc private_bank1; // Private Bank 1
      l2_memory l2_ram; // L2 Memory

      uvm_reg_map soc_map; // SoC address mapping


      // Function: new
      // 
      function new(string name = "soc_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         soc_peripherals = soc_peripherals_block::type_id::create("soc_peripherals");
         soc_peripherals.configure(this, "soc_peripherals_i");
         soc_peripherals.build();

         private_bank0 = private_bank_soc::type_id::create("private_bank0");
         private_bank0.configure(this, "l2_ram_i.bank_sram_pri0_i.sram");

         private_bank1 = private_bank_soc::type_id::create("private_bank1");
         private_bank1.configure(this, "l2_ram_i.bank_sram_pri1_i.sram");

         l2_ram = l2_memory::type_id::create("l2_ram");
         l2_ram.configure(this, "l2_ram_i");

         soc_map = create_map("soc_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = soc_map;

         soc_map.add_submap(soc_peripherals.soc_peripherals_map, 'h1a100000);
         soc_map.add_mem(private_bank0, 'h1c000000, "RW");
         soc_map.add_mem(private_bank1, 'h1c008000, "RW");
         soc_map.add_mem(l2_ram, 'h1c010000, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_memory_config_block
   // 
   //--------------------------------------------------------------------

   class weight_memory_config_block extends uvm_reg_block;
      `uvm_object_utils(weight_memory_config_block)

      rand weight_memory_config_cfg cfg; // Change settings for virtual memory mode of the weight memory
      rand weight_memory_config_vmm_mram_page_idx vmm_mram_page_idx; // Index of the currently stored page in MRAM.
      rand weight_memory_config_vmm_sram_page_idx vmm_sram_page_idx; // Index of the currently stored page in SRAM.
      rand weight_memory_config_vmm_status vmm_status; // Status of virtual memory mode.
      rand weight_memory_config_mram_clk_div mram_clk_div; // Change the clock divider settings of the MRAM banks. The MRAMs are
                                                         // driven with SoC Clock divided by CLK_DIV_CFG*2 (thus even division only).
                                                         // A value of zero bypasses the divider thus directly driving MRAM with SoC clock.
      rand weight_memory_config_mram_bank_pwr_0 mram_bank_pwr_0; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_pwr_1 mram_bank_pwr_1; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_pwr_2 mram_bank_pwr_2; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_pwr_3 mram_bank_pwr_3; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_status_0 mram_bank_status_0; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_status_1 mram_bank_status_1; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_status_2 mram_bank_status_2; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_status_3 mram_bank_status_3; // Change the power state of the individual MRAM banks
      rand weight_memory_config_mram_bank_seq_cfga_0 mram_bank_seq_cfga_0; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfga_1 mram_bank_seq_cfga_1; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfga_2 mram_bank_seq_cfga_2; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfga_3 mram_bank_seq_cfga_3; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfgb_0 mram_bank_seq_cfgb_0; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfgb_1 mram_bank_seq_cfgb_1; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfgb_2 mram_bank_seq_cfgb_2; // Change the power sequencing durations
      rand weight_memory_config_mram_bank_seq_cfgb_3 mram_bank_seq_cfgb_3; // Change the power sequencing durations

      uvm_reg_map weight_memory_config_map; // Default Map


      // Function: new
      // 
      function new(string name = "weight_memory_config_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         cfg = weight_memory_config_cfg::type_id::create("cfg");
         cfg.configure(this, null, "");
         cfg.add_hdl_path_slice("u_cfg_vmm_en.q", 2, 1);
         cfg.add_hdl_path_slice("u_cfg_prio_mode.q", 0, 2);
         cfg.build();

         vmm_mram_page_idx = weight_memory_config_vmm_mram_page_idx::type_id::create("vmm_mram_page_idx");
         vmm_mram_page_idx.configure(this, null, "");
         vmm_mram_page_idx.add_hdl_path_slice("u_vmm_mram_page_idx.q", 0, 10);
         vmm_mram_page_idx.build();

         vmm_sram_page_idx = weight_memory_config_vmm_sram_page_idx::type_id::create("vmm_sram_page_idx");
         vmm_sram_page_idx.configure(this, null, "");
         vmm_sram_page_idx.add_hdl_path_slice("u_vmm_sram_page_idx.q", 0, 10);
         vmm_sram_page_idx.build();

         vmm_status = weight_memory_config_vmm_status::type_id::create("vmm_status");
         vmm_status.configure(this, null, "");
         vmm_status.add_hdl_path_slice("u_vmm_status_vmm_pf_status.qs", 16, 1);
         vmm_status.add_hdl_path_slice("u_vmm_status_vmm_pf_idx.qs", 0, 10);
         vmm_status.build();

         mram_clk_div = weight_memory_config_mram_clk_div::type_id::create("mram_clk_div");
         mram_clk_div.configure(this, null, "");
         mram_clk_div.add_hdl_path_slice("u_mram_clk_div.q", 0, 4);
         mram_clk_div.build();

         mram_bank_pwr_0 = weight_memory_config_mram_bank_pwr_0::type_id::create("mram_bank_pwr_0");
         mram_bank_pwr_0.configure(this, null, "");
         mram_bank_pwr_0.add_hdl_path_slice("u_mram_bank_pwr_0_sleep_en_0.q", 1, 1);
         mram_bank_pwr_0.add_hdl_path_slice("u_mram_bank_pwr_0_pwr_on_0.q", 0, 1);
         mram_bank_pwr_0.build();

         mram_bank_pwr_1 = weight_memory_config_mram_bank_pwr_1::type_id::create("mram_bank_pwr_1");
         mram_bank_pwr_1.configure(this, null, "");
         mram_bank_pwr_1.add_hdl_path_slice("u_mram_bank_pwr_1_sleep_en_1.q", 1, 1);
         mram_bank_pwr_1.add_hdl_path_slice("u_mram_bank_pwr_1_pwr_on_1.q", 0, 1);
         mram_bank_pwr_1.build();

         mram_bank_pwr_2 = weight_memory_config_mram_bank_pwr_2::type_id::create("mram_bank_pwr_2");
         mram_bank_pwr_2.configure(this, null, "");
         mram_bank_pwr_2.add_hdl_path_slice("u_mram_bank_pwr_2_sleep_en_2.q", 1, 1);
         mram_bank_pwr_2.add_hdl_path_slice("u_mram_bank_pwr_2_pwr_on_2.q", 0, 1);
         mram_bank_pwr_2.build();

         mram_bank_pwr_3 = weight_memory_config_mram_bank_pwr_3::type_id::create("mram_bank_pwr_3");
         mram_bank_pwr_3.configure(this, null, "");
         mram_bank_pwr_3.add_hdl_path_slice("u_mram_bank_pwr_3_sleep_en_3.q", 1, 1);
         mram_bank_pwr_3.add_hdl_path_slice("u_mram_bank_pwr_3_pwr_on_3.q", 0, 1);
         mram_bank_pwr_3.build();

         mram_bank_status_0 = weight_memory_config_mram_bank_status_0::type_id::create("mram_bank_status_0");
         mram_bank_status_0.configure(this, null, "");
         mram_bank_status_0.add_hdl_path_slice("u_mram_bank_status_0_status_cut1_0.qs", 4, 4);
         mram_bank_status_0.add_hdl_path_slice("u_mram_bank_status_0_status_cut0_0.qs", 0, 4);
         mram_bank_status_0.build();

         mram_bank_status_1 = weight_memory_config_mram_bank_status_1::type_id::create("mram_bank_status_1");
         mram_bank_status_1.configure(this, null, "");
         mram_bank_status_1.add_hdl_path_slice("u_mram_bank_status_1_status_cut1_1.qs", 4, 4);
         mram_bank_status_1.add_hdl_path_slice("u_mram_bank_status_1_status_cut0_1.qs", 0, 4);
         mram_bank_status_1.build();

         mram_bank_status_2 = weight_memory_config_mram_bank_status_2::type_id::create("mram_bank_status_2");
         mram_bank_status_2.configure(this, null, "");
         mram_bank_status_2.add_hdl_path_slice("u_mram_bank_status_2_status_cut1_2.qs", 4, 4);
         mram_bank_status_2.add_hdl_path_slice("u_mram_bank_status_2_status_cut0_2.qs", 0, 4);
         mram_bank_status_2.build();

         mram_bank_status_3 = weight_memory_config_mram_bank_status_3::type_id::create("mram_bank_status_3");
         mram_bank_status_3.configure(this, null, "");
         mram_bank_status_3.add_hdl_path_slice("u_mram_bank_status_3_status_cut1_3.qs", 4, 4);
         mram_bank_status_3.add_hdl_path_slice("u_mram_bank_status_3_status_cut0_3.qs", 0, 4);
         mram_bank_status_3.build();

         mram_bank_seq_cfga_0 = weight_memory_config_mram_bank_seq_cfga_0::type_id::create("mram_bank_seq_cfga_0");
         mram_bank_seq_cfga_0.configure(this, null, "");
         mram_bank_seq_cfga_0.add_hdl_path_slice("u_mram_bank_seq_cfga_0_ds_dur_0.q", 16, 16);
         mram_bank_seq_cfga_0.add_hdl_path_slice("u_mram_bank_seq_cfga_0_trst_dur_0.q", 0, 16);
         mram_bank_seq_cfga_0.build();

         mram_bank_seq_cfga_1 = weight_memory_config_mram_bank_seq_cfga_1::type_id::create("mram_bank_seq_cfga_1");
         mram_bank_seq_cfga_1.configure(this, null, "");
         mram_bank_seq_cfga_1.add_hdl_path_slice("u_mram_bank_seq_cfga_1_ds_dur_1.q", 16, 16);
         mram_bank_seq_cfga_1.add_hdl_path_slice("u_mram_bank_seq_cfga_1_trst_dur_1.q", 0, 16);
         mram_bank_seq_cfga_1.build();

         mram_bank_seq_cfga_2 = weight_memory_config_mram_bank_seq_cfga_2::type_id::create("mram_bank_seq_cfga_2");
         mram_bank_seq_cfga_2.configure(this, null, "");
         mram_bank_seq_cfga_2.add_hdl_path_slice("u_mram_bank_seq_cfga_2_ds_dur_2.q", 16, 16);
         mram_bank_seq_cfga_2.add_hdl_path_slice("u_mram_bank_seq_cfga_2_trst_dur_2.q", 0, 16);
         mram_bank_seq_cfga_2.build();

         mram_bank_seq_cfga_3 = weight_memory_config_mram_bank_seq_cfga_3::type_id::create("mram_bank_seq_cfga_3");
         mram_bank_seq_cfga_3.configure(this, null, "");
         mram_bank_seq_cfga_3.add_hdl_path_slice("u_mram_bank_seq_cfga_3_ds_dur_3.q", 16, 16);
         mram_bank_seq_cfga_3.add_hdl_path_slice("u_mram_bank_seq_cfga_3_trst_dur_3.q", 0, 16);
         mram_bank_seq_cfga_3.build();

         mram_bank_seq_cfgb_0 = weight_memory_config_mram_bank_seq_cfgb_0::type_id::create("mram_bank_seq_cfgb_0");
         mram_bank_seq_cfgb_0.configure(this, null, "");
         mram_bank_seq_cfgb_0.add_hdl_path_slice("u_mram_bank_seq_cfgb_0.q", 0, 16);
         mram_bank_seq_cfgb_0.build();

         mram_bank_seq_cfgb_1 = weight_memory_config_mram_bank_seq_cfgb_1::type_id::create("mram_bank_seq_cfgb_1");
         mram_bank_seq_cfgb_1.configure(this, null, "");
         mram_bank_seq_cfgb_1.add_hdl_path_slice("u_mram_bank_seq_cfgb_1.q", 0, 16);
         mram_bank_seq_cfgb_1.build();

         mram_bank_seq_cfgb_2 = weight_memory_config_mram_bank_seq_cfgb_2::type_id::create("mram_bank_seq_cfgb_2");
         mram_bank_seq_cfgb_2.configure(this, null, "");
         mram_bank_seq_cfgb_2.add_hdl_path_slice("u_mram_bank_seq_cfgb_2.q", 0, 16);
         mram_bank_seq_cfgb_2.build();

         mram_bank_seq_cfgb_3 = weight_memory_config_mram_bank_seq_cfgb_3::type_id::create("mram_bank_seq_cfgb_3");
         mram_bank_seq_cfgb_3.configure(this, null, "");
         mram_bank_seq_cfgb_3.add_hdl_path_slice("u_mram_bank_seq_cfgb_3.q", 0, 16);
         mram_bank_seq_cfgb_3.build();

         weight_memory_config_map = create_map("weight_memory_config_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = weight_memory_config_map;

         weight_memory_config_map.add_reg(cfg, 'h0, "RW");
         weight_memory_config_map.add_reg(vmm_mram_page_idx, 'h4, "RW");
         weight_memory_config_map.add_reg(vmm_sram_page_idx, 'h8, "RW");
         weight_memory_config_map.add_reg(vmm_status, 'hc, "RW");
         weight_memory_config_map.add_reg(mram_clk_div, 'h10, "RW");
         weight_memory_config_map.add_reg(mram_bank_pwr_0, 'h14, "RW");
         weight_memory_config_map.add_reg(mram_bank_pwr_1, 'h18, "RW");
         weight_memory_config_map.add_reg(mram_bank_pwr_2, 'h1c, "RW");
         weight_memory_config_map.add_reg(mram_bank_pwr_3, 'h20, "RW");
         weight_memory_config_map.add_reg(mram_bank_status_0, 'h24, "RW");
         weight_memory_config_map.add_reg(mram_bank_status_1, 'h28, "RW");
         weight_memory_config_map.add_reg(mram_bank_status_2, 'h2c, "RW");
         weight_memory_config_map.add_reg(mram_bank_status_3, 'h30, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfga_0, 'h34, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfga_1, 'h38, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfga_2, 'h3c, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfga_3, 'h40, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfgb_0, 'h44, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfgb_1, 'h48, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfgb_2, 'h4c, "RW");
         weight_memory_config_map.add_reg(mram_bank_seq_cfgb_3, 'h50, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: weight_mem_block
   // 
   //--------------------------------------------------------------------

   class weight_mem_block extends uvm_reg_block;
      `uvm_object_utils(weight_mem_block)

      rand weight_memory_config_block weight_mem_ctrl; // Control & Status Registers of the Weight Memory Subsystem
      weight_memory weights_mram; // MRAM Weight Memory
      weight_memory weights_sram; // SRAM Weight Memory

      uvm_reg_map weight_mem_map; // Weight Memory Subsystem Mapping


      // Function: new
      // 
      function new(string name = "weight_mem_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         weight_mem_ctrl = weight_memory_config_block::type_id::create("weight_mem_ctrl");
         weight_mem_ctrl.configure(this, "i_regfile");
         weight_mem_ctrl.build();

         weights_mram = weight_memory::type_id::create("weights_mram");
         weights_mram.configure(this);

         weights_sram = weight_memory::type_id::create("weights_sram");
         weights_sram.configure(this);

         weight_mem_map = create_map("weight_mem_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = weight_mem_map;

         weight_mem_map.add_submap(weight_mem_ctrl.weight_memory_config_map, 'hc00000);
         weight_mem_map.add_mem(weights_mram, 'h400000, "RW");
         weight_mem_map.add_mem(weights_sram, 'h800000, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: cluster_block
   // 
   // Cluster Domain
   //--------------------------------------------------------------------

   class cluster_block extends uvm_reg_block;
      `uvm_object_utils(cluster_block)

      rand weight_mem_block weight_mem; // Weight Memory Subsystem
      l1_memory l1_ram; // L1 Memory

      uvm_reg_map cluster_map; // Cluster Address mapping (without cluster offset)


      // Function: new
      // 
      function new(string name = "cluster_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         weight_mem = weight_mem_block::type_id::create("weight_mem");
         weight_mem.configure(this, "i_weight_memory");
         weight_mem.build();

         l1_ram = l1_memory::type_id::create("l1_ram");
         l1_ram.configure(this, "tcdm_banks_i");

         cluster_map = create_map("cluster_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = cluster_map;

         cluster_map.add_submap(weight_mem.weight_mem_map, 'h0);
         cluster_map.add_mem(l1_ram, 'h0, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: pll_config_block
   // 
   //--------------------------------------------------------------------

   class pll_config_block extends uvm_reg_block;
      `uvm_object_utils(pll_config_block)

      rand pll_config_status status; // Status register of the PLL
      rand pll_config_cfg1 cfg1; // Configure general PLL settings
      rand pll_config_cfg2 cfg2; // Configure the target frequency of the PLL. After reset, the PLL starts up at 50 MHz.
      rand pll_config_cfg3 cfg3; // Configure calibration settings of the PLL.

      uvm_reg_map pll_config_map; // Default Map


      // Function: new
      // 
      function new(string name = "pll_config_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         status = pll_config_status::type_id::create("status");
         status.configure(this, null, "");
         status.add_hdl_path_slice("u_status_fcalout.qs", 16, 8);
         status.add_hdl_path_slice("u_status_lock.qs", 0, 1);
         status.build();

         cfg1 = pll_config_cfg1::type_id::create("cfg1");
         cfg1.configure(this, null, "");
         cfg1.add_hdl_path_slice("u_cfg1_lockgate.q", 6, 1);
         cfg1.add_hdl_path_slice("u_cfg1_lockcount.q", 4, 2);
         cfg1.add_hdl_path_slice("u_cfg1_foutvcoen.q", 2, 1);
         cfg1.add_hdl_path_slice("u_cfg1_foutpostdiven.q", 1, 1);
         cfg1.add_hdl_path_slice("u_cfg1_pllen.q", 0, 1);
         cfg1.build();

         cfg2 = pll_config_cfg2::type_id::create("cfg2");
         cfg2.configure(this, null, "");
         cfg2.add_hdl_path_slice("u_cfg2_freq_change_mask_cnt.q", 20, 8);
         cfg2.add_hdl_path_slice("u_cfg2_failsafe_en.q", 19, 1);
         cfg2.add_hdl_path_slice("u_cfg2_vcodivsel.q", 18, 1);
         cfg2.add_hdl_path_slice("u_cfg2_postdiv.q", 14, 4);
         cfg2.add_hdl_path_slice("u_cfg2_fbdiv.q", 0, 14);
         cfg2.build();

         cfg3 = pll_config_cfg3::type_id::create("cfg3");
         cfg3.configure(this, null, "");
         cfg3.add_hdl_path_slice("u_cfg3_fcalbyp.q", 31, 1);
         cfg3.add_hdl_path_slice("u_cfg3_fcaltest.q", 30, 1);
         cfg3.add_hdl_path_slice("u_cfg3_fcalin.q", 0, 8);
         cfg3.build();

         pll_config_map = create_map("pll_config_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = pll_config_map;

         pll_config_map.add_reg(status, 'h0, "RW");
         pll_config_map.add_reg(cfg1, 'h4, "RW");
         pll_config_map.add_reg(cfg2, 'h8, "RW");
         pll_config_map.add_reg(cfg3, 'hc, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_functional_config_block
   // 
   //--------------------------------------------------------------------

   class siracusa_pads_functional_config_block extends uvm_reg_block;
      `uvm_object_utils(siracusa_pads_functional_config_block)

      rand siracusa_pads_functional_config_pad_gpio00_cfg pad_gpio00_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio00_mux_sel pad_gpio00_mux_sel; // Pad signal port multiplex selection for pad pad_gpio00. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio01_cfg pad_gpio01_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio01_mux_sel pad_gpio01_mux_sel; // Pad signal port multiplex selection for pad pad_gpio01. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio02_cfg pad_gpio02_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio02_mux_sel pad_gpio02_mux_sel; // Pad signal port multiplex selection for pad pad_gpio02. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio03_cfg pad_gpio03_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio03_mux_sel pad_gpio03_mux_sel; // Pad signal port multiplex selection for pad pad_gpio03. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio04_cfg pad_gpio04_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio04_mux_sel pad_gpio04_mux_sel; // Pad signal port multiplex selection for pad pad_gpio04. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio05_cfg pad_gpio05_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio05_mux_sel pad_gpio05_mux_sel; // Pad signal port multiplex selection for pad pad_gpio05. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio06_cfg pad_gpio06_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio06_mux_sel pad_gpio06_mux_sel; // Pad signal port multiplex selection for pad pad_gpio06. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio07_cfg pad_gpio07_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio07_mux_sel pad_gpio07_mux_sel; // Pad signal port multiplex selection for pad pad_gpio07. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio08_cfg pad_gpio08_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio08_mux_sel pad_gpio08_mux_sel; // Pad signal port multiplex selection for pad pad_gpio08. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio09_cfg pad_gpio09_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio09_mux_sel pad_gpio09_mux_sel; // Pad signal port multiplex selection for pad pad_gpio09. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio10_cfg pad_gpio10_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio10_mux_sel pad_gpio10_mux_sel; // Pad signal port multiplex selection for pad pad_gpio10. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio11_cfg pad_gpio11_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio11_mux_sel pad_gpio11_mux_sel; // Pad signal port multiplex selection for pad pad_gpio11. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio12_cfg pad_gpio12_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio12_mux_sel pad_gpio12_mux_sel; // Pad signal port multiplex selection for pad pad_gpio12. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio13_cfg pad_gpio13_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio13_mux_sel pad_gpio13_mux_sel; // Pad signal port multiplex selection for pad pad_gpio13. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio14_cfg pad_gpio14_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio14_mux_sel pad_gpio14_mux_sel; // Pad signal port multiplex selection for pad pad_gpio14. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio15_cfg pad_gpio15_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio15_mux_sel pad_gpio15_mux_sel; // Pad signal port multiplex selection for pad pad_gpio15. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio16_cfg pad_gpio16_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio16_mux_sel pad_gpio16_mux_sel; // Pad signal port multiplex selection for pad pad_gpio16. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio17_cfg pad_gpio17_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio17_mux_sel pad_gpio17_mux_sel; // Pad signal port multiplex selection for pad pad_gpio17. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio18_cfg pad_gpio18_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio18_mux_sel pad_gpio18_mux_sel; // Pad signal port multiplex selection for pad pad_gpio18. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio19_cfg pad_gpio19_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio19_mux_sel pad_gpio19_mux_sel; // Pad signal port multiplex selection for pad pad_gpio19. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio20_cfg pad_gpio20_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio20_mux_sel pad_gpio20_mux_sel; // Pad signal port multiplex selection for pad pad_gpio20. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio21_cfg pad_gpio21_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio21_mux_sel pad_gpio21_mux_sel; // Pad signal port multiplex selection for pad pad_gpio21. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio22_cfg pad_gpio22_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio22_mux_sel pad_gpio22_mux_sel; // Pad signal port multiplex selection for pad pad_gpio22. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio23_cfg pad_gpio23_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio23_mux_sel pad_gpio23_mux_sel; // Pad signal port multiplex selection for pad pad_gpio23. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio24_cfg pad_gpio24_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio24_mux_sel pad_gpio24_mux_sel; // Pad signal port multiplex selection for pad pad_gpio24. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio25_cfg pad_gpio25_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio25_mux_sel pad_gpio25_mux_sel; // Pad signal port multiplex selection for pad pad_gpio25. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio26_cfg pad_gpio26_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio26_mux_sel pad_gpio26_mux_sel; // Pad signal port multiplex selection for pad pad_gpio26. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio27_cfg pad_gpio27_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio27_mux_sel pad_gpio27_mux_sel; // Pad signal port multiplex selection for pad pad_gpio27. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio28_cfg pad_gpio28_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio28_mux_sel pad_gpio28_mux_sel; // Pad signal port multiplex selection for pad pad_gpio28. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio29_cfg pad_gpio29_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio29_mux_sel pad_gpio29_mux_sel; // Pad signal port multiplex selection for pad pad_gpio29. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio30_cfg pad_gpio30_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio30_mux_sel pad_gpio30_mux_sel; // Pad signal port multiplex selection for pad pad_gpio30. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio31_cfg pad_gpio31_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio31_mux_sel pad_gpio31_mux_sel; // Pad signal port multiplex selection for pad pad_gpio31. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio32_cfg pad_gpio32_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio32_mux_sel pad_gpio32_mux_sel; // Pad signal port multiplex selection for pad pad_gpio32. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio33_cfg pad_gpio33_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio33_mux_sel pad_gpio33_mux_sel; // Pad signal port multiplex selection for pad pad_gpio33. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio34_cfg pad_gpio34_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio34_mux_sel pad_gpio34_mux_sel; // Pad signal port multiplex selection for pad pad_gpio34. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio35_cfg pad_gpio35_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio35_mux_sel pad_gpio35_mux_sel; // Pad signal port multiplex selection for pad pad_gpio35. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio36_cfg pad_gpio36_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio36_mux_sel pad_gpio36_mux_sel; // Pad signal port multiplex selection for pad pad_gpio36. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio37_cfg pad_gpio37_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio37_mux_sel pad_gpio37_mux_sel; // Pad signal port multiplex selection for pad pad_gpio37. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio38_cfg pad_gpio38_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio38_mux_sel pad_gpio38_mux_sel; // Pad signal port multiplex selection for pad pad_gpio38. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio39_cfg pad_gpio39_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio39_mux_sel pad_gpio39_mux_sel; // Pad signal port multiplex selection for pad pad_gpio39. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio40_cfg pad_gpio40_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio40_mux_sel pad_gpio40_mux_sel; // Pad signal port multiplex selection for pad pad_gpio40. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio41_cfg pad_gpio41_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio41_mux_sel pad_gpio41_mux_sel; // Pad signal port multiplex selection for pad pad_gpio41. The programmed value defines which port
                                                                                 // is connected to the pad.
      rand siracusa_pads_functional_config_pad_gpio42_cfg pad_gpio42_cfg; // Pad signal configuration.
      rand siracusa_pads_functional_config_pad_gpio42_mux_sel pad_gpio42_mux_sel; // Pad signal port multiplex selection for pad pad_gpio42. The programmed value defines which port
                                                                                 // is connected to the pad.

      uvm_reg_map siracusa_pads_functional_config_map; // Default Map


      // Function: new
      // 
      function new(string name = "siracusa_pads_functional_config_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio00_cfg = siracusa_pads_functional_config_pad_gpio00_cfg::type_id::create("pad_gpio00_cfg");
         pad_gpio00_cfg.configure(this, null, "");
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_tx_en.q", 9, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_st_en.q", 8, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_ret_en.q", 7, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_pull_sel.q", 6, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_pull_en.q", 5, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv3.q", 4, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv2.q", 3, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv1.q", 2, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv0.q", 1, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_chip2pad.q", 0, 1);
         pad_gpio00_cfg.build();

         pad_gpio00_mux_sel = siracusa_pads_functional_config_pad_gpio00_mux_sel::type_id::create("pad_gpio00_mux_sel");
         pad_gpio00_mux_sel.configure(this, null, "");
         pad_gpio00_mux_sel.add_hdl_path_slice("u_pad_gpio00_mux_sel.q", 0, 5);
         pad_gpio00_mux_sel.build();

         pad_gpio01_cfg = siracusa_pads_functional_config_pad_gpio01_cfg::type_id::create("pad_gpio01_cfg");
         pad_gpio01_cfg.configure(this, null, "");
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_tx_en.q", 9, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_st_en.q", 8, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_ret_en.q", 7, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_pull_sel.q", 6, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_pull_en.q", 5, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv3.q", 4, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv2.q", 3, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv1.q", 2, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv0.q", 1, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_chip2pad.q", 0, 1);
         pad_gpio01_cfg.build();

         pad_gpio01_mux_sel = siracusa_pads_functional_config_pad_gpio01_mux_sel::type_id::create("pad_gpio01_mux_sel");
         pad_gpio01_mux_sel.configure(this, null, "");
         pad_gpio01_mux_sel.add_hdl_path_slice("u_pad_gpio01_mux_sel.q", 0, 5);
         pad_gpio01_mux_sel.build();

         pad_gpio02_cfg = siracusa_pads_functional_config_pad_gpio02_cfg::type_id::create("pad_gpio02_cfg");
         pad_gpio02_cfg.configure(this, null, "");
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_tx_en.q", 9, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_st_en.q", 8, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_ret_en.q", 7, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_pull_sel.q", 6, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_pull_en.q", 5, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv3.q", 4, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv2.q", 3, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv1.q", 2, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv0.q", 1, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_chip2pad.q", 0, 1);
         pad_gpio02_cfg.build();

         pad_gpio02_mux_sel = siracusa_pads_functional_config_pad_gpio02_mux_sel::type_id::create("pad_gpio02_mux_sel");
         pad_gpio02_mux_sel.configure(this, null, "");
         pad_gpio02_mux_sel.add_hdl_path_slice("u_pad_gpio02_mux_sel.q", 0, 5);
         pad_gpio02_mux_sel.build();

         pad_gpio03_cfg = siracusa_pads_functional_config_pad_gpio03_cfg::type_id::create("pad_gpio03_cfg");
         pad_gpio03_cfg.configure(this, null, "");
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_tx_en.q", 9, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_st_en.q", 8, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_ret_en.q", 7, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_pull_sel.q", 6, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_pull_en.q", 5, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv3.q", 4, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv2.q", 3, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv1.q", 2, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv0.q", 1, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_chip2pad.q", 0, 1);
         pad_gpio03_cfg.build();

         pad_gpio03_mux_sel = siracusa_pads_functional_config_pad_gpio03_mux_sel::type_id::create("pad_gpio03_mux_sel");
         pad_gpio03_mux_sel.configure(this, null, "");
         pad_gpio03_mux_sel.add_hdl_path_slice("u_pad_gpio03_mux_sel.q", 0, 5);
         pad_gpio03_mux_sel.build();

         pad_gpio04_cfg = siracusa_pads_functional_config_pad_gpio04_cfg::type_id::create("pad_gpio04_cfg");
         pad_gpio04_cfg.configure(this, null, "");
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_tx_en.q", 9, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_st_en.q", 8, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_ret_en.q", 7, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_pull_sel.q", 6, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_pull_en.q", 5, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv3.q", 4, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv2.q", 3, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv1.q", 2, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv0.q", 1, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_chip2pad.q", 0, 1);
         pad_gpio04_cfg.build();

         pad_gpio04_mux_sel = siracusa_pads_functional_config_pad_gpio04_mux_sel::type_id::create("pad_gpio04_mux_sel");
         pad_gpio04_mux_sel.configure(this, null, "");
         pad_gpio04_mux_sel.add_hdl_path_slice("u_pad_gpio04_mux_sel.q", 0, 5);
         pad_gpio04_mux_sel.build();

         pad_gpio05_cfg = siracusa_pads_functional_config_pad_gpio05_cfg::type_id::create("pad_gpio05_cfg");
         pad_gpio05_cfg.configure(this, null, "");
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_tx_en.q", 9, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_st_en.q", 8, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_ret_en.q", 7, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_pull_sel.q", 6, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_pull_en.q", 5, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv3.q", 4, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv2.q", 3, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv1.q", 2, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv0.q", 1, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_chip2pad.q", 0, 1);
         pad_gpio05_cfg.build();

         pad_gpio05_mux_sel = siracusa_pads_functional_config_pad_gpio05_mux_sel::type_id::create("pad_gpio05_mux_sel");
         pad_gpio05_mux_sel.configure(this, null, "");
         pad_gpio05_mux_sel.add_hdl_path_slice("u_pad_gpio05_mux_sel.q", 0, 5);
         pad_gpio05_mux_sel.build();

         pad_gpio06_cfg = siracusa_pads_functional_config_pad_gpio06_cfg::type_id::create("pad_gpio06_cfg");
         pad_gpio06_cfg.configure(this, null, "");
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_tx_en.q", 9, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_st_en.q", 8, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_ret_en.q", 7, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_pull_sel.q", 6, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_pull_en.q", 5, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv3.q", 4, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv2.q", 3, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv1.q", 2, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv0.q", 1, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_chip2pad.q", 0, 1);
         pad_gpio06_cfg.build();

         pad_gpio06_mux_sel = siracusa_pads_functional_config_pad_gpio06_mux_sel::type_id::create("pad_gpio06_mux_sel");
         pad_gpio06_mux_sel.configure(this, null, "");
         pad_gpio06_mux_sel.add_hdl_path_slice("u_pad_gpio06_mux_sel.q", 0, 5);
         pad_gpio06_mux_sel.build();

         pad_gpio07_cfg = siracusa_pads_functional_config_pad_gpio07_cfg::type_id::create("pad_gpio07_cfg");
         pad_gpio07_cfg.configure(this, null, "");
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_tx_en.q", 9, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_st_en.q", 8, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_ret_en.q", 7, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_pull_sel.q", 6, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_pull_en.q", 5, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv3.q", 4, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv2.q", 3, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv1.q", 2, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv0.q", 1, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_chip2pad.q", 0, 1);
         pad_gpio07_cfg.build();

         pad_gpio07_mux_sel = siracusa_pads_functional_config_pad_gpio07_mux_sel::type_id::create("pad_gpio07_mux_sel");
         pad_gpio07_mux_sel.configure(this, null, "");
         pad_gpio07_mux_sel.add_hdl_path_slice("u_pad_gpio07_mux_sel.q", 0, 5);
         pad_gpio07_mux_sel.build();

         pad_gpio08_cfg = siracusa_pads_functional_config_pad_gpio08_cfg::type_id::create("pad_gpio08_cfg");
         pad_gpio08_cfg.configure(this, null, "");
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_tx_en.q", 9, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_st_en.q", 8, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_ret_en.q", 7, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_pull_sel.q", 6, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_pull_en.q", 5, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv3.q", 4, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv2.q", 3, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv1.q", 2, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv0.q", 1, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_chip2pad.q", 0, 1);
         pad_gpio08_cfg.build();

         pad_gpio08_mux_sel = siracusa_pads_functional_config_pad_gpio08_mux_sel::type_id::create("pad_gpio08_mux_sel");
         pad_gpio08_mux_sel.configure(this, null, "");
         pad_gpio08_mux_sel.add_hdl_path_slice("u_pad_gpio08_mux_sel.q", 0, 5);
         pad_gpio08_mux_sel.build();

         pad_gpio09_cfg = siracusa_pads_functional_config_pad_gpio09_cfg::type_id::create("pad_gpio09_cfg");
         pad_gpio09_cfg.configure(this, null, "");
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_tx_en.q", 9, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_st_en.q", 8, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_ret_en.q", 7, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_pull_sel.q", 6, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_pull_en.q", 5, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv3.q", 4, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv2.q", 3, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv1.q", 2, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv0.q", 1, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_chip2pad.q", 0, 1);
         pad_gpio09_cfg.build();

         pad_gpio09_mux_sel = siracusa_pads_functional_config_pad_gpio09_mux_sel::type_id::create("pad_gpio09_mux_sel");
         pad_gpio09_mux_sel.configure(this, null, "");
         pad_gpio09_mux_sel.add_hdl_path_slice("u_pad_gpio09_mux_sel.q", 0, 5);
         pad_gpio09_mux_sel.build();

         pad_gpio10_cfg = siracusa_pads_functional_config_pad_gpio10_cfg::type_id::create("pad_gpio10_cfg");
         pad_gpio10_cfg.configure(this, null, "");
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_tx_en.q", 9, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_st_en.q", 8, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_ret_en.q", 7, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_pull_sel.q", 6, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_pull_en.q", 5, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv3.q", 4, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv2.q", 3, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv1.q", 2, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv0.q", 1, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_chip2pad.q", 0, 1);
         pad_gpio10_cfg.build();

         pad_gpio10_mux_sel = siracusa_pads_functional_config_pad_gpio10_mux_sel::type_id::create("pad_gpio10_mux_sel");
         pad_gpio10_mux_sel.configure(this, null, "");
         pad_gpio10_mux_sel.add_hdl_path_slice("u_pad_gpio10_mux_sel.q", 0, 5);
         pad_gpio10_mux_sel.build();

         pad_gpio11_cfg = siracusa_pads_functional_config_pad_gpio11_cfg::type_id::create("pad_gpio11_cfg");
         pad_gpio11_cfg.configure(this, null, "");
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_tx_en.q", 9, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_st_en.q", 8, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_ret_en.q", 7, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_pull_sel.q", 6, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_pull_en.q", 5, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv3.q", 4, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv2.q", 3, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv1.q", 2, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv0.q", 1, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_chip2pad.q", 0, 1);
         pad_gpio11_cfg.build();

         pad_gpio11_mux_sel = siracusa_pads_functional_config_pad_gpio11_mux_sel::type_id::create("pad_gpio11_mux_sel");
         pad_gpio11_mux_sel.configure(this, null, "");
         pad_gpio11_mux_sel.add_hdl_path_slice("u_pad_gpio11_mux_sel.q", 0, 5);
         pad_gpio11_mux_sel.build();

         pad_gpio12_cfg = siracusa_pads_functional_config_pad_gpio12_cfg::type_id::create("pad_gpio12_cfg");
         pad_gpio12_cfg.configure(this, null, "");
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_tx_en.q", 9, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_st_en.q", 8, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_ret_en.q", 7, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_pull_sel.q", 6, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_pull_en.q", 5, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv3.q", 4, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv2.q", 3, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv1.q", 2, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv0.q", 1, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_chip2pad.q", 0, 1);
         pad_gpio12_cfg.build();

         pad_gpio12_mux_sel = siracusa_pads_functional_config_pad_gpio12_mux_sel::type_id::create("pad_gpio12_mux_sel");
         pad_gpio12_mux_sel.configure(this, null, "");
         pad_gpio12_mux_sel.add_hdl_path_slice("u_pad_gpio12_mux_sel.q", 0, 5);
         pad_gpio12_mux_sel.build();

         pad_gpio13_cfg = siracusa_pads_functional_config_pad_gpio13_cfg::type_id::create("pad_gpio13_cfg");
         pad_gpio13_cfg.configure(this, null, "");
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_tx_en.q", 9, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_st_en.q", 8, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_ret_en.q", 7, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_pull_sel.q", 6, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_pull_en.q", 5, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv3.q", 4, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv2.q", 3, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv1.q", 2, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv0.q", 1, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_chip2pad.q", 0, 1);
         pad_gpio13_cfg.build();

         pad_gpio13_mux_sel = siracusa_pads_functional_config_pad_gpio13_mux_sel::type_id::create("pad_gpio13_mux_sel");
         pad_gpio13_mux_sel.configure(this, null, "");
         pad_gpio13_mux_sel.add_hdl_path_slice("u_pad_gpio13_mux_sel.q", 0, 5);
         pad_gpio13_mux_sel.build();

         pad_gpio14_cfg = siracusa_pads_functional_config_pad_gpio14_cfg::type_id::create("pad_gpio14_cfg");
         pad_gpio14_cfg.configure(this, null, "");
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_tx_en.q", 9, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_st_en.q", 8, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_ret_en.q", 7, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_pull_sel.q", 6, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_pull_en.q", 5, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv3.q", 4, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv2.q", 3, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv1.q", 2, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv0.q", 1, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_chip2pad.q", 0, 1);
         pad_gpio14_cfg.build();

         pad_gpio14_mux_sel = siracusa_pads_functional_config_pad_gpio14_mux_sel::type_id::create("pad_gpio14_mux_sel");
         pad_gpio14_mux_sel.configure(this, null, "");
         pad_gpio14_mux_sel.add_hdl_path_slice("u_pad_gpio14_mux_sel.q", 0, 5);
         pad_gpio14_mux_sel.build();

         pad_gpio15_cfg = siracusa_pads_functional_config_pad_gpio15_cfg::type_id::create("pad_gpio15_cfg");
         pad_gpio15_cfg.configure(this, null, "");
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_tx_en.q", 9, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_st_en.q", 8, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_ret_en.q", 7, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_pull_sel.q", 6, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_pull_en.q", 5, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv3.q", 4, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv2.q", 3, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv1.q", 2, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv0.q", 1, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_chip2pad.q", 0, 1);
         pad_gpio15_cfg.build();

         pad_gpio15_mux_sel = siracusa_pads_functional_config_pad_gpio15_mux_sel::type_id::create("pad_gpio15_mux_sel");
         pad_gpio15_mux_sel.configure(this, null, "");
         pad_gpio15_mux_sel.add_hdl_path_slice("u_pad_gpio15_mux_sel.q", 0, 5);
         pad_gpio15_mux_sel.build();

         pad_gpio16_cfg = siracusa_pads_functional_config_pad_gpio16_cfg::type_id::create("pad_gpio16_cfg");
         pad_gpio16_cfg.configure(this, null, "");
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_tx_en.q", 9, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_st_en.q", 8, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_ret_en.q", 7, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_pull_sel.q", 6, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_pull_en.q", 5, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv3.q", 4, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv2.q", 3, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv1.q", 2, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv0.q", 1, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_chip2pad.q", 0, 1);
         pad_gpio16_cfg.build();

         pad_gpio16_mux_sel = siracusa_pads_functional_config_pad_gpio16_mux_sel::type_id::create("pad_gpio16_mux_sel");
         pad_gpio16_mux_sel.configure(this, null, "");
         pad_gpio16_mux_sel.add_hdl_path_slice("u_pad_gpio16_mux_sel.q", 0, 5);
         pad_gpio16_mux_sel.build();

         pad_gpio17_cfg = siracusa_pads_functional_config_pad_gpio17_cfg::type_id::create("pad_gpio17_cfg");
         pad_gpio17_cfg.configure(this, null, "");
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_tx_en.q", 9, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_st_en.q", 8, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_ret_en.q", 7, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_pull_sel.q", 6, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_pull_en.q", 5, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv3.q", 4, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv2.q", 3, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv1.q", 2, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv0.q", 1, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_chip2pad.q", 0, 1);
         pad_gpio17_cfg.build();

         pad_gpio17_mux_sel = siracusa_pads_functional_config_pad_gpio17_mux_sel::type_id::create("pad_gpio17_mux_sel");
         pad_gpio17_mux_sel.configure(this, null, "");
         pad_gpio17_mux_sel.add_hdl_path_slice("u_pad_gpio17_mux_sel.q", 0, 5);
         pad_gpio17_mux_sel.build();

         pad_gpio18_cfg = siracusa_pads_functional_config_pad_gpio18_cfg::type_id::create("pad_gpio18_cfg");
         pad_gpio18_cfg.configure(this, null, "");
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_tx_en.q", 9, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_st_en.q", 8, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_ret_en.q", 7, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_pull_sel.q", 6, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_pull_en.q", 5, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv3.q", 4, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv2.q", 3, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv1.q", 2, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv0.q", 1, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_chip2pad.q", 0, 1);
         pad_gpio18_cfg.build();

         pad_gpio18_mux_sel = siracusa_pads_functional_config_pad_gpio18_mux_sel::type_id::create("pad_gpio18_mux_sel");
         pad_gpio18_mux_sel.configure(this, null, "");
         pad_gpio18_mux_sel.add_hdl_path_slice("u_pad_gpio18_mux_sel.q", 0, 5);
         pad_gpio18_mux_sel.build();

         pad_gpio19_cfg = siracusa_pads_functional_config_pad_gpio19_cfg::type_id::create("pad_gpio19_cfg");
         pad_gpio19_cfg.configure(this, null, "");
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_tx_en.q", 9, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_st_en.q", 8, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_ret_en.q", 7, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_pull_sel.q", 6, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_pull_en.q", 5, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv3.q", 4, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv2.q", 3, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv1.q", 2, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv0.q", 1, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_chip2pad.q", 0, 1);
         pad_gpio19_cfg.build();

         pad_gpio19_mux_sel = siracusa_pads_functional_config_pad_gpio19_mux_sel::type_id::create("pad_gpio19_mux_sel");
         pad_gpio19_mux_sel.configure(this, null, "");
         pad_gpio19_mux_sel.add_hdl_path_slice("u_pad_gpio19_mux_sel.q", 0, 5);
         pad_gpio19_mux_sel.build();

         pad_gpio20_cfg = siracusa_pads_functional_config_pad_gpio20_cfg::type_id::create("pad_gpio20_cfg");
         pad_gpio20_cfg.configure(this, null, "");
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_tx_en.q", 9, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_st_en.q", 8, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_ret_en.q", 7, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_pull_sel.q", 6, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_pull_en.q", 5, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv3.q", 4, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv2.q", 3, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv1.q", 2, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv0.q", 1, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_chip2pad.q", 0, 1);
         pad_gpio20_cfg.build();

         pad_gpio20_mux_sel = siracusa_pads_functional_config_pad_gpio20_mux_sel::type_id::create("pad_gpio20_mux_sel");
         pad_gpio20_mux_sel.configure(this, null, "");
         pad_gpio20_mux_sel.add_hdl_path_slice("u_pad_gpio20_mux_sel.q", 0, 5);
         pad_gpio20_mux_sel.build();

         pad_gpio21_cfg = siracusa_pads_functional_config_pad_gpio21_cfg::type_id::create("pad_gpio21_cfg");
         pad_gpio21_cfg.configure(this, null, "");
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_tx_en.q", 9, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_st_en.q", 8, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_ret_en.q", 7, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_pull_sel.q", 6, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_pull_en.q", 5, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv3.q", 4, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv2.q", 3, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv1.q", 2, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv0.q", 1, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_chip2pad.q", 0, 1);
         pad_gpio21_cfg.build();

         pad_gpio21_mux_sel = siracusa_pads_functional_config_pad_gpio21_mux_sel::type_id::create("pad_gpio21_mux_sel");
         pad_gpio21_mux_sel.configure(this, null, "");
         pad_gpio21_mux_sel.add_hdl_path_slice("u_pad_gpio21_mux_sel.q", 0, 5);
         pad_gpio21_mux_sel.build();

         pad_gpio22_cfg = siracusa_pads_functional_config_pad_gpio22_cfg::type_id::create("pad_gpio22_cfg");
         pad_gpio22_cfg.configure(this, null, "");
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_tx_en.q", 9, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_st_en.q", 8, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_ret_en.q", 7, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_pull_sel.q", 6, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_pull_en.q", 5, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv3.q", 4, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv2.q", 3, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv1.q", 2, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv0.q", 1, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_chip2pad.q", 0, 1);
         pad_gpio22_cfg.build();

         pad_gpio22_mux_sel = siracusa_pads_functional_config_pad_gpio22_mux_sel::type_id::create("pad_gpio22_mux_sel");
         pad_gpio22_mux_sel.configure(this, null, "");
         pad_gpio22_mux_sel.add_hdl_path_slice("u_pad_gpio22_mux_sel.q", 0, 5);
         pad_gpio22_mux_sel.build();

         pad_gpio23_cfg = siracusa_pads_functional_config_pad_gpio23_cfg::type_id::create("pad_gpio23_cfg");
         pad_gpio23_cfg.configure(this, null, "");
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_tx_en.q", 9, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_st_en.q", 8, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_ret_en.q", 7, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_pull_sel.q", 6, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_pull_en.q", 5, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv3.q", 4, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv2.q", 3, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv1.q", 2, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv0.q", 1, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_chip2pad.q", 0, 1);
         pad_gpio23_cfg.build();

         pad_gpio23_mux_sel = siracusa_pads_functional_config_pad_gpio23_mux_sel::type_id::create("pad_gpio23_mux_sel");
         pad_gpio23_mux_sel.configure(this, null, "");
         pad_gpio23_mux_sel.add_hdl_path_slice("u_pad_gpio23_mux_sel.q", 0, 5);
         pad_gpio23_mux_sel.build();

         pad_gpio24_cfg = siracusa_pads_functional_config_pad_gpio24_cfg::type_id::create("pad_gpio24_cfg");
         pad_gpio24_cfg.configure(this, null, "");
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_tx_en.q", 9, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_st_en.q", 8, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_ret_en.q", 7, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_pull_sel.q", 6, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_pull_en.q", 5, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv3.q", 4, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv2.q", 3, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv1.q", 2, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv0.q", 1, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_chip2pad.q", 0, 1);
         pad_gpio24_cfg.build();

         pad_gpio24_mux_sel = siracusa_pads_functional_config_pad_gpio24_mux_sel::type_id::create("pad_gpio24_mux_sel");
         pad_gpio24_mux_sel.configure(this, null, "");
         pad_gpio24_mux_sel.add_hdl_path_slice("u_pad_gpio24_mux_sel.q", 0, 5);
         pad_gpio24_mux_sel.build();

         pad_gpio25_cfg = siracusa_pads_functional_config_pad_gpio25_cfg::type_id::create("pad_gpio25_cfg");
         pad_gpio25_cfg.configure(this, null, "");
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_tx_en.q", 9, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_st_en.q", 8, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_ret_en.q", 7, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_pull_sel.q", 6, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_pull_en.q", 5, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv3.q", 4, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv2.q", 3, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv1.q", 2, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv0.q", 1, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_chip2pad.q", 0, 1);
         pad_gpio25_cfg.build();

         pad_gpio25_mux_sel = siracusa_pads_functional_config_pad_gpio25_mux_sel::type_id::create("pad_gpio25_mux_sel");
         pad_gpio25_mux_sel.configure(this, null, "");
         pad_gpio25_mux_sel.add_hdl_path_slice("u_pad_gpio25_mux_sel.q", 0, 5);
         pad_gpio25_mux_sel.build();

         pad_gpio26_cfg = siracusa_pads_functional_config_pad_gpio26_cfg::type_id::create("pad_gpio26_cfg");
         pad_gpio26_cfg.configure(this, null, "");
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_tx_en.q", 9, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_st_en.q", 8, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_ret_en.q", 7, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_pull_sel.q", 6, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_pull_en.q", 5, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv3.q", 4, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv2.q", 3, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv1.q", 2, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv0.q", 1, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_chip2pad.q", 0, 1);
         pad_gpio26_cfg.build();

         pad_gpio26_mux_sel = siracusa_pads_functional_config_pad_gpio26_mux_sel::type_id::create("pad_gpio26_mux_sel");
         pad_gpio26_mux_sel.configure(this, null, "");
         pad_gpio26_mux_sel.add_hdl_path_slice("u_pad_gpio26_mux_sel.q", 0, 5);
         pad_gpio26_mux_sel.build();

         pad_gpio27_cfg = siracusa_pads_functional_config_pad_gpio27_cfg::type_id::create("pad_gpio27_cfg");
         pad_gpio27_cfg.configure(this, null, "");
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_tx_en.q", 9, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_st_en.q", 8, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_ret_en.q", 7, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_pull_sel.q", 6, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_pull_en.q", 5, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv3.q", 4, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv2.q", 3, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv1.q", 2, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv0.q", 1, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_chip2pad.q", 0, 1);
         pad_gpio27_cfg.build();

         pad_gpio27_mux_sel = siracusa_pads_functional_config_pad_gpio27_mux_sel::type_id::create("pad_gpio27_mux_sel");
         pad_gpio27_mux_sel.configure(this, null, "");
         pad_gpio27_mux_sel.add_hdl_path_slice("u_pad_gpio27_mux_sel.q", 0, 5);
         pad_gpio27_mux_sel.build();

         pad_gpio28_cfg = siracusa_pads_functional_config_pad_gpio28_cfg::type_id::create("pad_gpio28_cfg");
         pad_gpio28_cfg.configure(this, null, "");
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_tx_en.q", 9, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_st_en.q", 8, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_ret_en.q", 7, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_pull_sel.q", 6, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_pull_en.q", 5, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv3.q", 4, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv2.q", 3, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv1.q", 2, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv0.q", 1, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_chip2pad.q", 0, 1);
         pad_gpio28_cfg.build();

         pad_gpio28_mux_sel = siracusa_pads_functional_config_pad_gpio28_mux_sel::type_id::create("pad_gpio28_mux_sel");
         pad_gpio28_mux_sel.configure(this, null, "");
         pad_gpio28_mux_sel.add_hdl_path_slice("u_pad_gpio28_mux_sel.q", 0, 5);
         pad_gpio28_mux_sel.build();

         pad_gpio29_cfg = siracusa_pads_functional_config_pad_gpio29_cfg::type_id::create("pad_gpio29_cfg");
         pad_gpio29_cfg.configure(this, null, "");
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_tx_en.q", 9, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_st_en.q", 8, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_ret_en.q", 7, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_pull_sel.q", 6, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_pull_en.q", 5, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv3.q", 4, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv2.q", 3, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv1.q", 2, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv0.q", 1, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_chip2pad.q", 0, 1);
         pad_gpio29_cfg.build();

         pad_gpio29_mux_sel = siracusa_pads_functional_config_pad_gpio29_mux_sel::type_id::create("pad_gpio29_mux_sel");
         pad_gpio29_mux_sel.configure(this, null, "");
         pad_gpio29_mux_sel.add_hdl_path_slice("u_pad_gpio29_mux_sel.q", 0, 5);
         pad_gpio29_mux_sel.build();

         pad_gpio30_cfg = siracusa_pads_functional_config_pad_gpio30_cfg::type_id::create("pad_gpio30_cfg");
         pad_gpio30_cfg.configure(this, null, "");
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_tx_en.q", 9, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_st_en.q", 8, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_ret_en.q", 7, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_pull_sel.q", 6, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_pull_en.q", 5, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv3.q", 4, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv2.q", 3, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv1.q", 2, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv0.q", 1, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_chip2pad.q", 0, 1);
         pad_gpio30_cfg.build();

         pad_gpio30_mux_sel = siracusa_pads_functional_config_pad_gpio30_mux_sel::type_id::create("pad_gpio30_mux_sel");
         pad_gpio30_mux_sel.configure(this, null, "");
         pad_gpio30_mux_sel.add_hdl_path_slice("u_pad_gpio30_mux_sel.q", 0, 5);
         pad_gpio30_mux_sel.build();

         pad_gpio31_cfg = siracusa_pads_functional_config_pad_gpio31_cfg::type_id::create("pad_gpio31_cfg");
         pad_gpio31_cfg.configure(this, null, "");
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_tx_en.q", 9, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_st_en.q", 8, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_ret_en.q", 7, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_pull_sel.q", 6, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_pull_en.q", 5, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv3.q", 4, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv2.q", 3, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv1.q", 2, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv0.q", 1, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_chip2pad.q", 0, 1);
         pad_gpio31_cfg.build();

         pad_gpio31_mux_sel = siracusa_pads_functional_config_pad_gpio31_mux_sel::type_id::create("pad_gpio31_mux_sel");
         pad_gpio31_mux_sel.configure(this, null, "");
         pad_gpio31_mux_sel.add_hdl_path_slice("u_pad_gpio31_mux_sel.q", 0, 5);
         pad_gpio31_mux_sel.build();

         pad_gpio32_cfg = siracusa_pads_functional_config_pad_gpio32_cfg::type_id::create("pad_gpio32_cfg");
         pad_gpio32_cfg.configure(this, null, "");
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_tx_en.q", 9, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_st_en.q", 8, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_ret_en.q", 7, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_pull_sel.q", 6, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_pull_en.q", 5, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv3.q", 4, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv2.q", 3, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv1.q", 2, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv0.q", 1, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_chip2pad.q", 0, 1);
         pad_gpio32_cfg.build();

         pad_gpio32_mux_sel = siracusa_pads_functional_config_pad_gpio32_mux_sel::type_id::create("pad_gpio32_mux_sel");
         pad_gpio32_mux_sel.configure(this, null, "");
         pad_gpio32_mux_sel.add_hdl_path_slice("u_pad_gpio32_mux_sel.q", 0, 5);
         pad_gpio32_mux_sel.build();

         pad_gpio33_cfg = siracusa_pads_functional_config_pad_gpio33_cfg::type_id::create("pad_gpio33_cfg");
         pad_gpio33_cfg.configure(this, null, "");
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_tx_en.q", 9, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_st_en.q", 8, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_ret_en.q", 7, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_pull_sel.q", 6, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_pull_en.q", 5, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv3.q", 4, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv2.q", 3, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv1.q", 2, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv0.q", 1, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_chip2pad.q", 0, 1);
         pad_gpio33_cfg.build();

         pad_gpio33_mux_sel = siracusa_pads_functional_config_pad_gpio33_mux_sel::type_id::create("pad_gpio33_mux_sel");
         pad_gpio33_mux_sel.configure(this, null, "");
         pad_gpio33_mux_sel.add_hdl_path_slice("u_pad_gpio33_mux_sel.q", 0, 5);
         pad_gpio33_mux_sel.build();

         pad_gpio34_cfg = siracusa_pads_functional_config_pad_gpio34_cfg::type_id::create("pad_gpio34_cfg");
         pad_gpio34_cfg.configure(this, null, "");
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_tx_en.q", 9, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_st_en.q", 8, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_ret_en.q", 7, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_pull_sel.q", 6, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_pull_en.q", 5, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv3.q", 4, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv2.q", 3, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv1.q", 2, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv0.q", 1, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_chip2pad.q", 0, 1);
         pad_gpio34_cfg.build();

         pad_gpio34_mux_sel = siracusa_pads_functional_config_pad_gpio34_mux_sel::type_id::create("pad_gpio34_mux_sel");
         pad_gpio34_mux_sel.configure(this, null, "");
         pad_gpio34_mux_sel.add_hdl_path_slice("u_pad_gpio34_mux_sel.q", 0, 5);
         pad_gpio34_mux_sel.build();

         pad_gpio35_cfg = siracusa_pads_functional_config_pad_gpio35_cfg::type_id::create("pad_gpio35_cfg");
         pad_gpio35_cfg.configure(this, null, "");
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_tx_en.q", 9, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_st_en.q", 8, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_ret_en.q", 7, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_pull_sel.q", 6, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_pull_en.q", 5, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv3.q", 4, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv2.q", 3, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv1.q", 2, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv0.q", 1, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_chip2pad.q", 0, 1);
         pad_gpio35_cfg.build();

         pad_gpio35_mux_sel = siracusa_pads_functional_config_pad_gpio35_mux_sel::type_id::create("pad_gpio35_mux_sel");
         pad_gpio35_mux_sel.configure(this, null, "");
         pad_gpio35_mux_sel.add_hdl_path_slice("u_pad_gpio35_mux_sel.q", 0, 5);
         pad_gpio35_mux_sel.build();

         pad_gpio36_cfg = siracusa_pads_functional_config_pad_gpio36_cfg::type_id::create("pad_gpio36_cfg");
         pad_gpio36_cfg.configure(this, null, "");
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_tx_en.q", 9, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_st_en.q", 8, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_ret_en.q", 7, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_pull_sel.q", 6, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_pull_en.q", 5, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv3.q", 4, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv2.q", 3, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv1.q", 2, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv0.q", 1, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_chip2pad.q", 0, 1);
         pad_gpio36_cfg.build();

         pad_gpio36_mux_sel = siracusa_pads_functional_config_pad_gpio36_mux_sel::type_id::create("pad_gpio36_mux_sel");
         pad_gpio36_mux_sel.configure(this, null, "");
         pad_gpio36_mux_sel.add_hdl_path_slice("u_pad_gpio36_mux_sel.q", 0, 5);
         pad_gpio36_mux_sel.build();

         pad_gpio37_cfg = siracusa_pads_functional_config_pad_gpio37_cfg::type_id::create("pad_gpio37_cfg");
         pad_gpio37_cfg.configure(this, null, "");
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_tx_en.q", 9, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_st_en.q", 8, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_ret_en.q", 7, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_pull_sel.q", 6, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_pull_en.q", 5, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv3.q", 4, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv2.q", 3, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv1.q", 2, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv0.q", 1, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_chip2pad.q", 0, 1);
         pad_gpio37_cfg.build();

         pad_gpio37_mux_sel = siracusa_pads_functional_config_pad_gpio37_mux_sel::type_id::create("pad_gpio37_mux_sel");
         pad_gpio37_mux_sel.configure(this, null, "");
         pad_gpio37_mux_sel.add_hdl_path_slice("u_pad_gpio37_mux_sel.q", 0, 5);
         pad_gpio37_mux_sel.build();

         pad_gpio38_cfg = siracusa_pads_functional_config_pad_gpio38_cfg::type_id::create("pad_gpio38_cfg");
         pad_gpio38_cfg.configure(this, null, "");
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_tx_en.q", 9, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_st_en.q", 8, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_ret_en.q", 7, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_pull_sel.q", 6, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_pull_en.q", 5, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv3.q", 4, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv2.q", 3, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv1.q", 2, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv0.q", 1, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_chip2pad.q", 0, 1);
         pad_gpio38_cfg.build();

         pad_gpio38_mux_sel = siracusa_pads_functional_config_pad_gpio38_mux_sel::type_id::create("pad_gpio38_mux_sel");
         pad_gpio38_mux_sel.configure(this, null, "");
         pad_gpio38_mux_sel.add_hdl_path_slice("u_pad_gpio38_mux_sel.q", 0, 5);
         pad_gpio38_mux_sel.build();

         pad_gpio39_cfg = siracusa_pads_functional_config_pad_gpio39_cfg::type_id::create("pad_gpio39_cfg");
         pad_gpio39_cfg.configure(this, null, "");
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_tx_en.q", 9, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_st_en.q", 8, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_ret_en.q", 7, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_pull_sel.q", 6, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_pull_en.q", 5, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv3.q", 4, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv2.q", 3, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv1.q", 2, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv0.q", 1, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_chip2pad.q", 0, 1);
         pad_gpio39_cfg.build();

         pad_gpio39_mux_sel = siracusa_pads_functional_config_pad_gpio39_mux_sel::type_id::create("pad_gpio39_mux_sel");
         pad_gpio39_mux_sel.configure(this, null, "");
         pad_gpio39_mux_sel.add_hdl_path_slice("u_pad_gpio39_mux_sel.q", 0, 5);
         pad_gpio39_mux_sel.build();

         pad_gpio40_cfg = siracusa_pads_functional_config_pad_gpio40_cfg::type_id::create("pad_gpio40_cfg");
         pad_gpio40_cfg.configure(this, null, "");
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_tx_en.q", 9, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_st_en.q", 8, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_ret_en.q", 7, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_pull_sel.q", 6, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_pull_en.q", 5, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv3.q", 4, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv2.q", 3, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv1.q", 2, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv0.q", 1, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_chip2pad.q", 0, 1);
         pad_gpio40_cfg.build();

         pad_gpio40_mux_sel = siracusa_pads_functional_config_pad_gpio40_mux_sel::type_id::create("pad_gpio40_mux_sel");
         pad_gpio40_mux_sel.configure(this, null, "");
         pad_gpio40_mux_sel.add_hdl_path_slice("u_pad_gpio40_mux_sel.q", 0, 5);
         pad_gpio40_mux_sel.build();

         pad_gpio41_cfg = siracusa_pads_functional_config_pad_gpio41_cfg::type_id::create("pad_gpio41_cfg");
         pad_gpio41_cfg.configure(this, null, "");
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_tx_en.q", 9, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_st_en.q", 8, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_ret_en.q", 7, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_pull_sel.q", 6, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_pull_en.q", 5, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv3.q", 4, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv2.q", 3, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv1.q", 2, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv0.q", 1, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_chip2pad.q", 0, 1);
         pad_gpio41_cfg.build();

         pad_gpio41_mux_sel = siracusa_pads_functional_config_pad_gpio41_mux_sel::type_id::create("pad_gpio41_mux_sel");
         pad_gpio41_mux_sel.configure(this, null, "");
         pad_gpio41_mux_sel.add_hdl_path_slice("u_pad_gpio41_mux_sel.q", 0, 5);
         pad_gpio41_mux_sel.build();

         pad_gpio42_cfg = siracusa_pads_functional_config_pad_gpio42_cfg::type_id::create("pad_gpio42_cfg");
         pad_gpio42_cfg.configure(this, null, "");
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_tx_en.q", 9, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_st_en.q", 8, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_ret_en.q", 7, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_pull_sel.q", 6, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_pull_en.q", 5, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv3.q", 4, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv2.q", 3, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv1.q", 2, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv0.q", 1, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_chip2pad.q", 0, 1);
         pad_gpio42_cfg.build();

         pad_gpio42_mux_sel = siracusa_pads_functional_config_pad_gpio42_mux_sel::type_id::create("pad_gpio42_mux_sel");
         pad_gpio42_mux_sel.configure(this, null, "");
         pad_gpio42_mux_sel.add_hdl_path_slice("u_pad_gpio42_mux_sel.q", 0, 5);
         pad_gpio42_mux_sel.build();

         siracusa_pads_functional_config_map = create_map("siracusa_pads_functional_config_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = siracusa_pads_functional_config_map;

         siracusa_pads_functional_config_map.add_reg(pad_gpio00_cfg, 'h0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio00_mux_sel, 'h4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio01_cfg, 'h8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio01_mux_sel, 'hc, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio02_cfg, 'h10, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio02_mux_sel, 'h14, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio03_cfg, 'h18, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio03_mux_sel, 'h1c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio04_cfg, 'h20, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio04_mux_sel, 'h24, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio05_cfg, 'h28, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio05_mux_sel, 'h2c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio06_cfg, 'h30, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio06_mux_sel, 'h34, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio07_cfg, 'h38, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio07_mux_sel, 'h3c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio08_cfg, 'h40, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio08_mux_sel, 'h44, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio09_cfg, 'h48, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio09_mux_sel, 'h4c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio10_cfg, 'h50, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio10_mux_sel, 'h54, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio11_cfg, 'h58, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio11_mux_sel, 'h5c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio12_cfg, 'h60, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio12_mux_sel, 'h64, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio13_cfg, 'h68, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio13_mux_sel, 'h6c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio14_cfg, 'h70, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio14_mux_sel, 'h74, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio15_cfg, 'h78, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio15_mux_sel, 'h7c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio16_cfg, 'h80, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio16_mux_sel, 'h84, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio17_cfg, 'h88, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio17_mux_sel, 'h8c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio18_cfg, 'h90, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio18_mux_sel, 'h94, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio19_cfg, 'h98, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio19_mux_sel, 'h9c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio20_cfg, 'ha0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio20_mux_sel, 'ha4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio21_cfg, 'ha8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio21_mux_sel, 'hac, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio22_cfg, 'hb0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio22_mux_sel, 'hb4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio23_cfg, 'hb8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio23_mux_sel, 'hbc, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio24_cfg, 'hc0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio24_mux_sel, 'hc4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio25_cfg, 'hc8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio25_mux_sel, 'hcc, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio26_cfg, 'hd0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio26_mux_sel, 'hd4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio27_cfg, 'hd8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio27_mux_sel, 'hdc, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio28_cfg, 'he0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio28_mux_sel, 'he4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio29_cfg, 'he8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio29_mux_sel, 'hec, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio30_cfg, 'hf0, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio30_mux_sel, 'hf4, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio31_cfg, 'hf8, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio31_mux_sel, 'hfc, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio32_cfg, 'h100, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio32_mux_sel, 'h104, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio33_cfg, 'h108, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio33_mux_sel, 'h10c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio34_cfg, 'h110, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio34_mux_sel, 'h114, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio35_cfg, 'h118, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio35_mux_sel, 'h11c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio36_cfg, 'h120, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio36_mux_sel, 'h124, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio37_cfg, 'h128, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio37_mux_sel, 'h12c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio38_cfg, 'h130, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio38_mux_sel, 'h134, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio39_cfg, 'h138, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio39_mux_sel, 'h13c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio40_cfg, 'h140, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio40_mux_sel, 'h144, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio41_cfg, 'h148, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio41_mux_sel, 'h14c, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio42_cfg, 'h150, "RW");
         siracusa_pads_functional_config_map.add_reg(pad_gpio42_mux_sel, 'h154, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_pads_debug_config_block
   // 
   //--------------------------------------------------------------------

   class siracusa_pads_debug_config_block extends uvm_reg_block;
      `uvm_object_utils(siracusa_pads_debug_config_block)

      rand siracusa_pads_debug_config_pad_gpio00_cfg pad_gpio00_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio00_mux_sel pad_gpio00_mux_sel; // Pad signal port multiplex selection for pad pad_gpio00. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio01_cfg pad_gpio01_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio01_mux_sel pad_gpio01_mux_sel; // Pad signal port multiplex selection for pad pad_gpio01. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio02_cfg pad_gpio02_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio02_mux_sel pad_gpio02_mux_sel; // Pad signal port multiplex selection for pad pad_gpio02. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio03_cfg pad_gpio03_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio03_mux_sel pad_gpio03_mux_sel; // Pad signal port multiplex selection for pad pad_gpio03. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio04_cfg pad_gpio04_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio04_mux_sel pad_gpio04_mux_sel; // Pad signal port multiplex selection for pad pad_gpio04. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio05_cfg pad_gpio05_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio05_mux_sel pad_gpio05_mux_sel; // Pad signal port multiplex selection for pad pad_gpio05. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio06_cfg pad_gpio06_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio06_mux_sel pad_gpio06_mux_sel; // Pad signal port multiplex selection for pad pad_gpio06. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio07_cfg pad_gpio07_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio07_mux_sel pad_gpio07_mux_sel; // Pad signal port multiplex selection for pad pad_gpio07. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio08_cfg pad_gpio08_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio08_mux_sel pad_gpio08_mux_sel; // Pad signal port multiplex selection for pad pad_gpio08. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio09_cfg pad_gpio09_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio09_mux_sel pad_gpio09_mux_sel; // Pad signal port multiplex selection for pad pad_gpio09. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio10_cfg pad_gpio10_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio10_mux_sel pad_gpio10_mux_sel; // Pad signal port multiplex selection for pad pad_gpio10. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio11_cfg pad_gpio11_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio11_mux_sel pad_gpio11_mux_sel; // Pad signal port multiplex selection for pad pad_gpio11. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio12_cfg pad_gpio12_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio12_mux_sel pad_gpio12_mux_sel; // Pad signal port multiplex selection for pad pad_gpio12. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio13_cfg pad_gpio13_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio13_mux_sel pad_gpio13_mux_sel; // Pad signal port multiplex selection for pad pad_gpio13. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio14_cfg pad_gpio14_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio14_mux_sel pad_gpio14_mux_sel; // Pad signal port multiplex selection for pad pad_gpio14. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio15_cfg pad_gpio15_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio15_mux_sel pad_gpio15_mux_sel; // Pad signal port multiplex selection for pad pad_gpio15. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio16_cfg pad_gpio16_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio16_mux_sel pad_gpio16_mux_sel; // Pad signal port multiplex selection for pad pad_gpio16. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio17_cfg pad_gpio17_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio17_mux_sel pad_gpio17_mux_sel; // Pad signal port multiplex selection for pad pad_gpio17. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio18_cfg pad_gpio18_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio18_mux_sel pad_gpio18_mux_sel; // Pad signal port multiplex selection for pad pad_gpio18. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio19_cfg pad_gpio19_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio19_mux_sel pad_gpio19_mux_sel; // Pad signal port multiplex selection for pad pad_gpio19. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio20_cfg pad_gpio20_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio20_mux_sel pad_gpio20_mux_sel; // Pad signal port multiplex selection for pad pad_gpio20. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio21_cfg pad_gpio21_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio21_mux_sel pad_gpio21_mux_sel; // Pad signal port multiplex selection for pad pad_gpio21. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio22_cfg pad_gpio22_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio22_mux_sel pad_gpio22_mux_sel; // Pad signal port multiplex selection for pad pad_gpio22. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio23_cfg pad_gpio23_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio23_mux_sel pad_gpio23_mux_sel; // Pad signal port multiplex selection for pad pad_gpio23. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio24_cfg pad_gpio24_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio24_mux_sel pad_gpio24_mux_sel; // Pad signal port multiplex selection for pad pad_gpio24. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio25_cfg pad_gpio25_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio25_mux_sel pad_gpio25_mux_sel; // Pad signal port multiplex selection for pad pad_gpio25. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio26_cfg pad_gpio26_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio26_mux_sel pad_gpio26_mux_sel; // Pad signal port multiplex selection for pad pad_gpio26. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio27_cfg pad_gpio27_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio27_mux_sel pad_gpio27_mux_sel; // Pad signal port multiplex selection for pad pad_gpio27. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio28_cfg pad_gpio28_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio28_mux_sel pad_gpio28_mux_sel; // Pad signal port multiplex selection for pad pad_gpio28. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio29_cfg pad_gpio29_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio29_mux_sel pad_gpio29_mux_sel; // Pad signal port multiplex selection for pad pad_gpio29. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio30_cfg pad_gpio30_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio30_mux_sel pad_gpio30_mux_sel; // Pad signal port multiplex selection for pad pad_gpio30. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio31_cfg pad_gpio31_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio31_mux_sel pad_gpio31_mux_sel; // Pad signal port multiplex selection for pad pad_gpio31. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio32_cfg pad_gpio32_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio32_mux_sel pad_gpio32_mux_sel; // Pad signal port multiplex selection for pad pad_gpio32. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio33_cfg pad_gpio33_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio33_mux_sel pad_gpio33_mux_sel; // Pad signal port multiplex selection for pad pad_gpio33. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio34_cfg pad_gpio34_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio34_mux_sel pad_gpio34_mux_sel; // Pad signal port multiplex selection for pad pad_gpio34. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio35_cfg pad_gpio35_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio35_mux_sel pad_gpio35_mux_sel; // Pad signal port multiplex selection for pad pad_gpio35. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio36_cfg pad_gpio36_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio36_mux_sel pad_gpio36_mux_sel; // Pad signal port multiplex selection for pad pad_gpio36. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio37_cfg pad_gpio37_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio37_mux_sel pad_gpio37_mux_sel; // Pad signal port multiplex selection for pad pad_gpio37. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio38_cfg pad_gpio38_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio38_mux_sel pad_gpio38_mux_sel; // Pad signal port multiplex selection for pad pad_gpio38. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio39_cfg pad_gpio39_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio39_mux_sel pad_gpio39_mux_sel; // Pad signal port multiplex selection for pad pad_gpio39. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio40_cfg pad_gpio40_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio40_mux_sel pad_gpio40_mux_sel; // Pad signal port multiplex selection for pad pad_gpio40. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio41_cfg pad_gpio41_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio41_mux_sel pad_gpio41_mux_sel; // Pad signal port multiplex selection for pad pad_gpio41. The programmed value defines which port
                                                                           // is connected to the pad.
      rand siracusa_pads_debug_config_pad_gpio42_cfg pad_gpio42_cfg; // Pad signal configuration.
      rand siracusa_pads_debug_config_pad_gpio42_mux_sel pad_gpio42_mux_sel; // Pad signal port multiplex selection for pad pad_gpio42. The programmed value defines which port
                                                                           // is connected to the pad.

      uvm_reg_map siracusa_pads_debug_config_map; // Default Map


      // Function: new
      // 
      function new(string name = "siracusa_pads_debug_config_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_gpio00_cfg = siracusa_pads_debug_config_pad_gpio00_cfg::type_id::create("pad_gpio00_cfg");
         pad_gpio00_cfg.configure(this, null, "");
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_tx_en.q", 9, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_st_en.q", 8, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_ret_en.q", 7, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_pull_sel.q", 6, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_pull_en.q", 5, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv3.q", 4, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv2.q", 3, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv1.q", 2, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_drv0.q", 1, 1);
         pad_gpio00_cfg.add_hdl_path_slice("u_pad_gpio00_cfg_chip2pad.q", 0, 1);
         pad_gpio00_cfg.build();

         pad_gpio00_mux_sel = siracusa_pads_debug_config_pad_gpio00_mux_sel::type_id::create("pad_gpio00_mux_sel");
         pad_gpio00_mux_sel.configure(this, null, "");
         pad_gpio00_mux_sel.add_hdl_path_slice("u_pad_gpio00_mux_sel.q", 0, 4);
         pad_gpio00_mux_sel.build();

         pad_gpio01_cfg = siracusa_pads_debug_config_pad_gpio01_cfg::type_id::create("pad_gpio01_cfg");
         pad_gpio01_cfg.configure(this, null, "");
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_tx_en.q", 9, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_st_en.q", 8, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_ret_en.q", 7, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_pull_sel.q", 6, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_pull_en.q", 5, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv3.q", 4, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv2.q", 3, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv1.q", 2, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_drv0.q", 1, 1);
         pad_gpio01_cfg.add_hdl_path_slice("u_pad_gpio01_cfg_chip2pad.q", 0, 1);
         pad_gpio01_cfg.build();

         pad_gpio01_mux_sel = siracusa_pads_debug_config_pad_gpio01_mux_sel::type_id::create("pad_gpio01_mux_sel");
         pad_gpio01_mux_sel.configure(this, null, "");
         pad_gpio01_mux_sel.add_hdl_path_slice("u_pad_gpio01_mux_sel.q", 0, 4);
         pad_gpio01_mux_sel.build();

         pad_gpio02_cfg = siracusa_pads_debug_config_pad_gpio02_cfg::type_id::create("pad_gpio02_cfg");
         pad_gpio02_cfg.configure(this, null, "");
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_tx_en.q", 9, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_st_en.q", 8, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_ret_en.q", 7, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_pull_sel.q", 6, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_pull_en.q", 5, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv3.q", 4, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv2.q", 3, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv1.q", 2, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_drv0.q", 1, 1);
         pad_gpio02_cfg.add_hdl_path_slice("u_pad_gpio02_cfg_chip2pad.q", 0, 1);
         pad_gpio02_cfg.build();

         pad_gpio02_mux_sel = siracusa_pads_debug_config_pad_gpio02_mux_sel::type_id::create("pad_gpio02_mux_sel");
         pad_gpio02_mux_sel.configure(this, null, "");
         pad_gpio02_mux_sel.add_hdl_path_slice("u_pad_gpio02_mux_sel.q", 0, 4);
         pad_gpio02_mux_sel.build();

         pad_gpio03_cfg = siracusa_pads_debug_config_pad_gpio03_cfg::type_id::create("pad_gpio03_cfg");
         pad_gpio03_cfg.configure(this, null, "");
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_tx_en.q", 9, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_st_en.q", 8, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_ret_en.q", 7, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_pull_sel.q", 6, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_pull_en.q", 5, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv3.q", 4, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv2.q", 3, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv1.q", 2, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_drv0.q", 1, 1);
         pad_gpio03_cfg.add_hdl_path_slice("u_pad_gpio03_cfg_chip2pad.q", 0, 1);
         pad_gpio03_cfg.build();

         pad_gpio03_mux_sel = siracusa_pads_debug_config_pad_gpio03_mux_sel::type_id::create("pad_gpio03_mux_sel");
         pad_gpio03_mux_sel.configure(this, null, "");
         pad_gpio03_mux_sel.add_hdl_path_slice("u_pad_gpio03_mux_sel.q", 0, 2);
         pad_gpio03_mux_sel.build();

         pad_gpio04_cfg = siracusa_pads_debug_config_pad_gpio04_cfg::type_id::create("pad_gpio04_cfg");
         pad_gpio04_cfg.configure(this, null, "");
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_tx_en.q", 9, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_st_en.q", 8, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_ret_en.q", 7, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_pull_sel.q", 6, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_pull_en.q", 5, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv3.q", 4, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv2.q", 3, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv1.q", 2, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_drv0.q", 1, 1);
         pad_gpio04_cfg.add_hdl_path_slice("u_pad_gpio04_cfg_chip2pad.q", 0, 1);
         pad_gpio04_cfg.build();

         pad_gpio04_mux_sel = siracusa_pads_debug_config_pad_gpio04_mux_sel::type_id::create("pad_gpio04_mux_sel");
         pad_gpio04_mux_sel.configure(this, null, "");
         pad_gpio04_mux_sel.add_hdl_path_slice("u_pad_gpio04_mux_sel.q", 0, 2);
         pad_gpio04_mux_sel.build();

         pad_gpio05_cfg = siracusa_pads_debug_config_pad_gpio05_cfg::type_id::create("pad_gpio05_cfg");
         pad_gpio05_cfg.configure(this, null, "");
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_tx_en.q", 9, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_st_en.q", 8, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_ret_en.q", 7, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_pull_sel.q", 6, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_pull_en.q", 5, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv3.q", 4, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv2.q", 3, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv1.q", 2, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_drv0.q", 1, 1);
         pad_gpio05_cfg.add_hdl_path_slice("u_pad_gpio05_cfg_chip2pad.q", 0, 1);
         pad_gpio05_cfg.build();

         pad_gpio05_mux_sel = siracusa_pads_debug_config_pad_gpio05_mux_sel::type_id::create("pad_gpio05_mux_sel");
         pad_gpio05_mux_sel.configure(this, null, "");
         pad_gpio05_mux_sel.add_hdl_path_slice("u_pad_gpio05_mux_sel.q", 0, 2);
         pad_gpio05_mux_sel.build();

         pad_gpio06_cfg = siracusa_pads_debug_config_pad_gpio06_cfg::type_id::create("pad_gpio06_cfg");
         pad_gpio06_cfg.configure(this, null, "");
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_tx_en.q", 9, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_st_en.q", 8, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_ret_en.q", 7, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_pull_sel.q", 6, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_pull_en.q", 5, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv3.q", 4, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv2.q", 3, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv1.q", 2, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_drv0.q", 1, 1);
         pad_gpio06_cfg.add_hdl_path_slice("u_pad_gpio06_cfg_chip2pad.q", 0, 1);
         pad_gpio06_cfg.build();

         pad_gpio06_mux_sel = siracusa_pads_debug_config_pad_gpio06_mux_sel::type_id::create("pad_gpio06_mux_sel");
         pad_gpio06_mux_sel.configure(this, null, "");
         pad_gpio06_mux_sel.add_hdl_path_slice("u_pad_gpio06_mux_sel.q", 0, 4);
         pad_gpio06_mux_sel.build();

         pad_gpio07_cfg = siracusa_pads_debug_config_pad_gpio07_cfg::type_id::create("pad_gpio07_cfg");
         pad_gpio07_cfg.configure(this, null, "");
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_tx_en.q", 9, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_st_en.q", 8, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_ret_en.q", 7, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_pull_sel.q", 6, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_pull_en.q", 5, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv3.q", 4, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv2.q", 3, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv1.q", 2, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_drv0.q", 1, 1);
         pad_gpio07_cfg.add_hdl_path_slice("u_pad_gpio07_cfg_chip2pad.q", 0, 1);
         pad_gpio07_cfg.build();

         pad_gpio07_mux_sel = siracusa_pads_debug_config_pad_gpio07_mux_sel::type_id::create("pad_gpio07_mux_sel");
         pad_gpio07_mux_sel.configure(this, null, "");
         pad_gpio07_mux_sel.add_hdl_path_slice("u_pad_gpio07_mux_sel.q", 0, 4);
         pad_gpio07_mux_sel.build();

         pad_gpio08_cfg = siracusa_pads_debug_config_pad_gpio08_cfg::type_id::create("pad_gpio08_cfg");
         pad_gpio08_cfg.configure(this, null, "");
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_tx_en.q", 9, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_st_en.q", 8, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_ret_en.q", 7, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_pull_sel.q", 6, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_pull_en.q", 5, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv3.q", 4, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv2.q", 3, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv1.q", 2, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_drv0.q", 1, 1);
         pad_gpio08_cfg.add_hdl_path_slice("u_pad_gpio08_cfg_chip2pad.q", 0, 1);
         pad_gpio08_cfg.build();

         pad_gpio08_mux_sel = siracusa_pads_debug_config_pad_gpio08_mux_sel::type_id::create("pad_gpio08_mux_sel");
         pad_gpio08_mux_sel.configure(this, null, "");
         pad_gpio08_mux_sel.add_hdl_path_slice("u_pad_gpio08_mux_sel.q", 0, 4);
         pad_gpio08_mux_sel.build();

         pad_gpio09_cfg = siracusa_pads_debug_config_pad_gpio09_cfg::type_id::create("pad_gpio09_cfg");
         pad_gpio09_cfg.configure(this, null, "");
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_tx_en.q", 9, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_st_en.q", 8, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_ret_en.q", 7, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_pull_sel.q", 6, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_pull_en.q", 5, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv3.q", 4, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv2.q", 3, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv1.q", 2, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_drv0.q", 1, 1);
         pad_gpio09_cfg.add_hdl_path_slice("u_pad_gpio09_cfg_chip2pad.q", 0, 1);
         pad_gpio09_cfg.build();

         pad_gpio09_mux_sel = siracusa_pads_debug_config_pad_gpio09_mux_sel::type_id::create("pad_gpio09_mux_sel");
         pad_gpio09_mux_sel.configure(this, null, "");
         pad_gpio09_mux_sel.add_hdl_path_slice("u_pad_gpio09_mux_sel.q", 0, 4);
         pad_gpio09_mux_sel.build();

         pad_gpio10_cfg = siracusa_pads_debug_config_pad_gpio10_cfg::type_id::create("pad_gpio10_cfg");
         pad_gpio10_cfg.configure(this, null, "");
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_tx_en.q", 9, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_st_en.q", 8, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_ret_en.q", 7, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_pull_sel.q", 6, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_pull_en.q", 5, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv3.q", 4, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv2.q", 3, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv1.q", 2, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_drv0.q", 1, 1);
         pad_gpio10_cfg.add_hdl_path_slice("u_pad_gpio10_cfg_chip2pad.q", 0, 1);
         pad_gpio10_cfg.build();

         pad_gpio10_mux_sel = siracusa_pads_debug_config_pad_gpio10_mux_sel::type_id::create("pad_gpio10_mux_sel");
         pad_gpio10_mux_sel.configure(this, null, "");
         pad_gpio10_mux_sel.add_hdl_path_slice("u_pad_gpio10_mux_sel.q", 0, 4);
         pad_gpio10_mux_sel.build();

         pad_gpio11_cfg = siracusa_pads_debug_config_pad_gpio11_cfg::type_id::create("pad_gpio11_cfg");
         pad_gpio11_cfg.configure(this, null, "");
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_tx_en.q", 9, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_st_en.q", 8, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_ret_en.q", 7, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_pull_sel.q", 6, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_pull_en.q", 5, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv3.q", 4, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv2.q", 3, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv1.q", 2, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_drv0.q", 1, 1);
         pad_gpio11_cfg.add_hdl_path_slice("u_pad_gpio11_cfg_chip2pad.q", 0, 1);
         pad_gpio11_cfg.build();

         pad_gpio11_mux_sel = siracusa_pads_debug_config_pad_gpio11_mux_sel::type_id::create("pad_gpio11_mux_sel");
         pad_gpio11_mux_sel.configure(this, null, "");
         pad_gpio11_mux_sel.add_hdl_path_slice("u_pad_gpio11_mux_sel.q", 0, 4);
         pad_gpio11_mux_sel.build();

         pad_gpio12_cfg = siracusa_pads_debug_config_pad_gpio12_cfg::type_id::create("pad_gpio12_cfg");
         pad_gpio12_cfg.configure(this, null, "");
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_tx_en.q", 9, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_st_en.q", 8, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_ret_en.q", 7, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_pull_sel.q", 6, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_pull_en.q", 5, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv3.q", 4, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv2.q", 3, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv1.q", 2, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_drv0.q", 1, 1);
         pad_gpio12_cfg.add_hdl_path_slice("u_pad_gpio12_cfg_chip2pad.q", 0, 1);
         pad_gpio12_cfg.build();

         pad_gpio12_mux_sel = siracusa_pads_debug_config_pad_gpio12_mux_sel::type_id::create("pad_gpio12_mux_sel");
         pad_gpio12_mux_sel.configure(this, null, "");
         pad_gpio12_mux_sel.add_hdl_path_slice("u_pad_gpio12_mux_sel.q", 0, 2);
         pad_gpio12_mux_sel.build();

         pad_gpio13_cfg = siracusa_pads_debug_config_pad_gpio13_cfg::type_id::create("pad_gpio13_cfg");
         pad_gpio13_cfg.configure(this, null, "");
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_tx_en.q", 9, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_st_en.q", 8, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_ret_en.q", 7, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_pull_sel.q", 6, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_pull_en.q", 5, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv3.q", 4, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv2.q", 3, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv1.q", 2, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_drv0.q", 1, 1);
         pad_gpio13_cfg.add_hdl_path_slice("u_pad_gpio13_cfg_chip2pad.q", 0, 1);
         pad_gpio13_cfg.build();

         pad_gpio13_mux_sel = siracusa_pads_debug_config_pad_gpio13_mux_sel::type_id::create("pad_gpio13_mux_sel");
         pad_gpio13_mux_sel.configure(this, null, "");
         pad_gpio13_mux_sel.add_hdl_path_slice("u_pad_gpio13_mux_sel.q", 0, 2);
         pad_gpio13_mux_sel.build();

         pad_gpio14_cfg = siracusa_pads_debug_config_pad_gpio14_cfg::type_id::create("pad_gpio14_cfg");
         pad_gpio14_cfg.configure(this, null, "");
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_tx_en.q", 9, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_st_en.q", 8, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_ret_en.q", 7, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_pull_sel.q", 6, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_pull_en.q", 5, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv3.q", 4, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv2.q", 3, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv1.q", 2, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_drv0.q", 1, 1);
         pad_gpio14_cfg.add_hdl_path_slice("u_pad_gpio14_cfg_chip2pad.q", 0, 1);
         pad_gpio14_cfg.build();

         pad_gpio14_mux_sel = siracusa_pads_debug_config_pad_gpio14_mux_sel::type_id::create("pad_gpio14_mux_sel");
         pad_gpio14_mux_sel.configure(this, null, "");
         pad_gpio14_mux_sel.add_hdl_path_slice("u_pad_gpio14_mux_sel.q", 0, 2);
         pad_gpio14_mux_sel.build();

         pad_gpio15_cfg = siracusa_pads_debug_config_pad_gpio15_cfg::type_id::create("pad_gpio15_cfg");
         pad_gpio15_cfg.configure(this, null, "");
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_tx_en.q", 9, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_st_en.q", 8, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_ret_en.q", 7, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_pull_sel.q", 6, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_pull_en.q", 5, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv3.q", 4, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv2.q", 3, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv1.q", 2, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_drv0.q", 1, 1);
         pad_gpio15_cfg.add_hdl_path_slice("u_pad_gpio15_cfg_chip2pad.q", 0, 1);
         pad_gpio15_cfg.build();

         pad_gpio15_mux_sel = siracusa_pads_debug_config_pad_gpio15_mux_sel::type_id::create("pad_gpio15_mux_sel");
         pad_gpio15_mux_sel.configure(this, null, "");
         pad_gpio15_mux_sel.add_hdl_path_slice("u_pad_gpio15_mux_sel.q", 0, 2);
         pad_gpio15_mux_sel.build();

         pad_gpio16_cfg = siracusa_pads_debug_config_pad_gpio16_cfg::type_id::create("pad_gpio16_cfg");
         pad_gpio16_cfg.configure(this, null, "");
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_tx_en.q", 9, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_st_en.q", 8, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_ret_en.q", 7, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_pull_sel.q", 6, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_pull_en.q", 5, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv3.q", 4, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv2.q", 3, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv1.q", 2, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_drv0.q", 1, 1);
         pad_gpio16_cfg.add_hdl_path_slice("u_pad_gpio16_cfg_chip2pad.q", 0, 1);
         pad_gpio16_cfg.build();

         pad_gpio16_mux_sel = siracusa_pads_debug_config_pad_gpio16_mux_sel::type_id::create("pad_gpio16_mux_sel");
         pad_gpio16_mux_sel.configure(this, null, "");
         pad_gpio16_mux_sel.add_hdl_path_slice("u_pad_gpio16_mux_sel.q", 0, 2);
         pad_gpio16_mux_sel.build();

         pad_gpio17_cfg = siracusa_pads_debug_config_pad_gpio17_cfg::type_id::create("pad_gpio17_cfg");
         pad_gpio17_cfg.configure(this, null, "");
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_tx_en.q", 9, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_st_en.q", 8, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_ret_en.q", 7, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_pull_sel.q", 6, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_pull_en.q", 5, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv3.q", 4, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv2.q", 3, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv1.q", 2, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_drv0.q", 1, 1);
         pad_gpio17_cfg.add_hdl_path_slice("u_pad_gpio17_cfg_chip2pad.q", 0, 1);
         pad_gpio17_cfg.build();

         pad_gpio17_mux_sel = siracusa_pads_debug_config_pad_gpio17_mux_sel::type_id::create("pad_gpio17_mux_sel");
         pad_gpio17_mux_sel.configure(this, null, "");
         pad_gpio17_mux_sel.add_hdl_path_slice("u_pad_gpio17_mux_sel.q", 0, 2);
         pad_gpio17_mux_sel.build();

         pad_gpio18_cfg = siracusa_pads_debug_config_pad_gpio18_cfg::type_id::create("pad_gpio18_cfg");
         pad_gpio18_cfg.configure(this, null, "");
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_tx_en.q", 9, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_st_en.q", 8, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_ret_en.q", 7, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_pull_sel.q", 6, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_pull_en.q", 5, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv3.q", 4, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv2.q", 3, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv1.q", 2, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_drv0.q", 1, 1);
         pad_gpio18_cfg.add_hdl_path_slice("u_pad_gpio18_cfg_chip2pad.q", 0, 1);
         pad_gpio18_cfg.build();

         pad_gpio18_mux_sel = siracusa_pads_debug_config_pad_gpio18_mux_sel::type_id::create("pad_gpio18_mux_sel");
         pad_gpio18_mux_sel.configure(this, null, "");
         pad_gpio18_mux_sel.add_hdl_path_slice("u_pad_gpio18_mux_sel.q", 0, 2);
         pad_gpio18_mux_sel.build();

         pad_gpio19_cfg = siracusa_pads_debug_config_pad_gpio19_cfg::type_id::create("pad_gpio19_cfg");
         pad_gpio19_cfg.configure(this, null, "");
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_tx_en.q", 9, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_st_en.q", 8, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_ret_en.q", 7, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_pull_sel.q", 6, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_pull_en.q", 5, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv3.q", 4, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv2.q", 3, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv1.q", 2, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_drv0.q", 1, 1);
         pad_gpio19_cfg.add_hdl_path_slice("u_pad_gpio19_cfg_chip2pad.q", 0, 1);
         pad_gpio19_cfg.build();

         pad_gpio19_mux_sel = siracusa_pads_debug_config_pad_gpio19_mux_sel::type_id::create("pad_gpio19_mux_sel");
         pad_gpio19_mux_sel.configure(this, null, "");
         pad_gpio19_mux_sel.add_hdl_path_slice("u_pad_gpio19_mux_sel.q", 0, 2);
         pad_gpio19_mux_sel.build();

         pad_gpio20_cfg = siracusa_pads_debug_config_pad_gpio20_cfg::type_id::create("pad_gpio20_cfg");
         pad_gpio20_cfg.configure(this, null, "");
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_tx_en.q", 9, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_st_en.q", 8, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_ret_en.q", 7, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_pull_sel.q", 6, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_pull_en.q", 5, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv3.q", 4, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv2.q", 3, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv1.q", 2, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_drv0.q", 1, 1);
         pad_gpio20_cfg.add_hdl_path_slice("u_pad_gpio20_cfg_chip2pad.q", 0, 1);
         pad_gpio20_cfg.build();

         pad_gpio20_mux_sel = siracusa_pads_debug_config_pad_gpio20_mux_sel::type_id::create("pad_gpio20_mux_sel");
         pad_gpio20_mux_sel.configure(this, null, "");
         pad_gpio20_mux_sel.add_hdl_path_slice("u_pad_gpio20_mux_sel.q", 0, 2);
         pad_gpio20_mux_sel.build();

         pad_gpio21_cfg = siracusa_pads_debug_config_pad_gpio21_cfg::type_id::create("pad_gpio21_cfg");
         pad_gpio21_cfg.configure(this, null, "");
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_tx_en.q", 9, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_st_en.q", 8, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_ret_en.q", 7, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_pull_sel.q", 6, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_pull_en.q", 5, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv3.q", 4, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv2.q", 3, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv1.q", 2, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_drv0.q", 1, 1);
         pad_gpio21_cfg.add_hdl_path_slice("u_pad_gpio21_cfg_chip2pad.q", 0, 1);
         pad_gpio21_cfg.build();

         pad_gpio21_mux_sel = siracusa_pads_debug_config_pad_gpio21_mux_sel::type_id::create("pad_gpio21_mux_sel");
         pad_gpio21_mux_sel.configure(this, null, "");
         pad_gpio21_mux_sel.add_hdl_path_slice("u_pad_gpio21_mux_sel.q", 0, 2);
         pad_gpio21_mux_sel.build();

         pad_gpio22_cfg = siracusa_pads_debug_config_pad_gpio22_cfg::type_id::create("pad_gpio22_cfg");
         pad_gpio22_cfg.configure(this, null, "");
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_tx_en.q", 9, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_st_en.q", 8, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_ret_en.q", 7, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_pull_sel.q", 6, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_pull_en.q", 5, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv3.q", 4, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv2.q", 3, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv1.q", 2, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_drv0.q", 1, 1);
         pad_gpio22_cfg.add_hdl_path_slice("u_pad_gpio22_cfg_chip2pad.q", 0, 1);
         pad_gpio22_cfg.build();

         pad_gpio22_mux_sel = siracusa_pads_debug_config_pad_gpio22_mux_sel::type_id::create("pad_gpio22_mux_sel");
         pad_gpio22_mux_sel.configure(this, null, "");
         pad_gpio22_mux_sel.add_hdl_path_slice("u_pad_gpio22_mux_sel.q", 0, 2);
         pad_gpio22_mux_sel.build();

         pad_gpio23_cfg = siracusa_pads_debug_config_pad_gpio23_cfg::type_id::create("pad_gpio23_cfg");
         pad_gpio23_cfg.configure(this, null, "");
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_tx_en.q", 9, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_st_en.q", 8, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_ret_en.q", 7, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_pull_sel.q", 6, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_pull_en.q", 5, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv3.q", 4, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv2.q", 3, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv1.q", 2, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_drv0.q", 1, 1);
         pad_gpio23_cfg.add_hdl_path_slice("u_pad_gpio23_cfg_chip2pad.q", 0, 1);
         pad_gpio23_cfg.build();

         pad_gpio23_mux_sel = siracusa_pads_debug_config_pad_gpio23_mux_sel::type_id::create("pad_gpio23_mux_sel");
         pad_gpio23_mux_sel.configure(this, null, "");
         pad_gpio23_mux_sel.add_hdl_path_slice("u_pad_gpio23_mux_sel.q", 0, 2);
         pad_gpio23_mux_sel.build();

         pad_gpio24_cfg = siracusa_pads_debug_config_pad_gpio24_cfg::type_id::create("pad_gpio24_cfg");
         pad_gpio24_cfg.configure(this, null, "");
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_tx_en.q", 9, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_st_en.q", 8, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_ret_en.q", 7, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_pull_sel.q", 6, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_pull_en.q", 5, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv3.q", 4, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv2.q", 3, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv1.q", 2, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_drv0.q", 1, 1);
         pad_gpio24_cfg.add_hdl_path_slice("u_pad_gpio24_cfg_chip2pad.q", 0, 1);
         pad_gpio24_cfg.build();

         pad_gpio24_mux_sel = siracusa_pads_debug_config_pad_gpio24_mux_sel::type_id::create("pad_gpio24_mux_sel");
         pad_gpio24_mux_sel.configure(this, null, "");
         pad_gpio24_mux_sel.add_hdl_path_slice("u_pad_gpio24_mux_sel.q", 0, 2);
         pad_gpio24_mux_sel.build();

         pad_gpio25_cfg = siracusa_pads_debug_config_pad_gpio25_cfg::type_id::create("pad_gpio25_cfg");
         pad_gpio25_cfg.configure(this, null, "");
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_tx_en.q", 9, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_st_en.q", 8, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_ret_en.q", 7, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_pull_sel.q", 6, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_pull_en.q", 5, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv3.q", 4, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv2.q", 3, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv1.q", 2, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_drv0.q", 1, 1);
         pad_gpio25_cfg.add_hdl_path_slice("u_pad_gpio25_cfg_chip2pad.q", 0, 1);
         pad_gpio25_cfg.build();

         pad_gpio25_mux_sel = siracusa_pads_debug_config_pad_gpio25_mux_sel::type_id::create("pad_gpio25_mux_sel");
         pad_gpio25_mux_sel.configure(this, null, "");
         pad_gpio25_mux_sel.add_hdl_path_slice("u_pad_gpio25_mux_sel.q", 0, 2);
         pad_gpio25_mux_sel.build();

         pad_gpio26_cfg = siracusa_pads_debug_config_pad_gpio26_cfg::type_id::create("pad_gpio26_cfg");
         pad_gpio26_cfg.configure(this, null, "");
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_tx_en.q", 9, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_st_en.q", 8, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_ret_en.q", 7, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_pull_sel.q", 6, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_pull_en.q", 5, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv3.q", 4, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv2.q", 3, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv1.q", 2, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_drv0.q", 1, 1);
         pad_gpio26_cfg.add_hdl_path_slice("u_pad_gpio26_cfg_chip2pad.q", 0, 1);
         pad_gpio26_cfg.build();

         pad_gpio26_mux_sel = siracusa_pads_debug_config_pad_gpio26_mux_sel::type_id::create("pad_gpio26_mux_sel");
         pad_gpio26_mux_sel.configure(this, null, "");
         pad_gpio26_mux_sel.add_hdl_path_slice("u_pad_gpio26_mux_sel.q", 0, 2);
         pad_gpio26_mux_sel.build();

         pad_gpio27_cfg = siracusa_pads_debug_config_pad_gpio27_cfg::type_id::create("pad_gpio27_cfg");
         pad_gpio27_cfg.configure(this, null, "");
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_tx_en.q", 9, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_st_en.q", 8, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_ret_en.q", 7, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_pull_sel.q", 6, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_pull_en.q", 5, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv3.q", 4, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv2.q", 3, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv1.q", 2, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_drv0.q", 1, 1);
         pad_gpio27_cfg.add_hdl_path_slice("u_pad_gpio27_cfg_chip2pad.q", 0, 1);
         pad_gpio27_cfg.build();

         pad_gpio27_mux_sel = siracusa_pads_debug_config_pad_gpio27_mux_sel::type_id::create("pad_gpio27_mux_sel");
         pad_gpio27_mux_sel.configure(this, null, "");
         pad_gpio27_mux_sel.add_hdl_path_slice("u_pad_gpio27_mux_sel.q", 0, 2);
         pad_gpio27_mux_sel.build();

         pad_gpio28_cfg = siracusa_pads_debug_config_pad_gpio28_cfg::type_id::create("pad_gpio28_cfg");
         pad_gpio28_cfg.configure(this, null, "");
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_tx_en.q", 9, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_st_en.q", 8, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_ret_en.q", 7, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_pull_sel.q", 6, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_pull_en.q", 5, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv3.q", 4, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv2.q", 3, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv1.q", 2, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_drv0.q", 1, 1);
         pad_gpio28_cfg.add_hdl_path_slice("u_pad_gpio28_cfg_chip2pad.q", 0, 1);
         pad_gpio28_cfg.build();

         pad_gpio28_mux_sel = siracusa_pads_debug_config_pad_gpio28_mux_sel::type_id::create("pad_gpio28_mux_sel");
         pad_gpio28_mux_sel.configure(this, null, "");
         pad_gpio28_mux_sel.add_hdl_path_slice("u_pad_gpio28_mux_sel.q", 0, 2);
         pad_gpio28_mux_sel.build();

         pad_gpio29_cfg = siracusa_pads_debug_config_pad_gpio29_cfg::type_id::create("pad_gpio29_cfg");
         pad_gpio29_cfg.configure(this, null, "");
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_tx_en.q", 9, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_st_en.q", 8, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_ret_en.q", 7, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_pull_sel.q", 6, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_pull_en.q", 5, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv3.q", 4, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv2.q", 3, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv1.q", 2, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_drv0.q", 1, 1);
         pad_gpio29_cfg.add_hdl_path_slice("u_pad_gpio29_cfg_chip2pad.q", 0, 1);
         pad_gpio29_cfg.build();

         pad_gpio29_mux_sel = siracusa_pads_debug_config_pad_gpio29_mux_sel::type_id::create("pad_gpio29_mux_sel");
         pad_gpio29_mux_sel.configure(this, null, "");
         pad_gpio29_mux_sel.add_hdl_path_slice("u_pad_gpio29_mux_sel.q", 0, 2);
         pad_gpio29_mux_sel.build();

         pad_gpio30_cfg = siracusa_pads_debug_config_pad_gpio30_cfg::type_id::create("pad_gpio30_cfg");
         pad_gpio30_cfg.configure(this, null, "");
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_tx_en.q", 9, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_st_en.q", 8, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_ret_en.q", 7, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_pull_sel.q", 6, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_pull_en.q", 5, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv3.q", 4, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv2.q", 3, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv1.q", 2, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_drv0.q", 1, 1);
         pad_gpio30_cfg.add_hdl_path_slice("u_pad_gpio30_cfg_chip2pad.q", 0, 1);
         pad_gpio30_cfg.build();

         pad_gpio30_mux_sel = siracusa_pads_debug_config_pad_gpio30_mux_sel::type_id::create("pad_gpio30_mux_sel");
         pad_gpio30_mux_sel.configure(this, null, "");
         pad_gpio30_mux_sel.add_hdl_path_slice("u_pad_gpio30_mux_sel.q", 0, 2);
         pad_gpio30_mux_sel.build();

         pad_gpio31_cfg = siracusa_pads_debug_config_pad_gpio31_cfg::type_id::create("pad_gpio31_cfg");
         pad_gpio31_cfg.configure(this, null, "");
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_tx_en.q", 9, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_st_en.q", 8, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_ret_en.q", 7, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_pull_sel.q", 6, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_pull_en.q", 5, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv3.q", 4, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv2.q", 3, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv1.q", 2, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_drv0.q", 1, 1);
         pad_gpio31_cfg.add_hdl_path_slice("u_pad_gpio31_cfg_chip2pad.q", 0, 1);
         pad_gpio31_cfg.build();

         pad_gpio31_mux_sel = siracusa_pads_debug_config_pad_gpio31_mux_sel::type_id::create("pad_gpio31_mux_sel");
         pad_gpio31_mux_sel.configure(this, null, "");
         pad_gpio31_mux_sel.add_hdl_path_slice("u_pad_gpio31_mux_sel.q", 0, 2);
         pad_gpio31_mux_sel.build();

         pad_gpio32_cfg = siracusa_pads_debug_config_pad_gpio32_cfg::type_id::create("pad_gpio32_cfg");
         pad_gpio32_cfg.configure(this, null, "");
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_tx_en.q", 9, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_st_en.q", 8, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_ret_en.q", 7, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_pull_sel.q", 6, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_pull_en.q", 5, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv3.q", 4, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv2.q", 3, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv1.q", 2, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_drv0.q", 1, 1);
         pad_gpio32_cfg.add_hdl_path_slice("u_pad_gpio32_cfg_chip2pad.q", 0, 1);
         pad_gpio32_cfg.build();

         pad_gpio32_mux_sel = siracusa_pads_debug_config_pad_gpio32_mux_sel::type_id::create("pad_gpio32_mux_sel");
         pad_gpio32_mux_sel.configure(this, null, "");
         pad_gpio32_mux_sel.add_hdl_path_slice("u_pad_gpio32_mux_sel.q", 0, 2);
         pad_gpio32_mux_sel.build();

         pad_gpio33_cfg = siracusa_pads_debug_config_pad_gpio33_cfg::type_id::create("pad_gpio33_cfg");
         pad_gpio33_cfg.configure(this, null, "");
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_tx_en.q", 9, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_st_en.q", 8, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_ret_en.q", 7, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_pull_sel.q", 6, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_pull_en.q", 5, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv3.q", 4, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv2.q", 3, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv1.q", 2, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_drv0.q", 1, 1);
         pad_gpio33_cfg.add_hdl_path_slice("u_pad_gpio33_cfg_chip2pad.q", 0, 1);
         pad_gpio33_cfg.build();

         pad_gpio33_mux_sel = siracusa_pads_debug_config_pad_gpio33_mux_sel::type_id::create("pad_gpio33_mux_sel");
         pad_gpio33_mux_sel.configure(this, null, "");
         pad_gpio33_mux_sel.add_hdl_path_slice("u_pad_gpio33_mux_sel.q", 0, 2);
         pad_gpio33_mux_sel.build();

         pad_gpio34_cfg = siracusa_pads_debug_config_pad_gpio34_cfg::type_id::create("pad_gpio34_cfg");
         pad_gpio34_cfg.configure(this, null, "");
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_tx_en.q", 9, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_st_en.q", 8, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_ret_en.q", 7, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_pull_sel.q", 6, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_pull_en.q", 5, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv3.q", 4, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv2.q", 3, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv1.q", 2, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_drv0.q", 1, 1);
         pad_gpio34_cfg.add_hdl_path_slice("u_pad_gpio34_cfg_chip2pad.q", 0, 1);
         pad_gpio34_cfg.build();

         pad_gpio34_mux_sel = siracusa_pads_debug_config_pad_gpio34_mux_sel::type_id::create("pad_gpio34_mux_sel");
         pad_gpio34_mux_sel.configure(this, null, "");
         pad_gpio34_mux_sel.add_hdl_path_slice("u_pad_gpio34_mux_sel.q", 0, 2);
         pad_gpio34_mux_sel.build();

         pad_gpio35_cfg = siracusa_pads_debug_config_pad_gpio35_cfg::type_id::create("pad_gpio35_cfg");
         pad_gpio35_cfg.configure(this, null, "");
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_tx_en.q", 9, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_st_en.q", 8, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_ret_en.q", 7, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_pull_sel.q", 6, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_pull_en.q", 5, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv3.q", 4, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv2.q", 3, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv1.q", 2, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_drv0.q", 1, 1);
         pad_gpio35_cfg.add_hdl_path_slice("u_pad_gpio35_cfg_chip2pad.q", 0, 1);
         pad_gpio35_cfg.build();

         pad_gpio35_mux_sel = siracusa_pads_debug_config_pad_gpio35_mux_sel::type_id::create("pad_gpio35_mux_sel");
         pad_gpio35_mux_sel.configure(this, null, "");
         pad_gpio35_mux_sel.add_hdl_path_slice("u_pad_gpio35_mux_sel.q", 0, 2);
         pad_gpio35_mux_sel.build();

         pad_gpio36_cfg = siracusa_pads_debug_config_pad_gpio36_cfg::type_id::create("pad_gpio36_cfg");
         pad_gpio36_cfg.configure(this, null, "");
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_tx_en.q", 9, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_st_en.q", 8, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_ret_en.q", 7, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_pull_sel.q", 6, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_pull_en.q", 5, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv3.q", 4, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv2.q", 3, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv1.q", 2, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_drv0.q", 1, 1);
         pad_gpio36_cfg.add_hdl_path_slice("u_pad_gpio36_cfg_chip2pad.q", 0, 1);
         pad_gpio36_cfg.build();

         pad_gpio36_mux_sel = siracusa_pads_debug_config_pad_gpio36_mux_sel::type_id::create("pad_gpio36_mux_sel");
         pad_gpio36_mux_sel.configure(this, null, "");
         pad_gpio36_mux_sel.add_hdl_path_slice("u_pad_gpio36_mux_sel.q", 0, 2);
         pad_gpio36_mux_sel.build();

         pad_gpio37_cfg = siracusa_pads_debug_config_pad_gpio37_cfg::type_id::create("pad_gpio37_cfg");
         pad_gpio37_cfg.configure(this, null, "");
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_tx_en.q", 9, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_st_en.q", 8, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_ret_en.q", 7, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_pull_sel.q", 6, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_pull_en.q", 5, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv3.q", 4, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv2.q", 3, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv1.q", 2, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_drv0.q", 1, 1);
         pad_gpio37_cfg.add_hdl_path_slice("u_pad_gpio37_cfg_chip2pad.q", 0, 1);
         pad_gpio37_cfg.build();

         pad_gpio37_mux_sel = siracusa_pads_debug_config_pad_gpio37_mux_sel::type_id::create("pad_gpio37_mux_sel");
         pad_gpio37_mux_sel.configure(this, null, "");
         pad_gpio37_mux_sel.add_hdl_path_slice("u_pad_gpio37_mux_sel.q", 0, 2);
         pad_gpio37_mux_sel.build();

         pad_gpio38_cfg = siracusa_pads_debug_config_pad_gpio38_cfg::type_id::create("pad_gpio38_cfg");
         pad_gpio38_cfg.configure(this, null, "");
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_tx_en.q", 9, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_st_en.q", 8, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_ret_en.q", 7, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_pull_sel.q", 6, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_pull_en.q", 5, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv3.q", 4, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv2.q", 3, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv1.q", 2, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_drv0.q", 1, 1);
         pad_gpio38_cfg.add_hdl_path_slice("u_pad_gpio38_cfg_chip2pad.q", 0, 1);
         pad_gpio38_cfg.build();

         pad_gpio38_mux_sel = siracusa_pads_debug_config_pad_gpio38_mux_sel::type_id::create("pad_gpio38_mux_sel");
         pad_gpio38_mux_sel.configure(this, null, "");
         pad_gpio38_mux_sel.add_hdl_path_slice("u_pad_gpio38_mux_sel.q", 0, 2);
         pad_gpio38_mux_sel.build();

         pad_gpio39_cfg = siracusa_pads_debug_config_pad_gpio39_cfg::type_id::create("pad_gpio39_cfg");
         pad_gpio39_cfg.configure(this, null, "");
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_tx_en.q", 9, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_st_en.q", 8, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_ret_en.q", 7, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_pull_sel.q", 6, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_pull_en.q", 5, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv3.q", 4, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv2.q", 3, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv1.q", 2, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_drv0.q", 1, 1);
         pad_gpio39_cfg.add_hdl_path_slice("u_pad_gpio39_cfg_chip2pad.q", 0, 1);
         pad_gpio39_cfg.build();

         pad_gpio39_mux_sel = siracusa_pads_debug_config_pad_gpio39_mux_sel::type_id::create("pad_gpio39_mux_sel");
         pad_gpio39_mux_sel.configure(this, null, "");
         pad_gpio39_mux_sel.add_hdl_path_slice("u_pad_gpio39_mux_sel.q", 0, 2);
         pad_gpio39_mux_sel.build();

         pad_gpio40_cfg = siracusa_pads_debug_config_pad_gpio40_cfg::type_id::create("pad_gpio40_cfg");
         pad_gpio40_cfg.configure(this, null, "");
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_tx_en.q", 9, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_st_en.q", 8, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_ret_en.q", 7, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_pull_sel.q", 6, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_pull_en.q", 5, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv3.q", 4, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv2.q", 3, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv1.q", 2, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_drv0.q", 1, 1);
         pad_gpio40_cfg.add_hdl_path_slice("u_pad_gpio40_cfg_chip2pad.q", 0, 1);
         pad_gpio40_cfg.build();

         pad_gpio40_mux_sel = siracusa_pads_debug_config_pad_gpio40_mux_sel::type_id::create("pad_gpio40_mux_sel");
         pad_gpio40_mux_sel.configure(this, null, "");
         pad_gpio40_mux_sel.add_hdl_path_slice("u_pad_gpio40_mux_sel.q", 0, 2);
         pad_gpio40_mux_sel.build();

         pad_gpio41_cfg = siracusa_pads_debug_config_pad_gpio41_cfg::type_id::create("pad_gpio41_cfg");
         pad_gpio41_cfg.configure(this, null, "");
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_tx_en.q", 9, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_st_en.q", 8, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_ret_en.q", 7, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_pull_sel.q", 6, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_pull_en.q", 5, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv3.q", 4, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv2.q", 3, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv1.q", 2, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_drv0.q", 1, 1);
         pad_gpio41_cfg.add_hdl_path_slice("u_pad_gpio41_cfg_chip2pad.q", 0, 1);
         pad_gpio41_cfg.build();

         pad_gpio41_mux_sel = siracusa_pads_debug_config_pad_gpio41_mux_sel::type_id::create("pad_gpio41_mux_sel");
         pad_gpio41_mux_sel.configure(this, null, "");
         pad_gpio41_mux_sel.add_hdl_path_slice("u_pad_gpio41_mux_sel.q", 0, 2);
         pad_gpio41_mux_sel.build();

         pad_gpio42_cfg = siracusa_pads_debug_config_pad_gpio42_cfg::type_id::create("pad_gpio42_cfg");
         pad_gpio42_cfg.configure(this, null, "");
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_tx_en.q", 9, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_st_en.q", 8, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_ret_en.q", 7, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_pull_sel.q", 6, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_pull_en.q", 5, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv3.q", 4, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv2.q", 3, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv1.q", 2, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_drv0.q", 1, 1);
         pad_gpio42_cfg.add_hdl_path_slice("u_pad_gpio42_cfg_chip2pad.q", 0, 1);
         pad_gpio42_cfg.build();

         pad_gpio42_mux_sel = siracusa_pads_debug_config_pad_gpio42_mux_sel::type_id::create("pad_gpio42_mux_sel");
         pad_gpio42_mux_sel.configure(this, null, "");
         pad_gpio42_mux_sel.add_hdl_path_slice("u_pad_gpio42_mux_sel.q", 0, 2);
         pad_gpio42_mux_sel.build();

         siracusa_pads_debug_config_map = create_map("siracusa_pads_debug_config_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = siracusa_pads_debug_config_map;

         siracusa_pads_debug_config_map.add_reg(pad_gpio00_cfg, 'h158, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio00_mux_sel, 'h15c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio01_cfg, 'h160, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio01_mux_sel, 'h164, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio02_cfg, 'h168, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio02_mux_sel, 'h16c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio03_cfg, 'h170, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio03_mux_sel, 'h174, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio04_cfg, 'h178, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio04_mux_sel, 'h17c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio05_cfg, 'h180, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio05_mux_sel, 'h184, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio06_cfg, 'h188, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio06_mux_sel, 'h18c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio07_cfg, 'h190, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio07_mux_sel, 'h194, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio08_cfg, 'h198, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio08_mux_sel, 'h19c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio09_cfg, 'h1a0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio09_mux_sel, 'h1a4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio10_cfg, 'h1a8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio10_mux_sel, 'h1ac, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio11_cfg, 'h1b0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio11_mux_sel, 'h1b4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio12_cfg, 'h1b8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio12_mux_sel, 'h1bc, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio13_cfg, 'h1c0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio13_mux_sel, 'h1c4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio14_cfg, 'h1c8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio14_mux_sel, 'h1cc, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio15_cfg, 'h1d0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio15_mux_sel, 'h1d4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio16_cfg, 'h1d8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio16_mux_sel, 'h1dc, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio17_cfg, 'h1e0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio17_mux_sel, 'h1e4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio18_cfg, 'h1e8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio18_mux_sel, 'h1ec, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio19_cfg, 'h1f0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio19_mux_sel, 'h1f4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio20_cfg, 'h1f8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio20_mux_sel, 'h1fc, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio21_cfg, 'h200, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio21_mux_sel, 'h204, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio22_cfg, 'h208, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio22_mux_sel, 'h20c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio23_cfg, 'h210, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio23_mux_sel, 'h214, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio24_cfg, 'h218, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio24_mux_sel, 'h21c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio25_cfg, 'h220, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio25_mux_sel, 'h224, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio26_cfg, 'h228, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio26_mux_sel, 'h22c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio27_cfg, 'h230, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio27_mux_sel, 'h234, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio28_cfg, 'h238, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio28_mux_sel, 'h23c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio29_cfg, 'h240, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio29_mux_sel, 'h244, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio30_cfg, 'h248, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio30_mux_sel, 'h24c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio31_cfg, 'h250, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio31_mux_sel, 'h254, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio32_cfg, 'h258, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio32_mux_sel, 'h25c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio33_cfg, 'h260, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio33_mux_sel, 'h264, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio34_cfg, 'h268, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio34_mux_sel, 'h26c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio35_cfg, 'h270, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio35_mux_sel, 'h274, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio36_cfg, 'h278, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio36_mux_sel, 'h27c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio37_cfg, 'h280, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio37_mux_sel, 'h284, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio38_cfg, 'h288, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio38_mux_sel, 'h28c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio39_cfg, 'h290, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio39_mux_sel, 'h294, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio40_cfg, 'h298, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio40_mux_sel, 'h29c, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio41_cfg, 'h2a0, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio41_mux_sel, 'h2a4, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio42_cfg, 'h2a8, "RW");
         siracusa_pads_debug_config_map.add_reg(pad_gpio42_mux_sel, 'h2ac, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_ctrl_block
   // 
   //--------------------------------------------------------------------

   class siracusa_ctrl_block extends uvm_reg_block;
      `uvm_object_utils(siracusa_ctrl_block)

      rand siracusa_ctrl_pad_dbg_mode_en_0 pad_dbg_mode_en_0; // Enable the corresponding GPIO pads debug functionality.
      rand siracusa_ctrl_pad_dbg_mode_en_1 pad_dbg_mode_en_1; // Enable the corresponding GPIO pads debug functionality.

      uvm_reg_map siracusa_ctrl_map; // Default Map


      // Function: new
      // 
      function new(string name = "siracusa_ctrl_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         pad_dbg_mode_en_0 = siracusa_ctrl_pad_dbg_mode_en_0::type_id::create("pad_dbg_mode_en_0");
         pad_dbg_mode_en_0.configure(this, null, "");
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_31.q", 31, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_30.q", 30, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_29.q", 29, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_28.q", 28, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_27.q", 27, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_26.q", 26, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_25.q", 25, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_24.q", 24, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_23.q", 23, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_22.q", 22, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_21.q", 21, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_20.q", 20, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_19.q", 19, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_18.q", 18, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_17.q", 17, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_16.q", 16, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_15.q", 15, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_14.q", 14, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_13.q", 13, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_12.q", 12, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_11.q", 11, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_10.q", 10, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_9.q", 9, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_8.q", 8, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_7.q", 7, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_6.q", 6, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_5.q", 5, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_4.q", 4, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_3.q", 3, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_2.q", 2, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_1.q", 1, 1);
         pad_dbg_mode_en_0.add_hdl_path_slice("u_pad_dbg_mode_en_0_pad_dbg_mode_en_0.q", 0, 1);
         pad_dbg_mode_en_0.build();

         pad_dbg_mode_en_1 = siracusa_ctrl_pad_dbg_mode_en_1::type_id::create("pad_dbg_mode_en_1");
         pad_dbg_mode_en_1.configure(this, null, "");
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_42.q", 10, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_41.q", 9, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_40.q", 8, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_39.q", 7, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_38.q", 6, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_37.q", 5, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_36.q", 4, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_35.q", 3, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_34.q", 2, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_33.q", 1, 1);
         pad_dbg_mode_en_1.add_hdl_path_slice("u_pad_dbg_mode_en_1_pad_dbg_mode_en_32.q", 0, 1);
         pad_dbg_mode_en_1.build();

         siracusa_ctrl_map = create_map("siracusa_ctrl_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = siracusa_ctrl_map;

         siracusa_ctrl_map.add_reg(pad_dbg_mode_en_0, 'h0, "RW");
         siracusa_ctrl_map.add_reg(pad_dbg_mode_en_1, 'h4, "RW");

         lock_model();
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: siracusa_top_block
   // 
   // Top block of siracusa
   //--------------------------------------------------------------------

   class siracusa_top_block extends uvm_reg_block;
      `uvm_object_utils(siracusa_top_block)

      rand soc_block soc; // SoC Sub block
      rand cluster_block cluster; // Cluster sub block
      rand pll_config_block soc_pll; // SoC PLL Config Register
      rand pll_config_block cluster_pll; // Cluster PLL Config Registers
      rand pll_config_block per_pll; // Peripheral PLL Config Registers
      rand siracusa_pads_functional_config_block pad_cfg_functional; // Pad Configuration Normal Mode
      rand siracusa_pads_debug_config_block pad_cfg_debug; // Pad Configuration Debug Mode
      rand siracusa_ctrl_block siracusa_ctrl; // Chip Level Debug registers

      uvm_reg_map top_map; // Mapping of the global addresspsace


      // Function: new
      // 
      function new(string name = "siracusa_top_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();

         add_hdl_path("tb.i_dut");
         soc = soc_block::type_id::create("soc");
         soc.configure(this, "soc_domain_i.pulp_soc_i");
         soc.build();

         cluster = cluster_block::type_id::create("cluster");
         cluster.configure(this, "cluster_domain_i.cluster_i");
         cluster.build();

         soc_pll = pll_config_block::type_id::create("soc_pll");
         soc_pll.configure(this, "i_soc_pll.i_regfile");
         soc_pll.build();

         cluster_pll = pll_config_block::type_id::create("cluster_pll");
         cluster_pll.configure(this, "i_cluster_pll.i_regfile");
         cluster_pll.build();

         per_pll = pll_config_block::type_id::create("per_pll");
         per_pll.configure(this, "i_per_pll.i_regfile");
         per_pll.build();

         pad_cfg_functional = siracusa_pads_functional_config_block::type_id::create("pad_cfg_functional");
         pad_cfg_functional.configure(this, "i_pads.i_siracusa_pads.i_functional_muxer.i_regfile");
         pad_cfg_functional.build();

         pad_cfg_debug = siracusa_pads_debug_config_block::type_id::create("pad_cfg_debug");
         pad_cfg_debug.configure(this, "i_pads.i_siracusa_pads.i_debug_muxer.i_regfile");
         pad_cfg_debug.build();

         siracusa_ctrl = siracusa_ctrl_block::type_id::create("siracusa_ctrl");
         siracusa_ctrl.configure(this, "i_chip_ctrl_reg_top");
         siracusa_ctrl.build();

         top_map = create_map("top_map", 'h0, 4, UVM_LITTLE_ENDIAN, 1);
         default_map = top_map;

         top_map.add_submap(soc.soc_map, 'h0);
         top_map.add_submap(cluster.cluster_map, 'h10000000);
         top_map.add_submap(soc_pll.pll_config_map, 'h1a100000);
         top_map.add_submap(cluster_pll.pll_config_map, 'h1a100010);
         top_map.add_submap(per_pll.pll_config_map, 'h1a100020);
         top_map.add_submap(pad_cfg_functional.siracusa_pads_functional_config_map, 'h1a140000);
         top_map.add_submap(pad_cfg_debug.siracusa_pads_debug_config_map, 'h1a140000);
         top_map.add_submap(siracusa_ctrl.siracusa_ctrl_map, 'h1a150000);

         lock_model();
      endfunction
   endclass


endpackage
